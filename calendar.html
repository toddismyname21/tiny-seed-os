<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visual Calendar - Tiny Seed OS</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/interactjs/dist/interact.min.js"></script>
    <style>
        :root {
            --primary: #2d5a27;
            --primary-light: #4a7c43;
            --primary-dark: #1e3d1a;
            --secondary: #f4a261;
            --accent: #e76f51;
            --success: #2a9d8f;
            --warning: #e9c46a;
            --danger: #e63946;
            --bg-dark: #1a1a2e;
            --bg-card: #16213e;
            --bg-light: #0f3460;
            --text-primary: #edf2f4;
            --text-secondary: #8d99ae;
            --border: rgba(255,255,255,0.1);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, var(--bg-dark) 0%, #0f0f1a 100%);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
        }

        .header {
            background: rgba(22, 33, 62, 0.95);
            backdrop-filter: blur(20px);
            border-bottom: 1px solid var(--border);
            padding: 1rem 2rem;
            padding-left: 300px; /* Account for sidebar width (280px) + some padding */
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1000;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .back-btn {
            background: var(--bg-light);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 10px 15px;
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.3s;
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .back-btn:hover {
            background: var(--primary);
            border-color: var(--primary);
        }

        .page-title {
            font-size: 1.5rem;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .page-title i { color: #3498db; }

        .header-controls {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .zoom-controls {
            display: flex;
            background: var(--bg-light);
            border-radius: 10px;
            overflow: hidden;
        }

        .zoom-btn {
            background: none;
            border: none;
            padding: 8px 12px;
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 500;
            font-size: 0.85rem;
            white-space: nowrap;
        }

        .zoom-btn:hover, .zoom-btn.active {
            background: var(--primary);
        }

        .sync-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            background: var(--bg-light);
            border-radius: 10px;
            font-size: 0.85rem;
        }

        .sync-indicator.syncing {
            color: var(--warning);
        }

        .sync-indicator.synced {
            color: var(--success);
        }

        .sync-indicator.error {
            color: var(--danger);
        }

        .sync-indicator.pending {
            color: var(--secondary);
        }

        .sync-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: currentColor;
        }

        .sync-indicator.syncing .sync-dot {
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        .submit-changes-btn {
            display: none;
            padding: 10px 20px;
            background: var(--secondary);
            color: var(--bg-dark);
            border: none;
            border-radius: 10px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            gap: 8px;
            align-items: center;
        }

        .submit-changes-btn.visible {
            display: flex;
        }

        .submit-changes-btn:hover {
            background: var(--accent);
            transform: translateY(-2px);
        }

        .submit-changes-btn .badge {
            background: var(--bg-dark);
            color: var(--secondary);
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.8rem;
        }

        .discard-btn {
            display: none;
            padding: 8px 12px;
            background: transparent;
            color: var(--text-secondary);
            border: 1px solid var(--border);
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.3s;
        }

        .discard-btn.visible {
            display: flex;
        }

        .discard-btn:hover {
            color: var(--danger);
            border-color: var(--danger);
        }

        .main-container {
            padding: 80px 0 0;
            min-height: 100vh;
        }

        /* Sidebar */
        .sidebar {
            position: fixed;
            top: 80px;
            left: 0;
            width: 280px;
            height: calc(100vh - 80px);
            background: var(--bg-card);
            border-right: 1px solid var(--border);
            padding: 1.5rem;
            overflow-y: auto;
            z-index: 100;
        }

        .sidebar-section {
            margin-bottom: 1.5rem;
        }

        .sidebar-title {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 1rem;
        }

        .filter-group {
            margin-bottom: 1rem;
        }

        .filter-group label {
            display: block;
            font-size: 0.85rem;
            margin-bottom: 6px;
            color: var(--text-secondary);
        }

        .filter-control {
            width: 100%;
            padding: 10px 14px;
            background: var(--bg-light);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 0.9rem;
        }

        .filter-control:focus {
            outline: none;
            border-color: var(--primary);
        }

        .checkbox-filters {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .checkbox-filter {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 12px;
            background: var(--bg-light);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .checkbox-filter:hover {
            background: var(--primary);
        }

        .checkbox-filter input {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
        }

        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        .status-dot.seeding { background: #8e44ad; }
        .status-dot.growing { background: var(--success); }
        .status-dot.harvest { background: var(--secondary); }
        .status-dot.completed { background: var(--text-secondary); }

        .legend {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 0.85rem;
        }

        .legend-color {
            width: 24px;
            height: 12px;
            border-radius: 4px;
        }

        /* Gantt Container - Main layout wrapper */
        .gantt-container {
            margin-left: 280px;
            padding: 1.5rem;
            padding-top: 0.5rem;
            position: relative;
            height: calc(100vh - 80px);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .gantt-wrapper {
            flex: 1;
            background: var(--bg-card);
            border-radius: 16px;
            border: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            min-height: 0;
        }

        /* The gantt-chart uses CSS Grid for sticky headers */
        .gantt-chart {
            flex: 1;
            display: grid;
            grid-template-columns: 200px 1fr;
            grid-template-rows: auto 1fr;
            min-height: 0;
            overflow: hidden;
        }

        /* Corner cell - top left, always visible */
        .gantt-corner {
            grid-row: 1;
            grid-column: 1;
            background: var(--bg-light);
            border-right: 2px solid var(--border);
            border-bottom: 2px solid var(--border);
            padding: 1rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
            z-index: 30;
        }

        /* Header row - scrolls horizontally only */
        .gantt-header-scroll {
            grid-row: 1;
            grid-column: 2;
            overflow-x: hidden;
            overflow-y: hidden;
            border-bottom: 2px solid var(--border);
            background: var(--bg-card);
            z-index: 20;
        }

        .gantt-header-inner {
            display: flex;
            flex-direction: column;
        }

        /* Labels column - scrolls vertically only */
        .gantt-labels-scroll {
            grid-row: 2;
            grid-column: 1;
            overflow-x: hidden;
            overflow-y: hidden;
            border-right: 2px solid var(--border);
            background: var(--bg-card);
            z-index: 20;
        }

        /* Main content - scrolls both ways */
        .gantt-content-scroll {
            grid-row: 2;
            grid-column: 2;
            overflow: auto;
            position: relative;
        }

        .gantt-content-inner {
            position: relative;
        }

        /* Field label in the labels column */
        .gantt-label {
            padding: 1rem;
            border-bottom: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            justify-content: center;
            background: var(--bg-card);
        }

        .gantt-label:nth-child(even) {
            background: #1a1a2e;
        }

        /* Timeline row in the content area */
        .gantt-row {
            position: relative;
            border-bottom: 1px solid var(--border);
        }

        .gantt-row:nth-child(even) {
            background: rgba(0, 0, 0, 0.1);
        }

        .gantt-body {
            position: relative;
        }

        /* Gap indicator styles for empty field space */
        .field-gap {
            position: absolute;
            height: calc(100% - 16px);
            top: 8px;
            background: repeating-linear-gradient(
                45deg,
                transparent,
                transparent 8px,
                rgba(46, 204, 113, 0.08) 8px,
                rgba(46, 204, 113, 0.08) 16px
            );
            border: 1px dashed rgba(46, 204, 113, 0.3);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            z-index: 1;
        }

        .field-gap:hover {
            background: repeating-linear-gradient(
                45deg,
                transparent,
                transparent 8px,
                rgba(46, 204, 113, 0.2) 8px,
                rgba(46, 204, 113, 0.2) 16px
            );
            border-color: rgba(46, 204, 113, 0.6);
            box-shadow: 0 0 15px rgba(46, 204, 113, 0.2);
        }

        .field-gap::after {
            content: '+';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.5rem;
            color: rgba(46, 204, 113, 0.4);
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .field-gap:hover::after {
            opacity: 1;
        }

        /* Gap tooltip */
        .gap-tooltip {
            position: fixed;
            background: var(--bg-card);
            border: 1px solid var(--primary);
            border-radius: 12px;
            padding: 1rem;
            z-index: 1000;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            min-width: 200px;
        }

        .gap-tooltip.visible {
            opacity: 1;
        }

        .gap-tooltip-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid var(--border);
        }

        .gap-tooltip-title {
            font-weight: 700;
            color: var(--primary-light);
        }

        .gap-tooltip-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 6px;
            font-size: 0.9rem;
        }

        .gap-tooltip-label {
            color: var(--text-secondary);
        }

        .gap-tooltip-value {
            font-weight: 600;
            color: var(--text-primary);
        }

        .gap-tooltip-hint {
            margin-top: 10px;
            padding-top: 8px;
            border-top: 1px solid var(--border);
            font-size: 0.8rem;
            color: var(--text-secondary);
            text-align: center;
        }

        /* Edit Modal Styles */
        .edit-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
        }

        .edit-modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .edit-modal {
            background: var(--bg-card);
            border-radius: 16px;
            border: 1px solid var(--border);
            width: 90%;
            max-width: 600px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        }

        .edit-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1.5rem;
            border-bottom: 1px solid var(--border);
            background: var(--bg-light);
            border-radius: 16px 16px 0 0;
        }

        .edit-modal-title {
            font-size: 1.25rem;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .edit-modal-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 5px;
            transition: color 0.2s;
        }

        .edit-modal-close:hover {
            color: var(--danger);
        }

        .edit-modal-body {
            padding: 1.5rem;
        }

        .edit-form-group {
            margin-bottom: 1.25rem;
        }

        .edit-form-label {
            display: block;
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 6px;
        }

        .edit-form-input {
            width: 100%;
            padding: 10px 14px;
            background: var(--bg-light);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 0.95rem;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .edit-form-input:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(46, 204, 113, 0.2);
        }

        .edit-form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
        }

        .edit-modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 1rem;
            padding: 1.5rem;
            border-top: 1px solid var(--border);
            background: var(--bg-light);
            border-radius: 0 0 16px 16px;
        }

        .edit-btn {
            padding: 10px 24px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .edit-btn-cancel {
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text-secondary);
        }

        .edit-btn-cancel:hover {
            background: var(--bg-card);
            color: var(--text-primary);
        }

        .edit-btn-save {
            background: var(--primary);
            border: none;
            color: white;
        }

        .edit-btn-save:hover {
            background: var(--primary-light);
            transform: translateY(-1px);
        }

        .edit-btn-save:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        /* Stats Bar */
        .stats-bar {
            display: flex;
            gap: 2rem;
            padding: 1rem 1.5rem;
            background: var(--bg-light);
            border-bottom: 1px solid var(--border);
            flex-wrap: wrap;
        }

        .stat-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .stat-value {
            font-size: 1.25rem;
            font-weight: 700;
            color: var(--primary-light);
        }

        .stat-label {
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        /* STICKY DATE HEADER - Sticks to top when scrolling vertically */
        .gantt-header {
            display: flex;
            border-bottom: 2px solid var(--border);
            position: sticky;
            top: 0;
            background: var(--bg-card);
            z-index: 100;
        }

        /* CORNER CELL - Sticks both left AND top */
        .gantt-field-header {
            width: 180px;
            min-width: 180px;
            padding: 1rem;
            background: var(--bg-light);
            border-right: 2px solid var(--border);
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
            position: sticky;
            left: 0;
            z-index: 110;
            box-shadow: 2px 2px 10px rgba(0,0,0,0.4);
        }

        .gantt-timeline-header {
            display: flex;
            flex-direction: column;
        }

        .gantt-months-row {
            display: flex;
            border-bottom: 1px solid var(--border);
        }

        .gantt-month {
            text-align: center;
            padding: 8px;
            font-weight: 600;
            font-size: 0.9rem;
            background: var(--bg-light);
            border-right: 1px solid var(--border);
            flex-shrink: 0;
        }

        .gantt-days-row {
            display: flex;
        }

        .gantt-day {
            text-align: center;
            padding: 4px;
            font-size: 0.7rem;
            color: var(--text-secondary);
            border-right: 1px solid rgba(255,255,255,0.05);
            flex-shrink: 0;
        }

        .gantt-day.today {
            background: rgba(244, 162, 97, 0.3);
            color: var(--secondary);
            font-weight: 600;
        }

        .gantt-day.weekend {
            background: rgba(0,0,0,0.2);
        }

        /* Gantt Body - Field Rows */
        .field-row {
            display: flex;
            border-bottom: 1px solid var(--border);
            min-height: 80px;
            position: relative;
        }

        .field-row:nth-child(even) {
            background: rgba(0, 0, 0, 0.1);
        }

        /* STICKY FIELD LABEL - Sticks to left when scrolling horizontally */
        .field-label {
            width: 180px;
            min-width: 180px;
            padding: 1rem;
            border-right: 2px solid var(--border);
            background: var(--bg-card);
            display: flex;
            flex-direction: column;
            justify-content: center;
            position: sticky;
            left: 0;
            z-index: 50;
            box-shadow: 2px 0 10px rgba(0,0,0,0.3);
        }

        .field-row:nth-child(even) .field-label {
            background: #1a1a2e;
        }

        .field-name {
            font-weight: 700;
            font-size: 1rem;
            margin-bottom: 4px;
        }

        .field-meta {
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        .field-timeline {
            position: relative;
            min-height: 80px;
        }

        /* Grid lines */
        .timeline-grid {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            pointer-events: none;
        }

        .grid-line {
            border-right: 1px solid rgba(255,255,255,0.03);
            flex-shrink: 0;
        }

        .grid-line.week-start {
            border-right-color: rgba(255,255,255,0.08);
        }

        /* Today Line */
        .today-line {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background: var(--danger);
            z-index: 25;
            pointer-events: none;
        }

        .today-marker {
            position: absolute;
            top: -24px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--danger);
            color: white;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.65rem;
            font-weight: 700;
            white-space: nowrap;
        }

        /* Crop Bars */
        .crop-bar {
            position: absolute;
            height: 36px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            padding: 0 10px;
            font-size: 0.75rem;
            font-weight: 600;
            color: white;
            cursor: grab;
            transition: box-shadow 0.2s, transform 0.1s;
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            z-index: 20;
            touch-action: none;
            user-select: none;
        }

        .crop-bar:hover {
            box-shadow: 0 4px 16px rgba(0,0,0,0.4);
            z-index: 30;
        }

        .crop-bar.dragging {
            cursor: grabbing;
            box-shadow: 0 8px 30px rgba(0,0,0,0.5);
            z-index: 100;
            opacity: 0.9;
        }

        /* Ghost element showing original position */
        .crop-bar-ghost {
            position: absolute;
            opacity: 0.3;
            pointer-events: none;
            border: 2px dashed rgba(255,255,255,0.5);
            background: repeating-linear-gradient(
                45deg,
                transparent,
                transparent 5px,
                rgba(255,255,255,0.1) 5px,
                rgba(255,255,255,0.1) 10px
            );
            z-index: 5;
        }

        .crop-bar-ghost::after {
            content: 'Original';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 0.7rem;
            color: rgba(255,255,255,0.6);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* Moved indicator on actual bar */
        .crop-bar.moved {
            box-shadow: 0 0 0 2px var(--secondary), 0 4px 12px rgba(244, 162, 97, 0.4);
        }

        .crop-bar.moved::before {
            content: 'âŸ²';
            position: absolute;
            top: -8px;
            right: -8px;
            background: var(--secondary);
            color: var(--bg-dark);
            width: 18px;
            height: 18px;
            border-radius: 50%;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }

        /* Empty bed row styling */
        .gantt-row.empty-bed {
            background: rgba(255,255,255,0.02);
        }

        .gantt-label.empty-bed {
            opacity: 0.5;
        }

        .gantt-label.empty-bed .field-meta {
            font-style: italic;
        }

        .crop-bar.resizing {
            z-index: 100;
        }

        .crop-bar.seeding {
            background: linear-gradient(135deg, #8e44ad 0%, #9b59b6 100%);
        }

        .crop-bar.growing {
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-light) 100%);
        }

        .crop-bar.harvest {
            background: linear-gradient(135deg, var(--secondary) 0%, var(--accent) 100%);
        }

        .crop-bar.completed {
            background: linear-gradient(135deg, #555 0%, #777 100%);
            opacity: 0.7;
        }

        .crop-bar.locked {
            border: 2px solid #e63946;
            cursor: not-allowed;
        }

        .crop-bar.locked .resize-handle {
            display: none;
        }

        /* Drag Tooltip - Real-time date display */
        .drag-tooltip {
            position: fixed;
            background: rgba(22, 33, 62, 0.98);
            border: 2px solid var(--primary);
            border-radius: 12px;
            padding: 12px 16px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            z-index: 2000;
            display: none;
            pointer-events: none;
            min-width: 180px;
        }

        .drag-tooltip.show {
            display: block;
        }

        .drag-tooltip-crop {
            font-weight: 700;
            font-size: 1rem;
            margin-bottom: 8px;
            padding-bottom: 8px;
            border-bottom: 1px solid var(--border);
            color: var(--primary-light);
        }

        .drag-date-row {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
            font-size: 0.9rem;
        }

        .drag-date-label {
            color: var(--text-secondary);
        }

        .drag-date-value {
            font-weight: 600;
            color: var(--text-primary);
            font-family: 'Courier New', monospace;
        }

        .drag-date-value.changed {
            color: var(--secondary);
            animation: pulse-date 0.3s ease;
        }

        @keyframes pulse-date {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        /* Timeline Navigation Bar */
        .timeline-nav {
            position: fixed;
            top: 65px;
            left: 280px;
            right: 0;
            background: rgba(22, 33, 62, 0.98);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid var(--border);
            padding: 10px 20px;
            display: flex;
            align-items: center;
            gap: 15px;
            z-index: 500;
        }

        .nav-btn {
            background: var(--bg-light);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 8px 12px;
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 2px;
        }

        .nav-btn:hover {
            background: var(--primary);
            border-color: var(--primary);
        }

        .nav-btn.today-btn {
            background: var(--primary);
            font-weight: 600;
        }

        .timeline-slider-container {
            flex: 1;
            max-width: 500px;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .timeline-slider {
            width: 100%;
            height: 8px;
            -webkit-appearance: none;
            background: var(--bg-light);
            border-radius: 4px;
            outline: none;
        }

        .timeline-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: var(--primary);
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }

        .timeline-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: var(--primary);
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid white;
        }

        .timeline-months {
            display: flex;
            justify-content: space-between;
            font-size: 0.65rem;
            color: var(--text-secondary);
            padding: 0 5px;
        }

        .current-range {
            background: var(--bg-light);
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--secondary);
            white-space: nowrap;
        }

        .main-container {
            padding: 130px 0 0; /* Adjusted for timeline nav */
        }

        @media (max-width: 1024px) {
            .timeline-nav {
                left: 0;
                top: 60px;
            }
            .main-container {
                padding-top: 180px;
            }
        }

        .crop-bar-icon {
            margin-right: 6px;
            font-size: 1rem;
        }

        .crop-bar-content {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .crop-bar-name {
            font-weight: 700;
        }

        .crop-bar-dates {
            font-size: 0.65rem;
            opacity: 0.9;
        }

        /* Resize Handles */
        .resize-handle {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 12px;
            cursor: ew-resize;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .crop-bar:hover .resize-handle {
            opacity: 1;
        }

        .resize-handle-left {
            left: 0;
            border-radius: 6px 0 0 6px;
            background: linear-gradient(90deg, rgba(0,0,0,0.3), transparent);
        }

        .resize-handle-right {
            right: 0;
            border-radius: 0 6px 6px 0;
            background: linear-gradient(-90deg, rgba(0,0,0,0.3), transparent);
        }

        .resize-handle::before {
            content: '';
            width: 3px;
            height: 20px;
            background: rgba(255,255,255,0.5);
            border-radius: 2px;
        }

        /* Drop Zone Highlight */
        .field-timeline.drop-target {
            background: rgba(45, 90, 39, 0.2);
        }

        .gantt-row.drop-target {
            background: rgba(45, 90, 39, 0.3) !important;
            box-shadow: inset 0 0 0 2px var(--primary);
        }

        /* Tooltip */
        .tooltip {
            position: fixed;
            background: var(--bg-card);
            border: 1px solid var(--primary);
            border-radius: 12px;
            padding: 1rem;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            z-index: 1000;
            max-width: 300px;
            display: none;
            pointer-events: none;
        }

        .tooltip.show {
            display: block;
        }

        .tooltip-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border);
        }

        .tooltip-icon {
            font-size: 1.5rem;
        }

        .tooltip-title {
            font-weight: 700;
            font-size: 1.1rem;
        }

        .tooltip-variety {
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .tooltip-row {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
            font-size: 0.9rem;
        }

        .tooltip-label {
            color: var(--text-secondary);
        }

        .tooltip-actions {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid var(--border);
            font-size: 0.75rem;
            color: var(--text-secondary);
            text-align: center;
        }

        /* Buttons */
        .btn {
            padding: 10px 20px;
            border-radius: 10px;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            border: none;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-light) 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(45, 90, 39, 0.3);
        }

        .btn-secondary {
            background: var(--bg-light);
            color: var(--text-primary);
            border: 1px solid var(--border);
        }

        /* Toast */
        .toast {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            background: var(--bg-card);
            border: 1px solid var(--primary);
            border-radius: 12px;
            padding: 1rem 1.5rem;
            display: flex;
            align-items: center;
            gap: 12px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            transform: translateX(150%);
            transition: transform 0.3s ease;
            z-index: 2000;
        }

        .toast.show { transform: translateX(0); }
        .toast.success i { color: var(--success); }
        .toast.error i { color: var(--danger); }
        .toast.warning i { color: var(--warning); }

        /* Loading */
        .loading {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 4rem;
            color: var(--text-secondary);
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 1rem;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Mobile */
        @media (max-width: 1024px) {
            .header {
                padding-left: 1rem;
                flex-wrap: wrap;
                gap: 0.5rem;
            }
            .header-controls {
                flex-wrap: wrap;
                gap: 0.5rem;
            }
            .sidebar {
                transform: translateX(-100%);
                transition: transform 0.3s;
            }
            .sidebar.show {
                transform: translateX(0);
            }
            .gantt-container {
                margin-left: 0;
            }
        }

        /* Larger screens - ensure header controls don't get cut off */
        @media (min-width: 1600px) {
            .header-controls {
                gap: 1.5rem;
            }
        }
    </style>
</head>
<body>
    <header class="header">
        <div class="header-left">
            <a href="index.html" class="back-btn">
                <i class="fas fa-arrow-left"></i>
                <span>Back</span>
            </a>
            <h1 class="page-title">
                <i class="fas fa-calendar-alt"></i>
                Field & Crop Calendar
            </h1>
        </div>
        <div class="header-controls">
            <div class="sync-indicator synced" id="syncIndicator">
                <span class="sync-dot"></span>
                <span id="syncText">Synced</span>
            </div>
            <button class="submit-changes-btn" id="submitChangesBtn" onclick="saveToGoogleSheets()">
                <i class="fas fa-cloud-upload-alt"></i>
                Submit Changes
                <span class="badge" id="pendingCount">0</span>
            </button>
            <button class="discard-btn" id="discardBtn" onclick="discardChanges()">
                <i class="fas fa-times"></i> Discard
            </button>
            <div class="zoom-controls">
                <button class="zoom-btn active" onclick="setViewMode('field')" id="view-field">By Field</button>
                <button class="zoom-btn" onclick="setViewMode('bed')" id="view-bed">By Bed</button>
                <button class="zoom-btn" onclick="setViewMode('crop')" id="view-crop">By Crop</button>
                <button class="zoom-btn" onclick="setViewMode('variety')" id="view-variety">By Variety</button>
            </div>
            <div class="zoom-controls">
                <button class="zoom-btn" onclick="setZoom('day')" id="zoom-day">Day</button>
                <button class="zoom-btn active" onclick="setZoom('week')" id="zoom-week">Week</button>
                <button class="zoom-btn" onclick="setZoom('month')" id="zoom-month">Month</button>
                <button class="zoom-btn" onclick="setZoom('quarter')" id="zoom-quarter">Quarter</button>
                <button class="zoom-btn" onclick="setZoom('year')" id="zoom-year">Full Year</button>
            </div>
            <button class="btn btn-secondary" onclick="showFullYear()">
                <i class="fas fa-expand"></i> Full Year
            </button>
            <button class="btn btn-primary" onclick="window.location.href='succession.html'">
                <i class="fas fa-plus"></i> Add Planting
            </button>
        </div>
    </header>

    <!-- Timeline Navigation Bar -->
    <div class="timeline-nav" id="timelineNav">
        <button class="nav-btn" onclick="navigateTimeline(-30)" title="Previous Month">
            <i class="fas fa-chevron-left"></i><i class="fas fa-chevron-left"></i>
        </button>
        <button class="nav-btn" onclick="navigateTimeline(-7)" title="Previous Week">
            <i class="fas fa-chevron-left"></i>
        </button>
        <div class="timeline-slider-container">
            <input type="range" id="timelineSlider" class="timeline-slider"
                   min="0" max="365" value="0"
                   oninput="onSliderChange(this.value)">
            <div class="timeline-months">
                <span>Jan</span><span>Feb</span><span>Mar</span><span>Apr</span>
                <span>May</span><span>Jun</span><span>Jul</span><span>Aug</span>
                <span>Sep</span><span>Oct</span><span>Nov</span><span>Dec</span>
            </div>
        </div>
        <button class="nav-btn" onclick="navigateTimeline(7)" title="Next Week">
            <i class="fas fa-chevron-right"></i>
        </button>
        <button class="nav-btn" onclick="navigateTimeline(30)" title="Next Month">
            <i class="fas fa-chevron-right"></i><i class="fas fa-chevron-right"></i>
        </button>
        <button class="nav-btn today-btn" onclick="goToToday()" title="Go to Today">
            Today
        </button>
        <div class="current-range" id="currentRange">Jan 1 - Dec 31, 2026</div>
    </div>

    <aside class="sidebar" id="sidebar">
        <div class="sidebar-section">
            <h3 class="sidebar-title">Filters</h3>

            <div class="filter-group">
                <label>Date Range</label>
                <select class="filter-control" id="dateRange" onchange="applyFilters()">
                    <option value="season">Full Season 2026</option>
                    <option value="month">This Month</option>
                    <option value="quarter">This Quarter</option>
                </select>
            </div>

            <div class="filter-group">
                <label>Crop</label>
                <select class="filter-control" id="cropFilter" onchange="applyFilters()">
                    <option value="">All Crops</option>
                </select>
            </div>

            <div class="filter-group">
                <label>Field</label>
                <select class="filter-control" id="fieldFilter" onchange="applyFilters()">
                    <option value="">All Fields</option>
                </select>
            </div>
        </div>

        <div class="sidebar-section">
            <h3 class="sidebar-title">Status</h3>
            <div class="checkbox-filters">
                <label class="checkbox-filter">
                    <input type="checkbox" checked onchange="applyFilters()" data-status="seeding">
                    <span class="status-dot seeding"></span>
                    <span>Seeding</span>
                </label>
                <label class="checkbox-filter">
                    <input type="checkbox" checked onchange="applyFilters()" data-status="growing">
                    <span class="status-dot growing"></span>
                    <span>Growing</span>
                </label>
                <label class="checkbox-filter">
                    <input type="checkbox" checked onchange="applyFilters()" data-status="harvest">
                    <span class="status-dot harvest"></span>
                    <span>Harvest Ready</span>
                </label>
                <label class="checkbox-filter">
                    <input type="checkbox" onchange="applyFilters()" data-status="completed">
                    <span class="status-dot completed"></span>
                    <span>Completed</span>
                </label>
            </div>
        </div>

        <div class="sidebar-section">
            <h3 class="sidebar-title">Legend</h3>
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: linear-gradient(135deg, #8e44ad 0%, #9b59b6 100%);"></div>
                    <span>Seeding Phase</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: linear-gradient(135deg, var(--primary) 0%, var(--primary-light) 100%);"></div>
                    <span>Growing Phase</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: linear-gradient(135deg, var(--secondary) 0%, var(--accent) 100%);"></div>
                    <span>Harvest Window</span>
                </div>
            </div>
        </div>

        <div class="sidebar-section">
            <h3 class="sidebar-title">Instructions</h3>
            <div style="font-size: 0.8rem; color: var(--text-secondary); line-height: 1.6;">
                <p><strong>Drag</strong> bars to move between fields</p>
                <p><strong>Resize</strong> by dragging edges to adjust duration</p>
                <p>Changes sync to Google Sheets automatically</p>
            </div>
        </div>

        <div class="sidebar-section">
            <button class="btn btn-primary" style="width: 100%; margin-bottom: 10px;" onclick="openAddPlantingModal()">
                <i class="fas fa-plus"></i> Add Planting
            </button>
            <button class="btn btn-secondary" style="width: 100%;" onclick="refreshData()">
                <i class="fas fa-sync-alt"></i> Refresh Data
            </button>
        </div>
    </aside>

    <main class="main-container">
        <div class="gantt-container">
            <div class="gantt-wrapper">
                <div class="stats-bar">
                    <div class="stat-item">
                        <span class="stat-value" id="totalPlantings">--</span>
                        <span class="stat-label">Plantings</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-value" id="activePlantings">--</span>
                        <span class="stat-label">Active</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-value" id="harvestReady">--</span>
                        <span class="stat-label">Harvest Ready</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-value" id="totalBedFeet">--</span>
                        <span class="stat-label">Bed Feet</span>
                    </div>
                </div>

                <div class="gantt-chart" id="ganttChart">
                    <div class="loading">
                        <div class="spinner"></div>
                        <p>Loading calendar...</p>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <!-- Edit Planting Modal -->
    <div class="edit-modal-overlay" id="editModal">
        <div class="edit-modal" style="max-width: 700px;">
            <div class="edit-modal-header">
                <div class="edit-modal-title">
                    <span id="editModalIcon" style="font-size: 1.5rem;">ðŸŒ±</span>
                    <div>
                        <div style="font-size: 1.1rem;" id="editModalCropName">Edit Planting</div>
                        <div style="font-size: 0.8rem; color: var(--text-secondary); font-weight: normal;" id="editModalBatchId">Batch ID: --</div>
                    </div>
                </div>
                <button class="edit-modal-close" onclick="closeEditModal()">&times;</button>
            </div>
            <div class="edit-modal-body">
                <input type="hidden" id="editBatchId">

                <!-- Current Info Banner -->
                <div style="background: var(--bg-light); border-radius: 8px; padding: 1rem; margin-bottom: 1.25rem; border-left: 4px solid var(--primary);">
                    <div style="font-size: 0.8rem; color: var(--text-secondary); margin-bottom: 0.5rem;">CURRENT SCHEDULE</div>
                    <div id="editCurrentSchedule" style="font-size: 0.9rem; line-height: 1.6;">Loading...</div>
                </div>

                <!-- Planting Method Toggle -->
                <div class="edit-form-group">
                    <label class="edit-form-label">Planting Method</label>
                    <div style="display: flex; gap: 1rem;">
                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 10px 16px; background: var(--bg-light); border-radius: 8px; border: 2px solid transparent; transition: all 0.2s;" id="methodTransplantLabel">
                            <input type="radio" name="plantingMethod" value="Transplant" id="methodTransplant" onchange="updateMethodFields()">
                            <span>ðŸŒ± Transplant</span>
                            <span style="font-size: 0.75rem; color: var(--text-secondary);">(Start in GH)</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 10px 16px; background: var(--bg-light); border-radius: 8px; border: 2px solid transparent; transition: all 0.2s;" id="methodDirectLabel">
                            <input type="radio" name="plantingMethod" value="Direct Seed" id="methodDirect" onchange="updateMethodFields()">
                            <span>ðŸŒ¾ Direct Seed</span>
                            <span style="font-size: 0.75rem; color: var(--text-secondary);">(Sow in field)</span>
                        </label>
                    </div>
                </div>

                <!-- Crop & Variety -->
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1.25rem;">
                    <div class="edit-form-group" style="margin-bottom: 0;">
                        <label class="edit-form-label">Crop</label>
                        <input type="text" class="edit-form-input" id="editCrop">
                    </div>
                    <div class="edit-form-group" style="margin-bottom: 0;">
                        <label class="edit-form-label">Variety</label>
                        <input type="text" class="edit-form-input" id="editVariety">
                    </div>
                </div>

                <!-- Location -->
                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 1rem; margin-bottom: 1.25rem;">
                    <div class="edit-form-group" style="margin-bottom: 0;">
                        <label class="edit-form-label">Field</label>
                        <input type="text" class="edit-form-input" id="editField">
                    </div>
                    <div class="edit-form-group" style="margin-bottom: 0;">
                        <label class="edit-form-label">Bed</label>
                        <input type="text" class="edit-form-input" id="editBed" placeholder="e.g., 1">
                    </div>
                    <div class="edit-form-group" style="margin-bottom: 0;">
                        <label class="edit-form-label">Bed Feet</label>
                        <input type="number" class="edit-form-input" id="editBedFeet">
                    </div>
                </div>

                <!-- Dates Section -->
                <div style="background: var(--bg-light); border-radius: 8px; padding: 1rem; margin-bottom: 1.25rem;">
                    <div style="font-size: 0.85rem; font-weight: 600; margin-bottom: 1rem; display: flex; align-items: center; gap: 8px;">
                        <i class="fas fa-calendar-alt" style="color: var(--primary);"></i>
                        Schedule Dates
                    </div>

                    <!-- Transplant dates (shown when Transplant selected) -->
                    <div id="transplantDates">
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1rem;">
                            <div class="edit-form-group" style="margin-bottom: 0;">
                                <label class="edit-form-label">ðŸ  GH Sow Date</label>
                                <input type="date" class="edit-form-input" id="editGHSow">
                            </div>
                            <div class="edit-form-group" style="margin-bottom: 0;">
                                <label class="edit-form-label">ðŸŒ¿ Transplant to Field</label>
                                <input type="date" class="edit-form-input" id="editTransplant">
                            </div>
                        </div>
                    </div>

                    <!-- Direct Seed dates (shown when Direct Seed selected) -->
                    <div id="directSeedDates" style="display: none;">
                        <div class="edit-form-group" style="margin-bottom: 1rem;">
                            <label class="edit-form-label">ðŸŒ¾ Field Sow Date</label>
                            <input type="date" class="edit-form-input" id="editFieldSow">
                        </div>
                    </div>

                    <!-- Harvest dates (always shown) -->
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                        <div class="edit-form-group" style="margin-bottom: 0;">
                            <label class="edit-form-label">ðŸ¥¬ First Harvest</label>
                            <input type="date" class="edit-form-input" id="editFirstHarvest">
                        </div>
                        <div class="edit-form-group" style="margin-bottom: 0;">
                            <label class="edit-form-label">ðŸ Last Harvest</label>
                            <input type="date" class="edit-form-input" id="editLastHarvest">
                        </div>
                    </div>
                </div>

                <!-- Days to Maturity (info only) -->
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1.25rem;">
                    <div class="edit-form-group" style="margin-bottom: 0;">
                        <label class="edit-form-label">Days to Maturity</label>
                        <input type="number" class="edit-form-input" id="editDTM" placeholder="e.g., 65">
                    </div>
                    <div class="edit-form-group" style="margin-bottom: 0;">
                        <label class="edit-form-label">Harvest Window (days)</label>
                        <input type="number" class="edit-form-input" id="editHarvestWindow" placeholder="e.g., 21">
                    </div>
                </div>

                <!-- Notes -->
                <div class="edit-form-group">
                    <label class="edit-form-label">Notes</label>
                    <textarea class="edit-form-input" id="editNotes" rows="2" placeholder="Any notes about this planting..."></textarea>
                </div>
            </div>
            <div class="edit-modal-footer">
                <button class="edit-btn edit-btn-cancel" onclick="closeEditModal()">Cancel</button>
                <button class="edit-btn edit-btn-save" id="editSaveBtn" onclick="saveEditModal()">
                    <i class="fas fa-save"></i> Save Changes
                </button>
            </div>
        </div>
    </div>

    <!-- Add Planting Modal -->
    <div class="edit-modal-overlay" id="addPlantingModal">
        <div class="edit-modal" style="max-width: 600px;">
            <div class="edit-modal-header">
                <div class="edit-modal-title">
                    <span style="font-size: 1.5rem;">ðŸŒ±</span>
                    <div>
                        <div style="font-size: 1.1rem;">Add New Planting</div>
                        <div style="font-size: 0.8rem; color: var(--text-secondary); font-weight: normal;">Create a new planting on the calendar</div>
                    </div>
                </div>
                <button class="edit-modal-close" onclick="closeAddPlantingModal()">&times;</button>
            </div>
            <div class="edit-modal-body">
                <div class="edit-form-row">
                    <div class="edit-form-group">
                        <label class="edit-label">Crop</label>
                        <select class="edit-input" id="addCrop" onchange="onAddCropChange()">
                            <option value="">Select crop...</option>
                        </select>
                        <input type="text" class="edit-input" id="addNewCrop" placeholder="Enter new crop name..." style="display: none; margin-top: 6px;">
                    </div>
                    <div class="edit-form-group">
                        <label class="edit-label">Variety</label>
                        <select class="edit-input" id="addVariety" onchange="onAddVarietyChange()">
                            <option value="">Select variety...</option>
                        </select>
                        <input type="text" class="edit-input" id="addNewVariety" placeholder="Enter new variety name..." style="display: none; margin-top: 6px;">
                    </div>
                </div>
                <div class="edit-form-row">
                    <div class="edit-form-group">
                        <label class="edit-label">Planting Method</label>
                        <select class="edit-input" id="addMethod">
                            <option value="Transplant">Transplant</option>
                            <option value="Direct Seed">Direct Seed</option>
                        </select>
                    </div>
                    <div class="edit-form-group">
                        <label class="edit-label">Tray Size</label>
                        <select class="edit-input" id="addTraySize">
                            <option value="128">128-cell</option>
                            <option value="72">72-cell</option>
                            <option value="50">50-cell</option>
                            <option value="32">32-cell</option>
                        </select>
                    </div>
                </div>
                <div class="edit-form-row">
                    <div class="edit-form-group">
                        <label class="edit-label">Bed Feet</label>
                        <input type="number" class="edit-input" id="addFeet" value="100" min="1">
                    </div>
                    <div class="edit-form-group">
                        <label class="edit-label">Target Field/Bed</label>
                        <input type="text" class="edit-input" id="addBed" placeholder="e.g., F1L-01">
                    </div>
                </div>
                <div class="edit-form-row">
                    <div class="edit-form-group">
                        <label class="edit-label">Date Type</label>
                        <select class="edit-input" id="addDateType">
                            <option value="transplant">Transplant Date</option>
                            <option value="ghSow">GH Sow Date</option>
                            <option value="fieldSow">Field Sow Date</option>
                            <option value="harvest">First Harvest Date</option>
                        </select>
                    </div>
                    <div class="edit-form-group">
                        <label class="edit-label">Date</label>
                        <input type="date" class="edit-input" id="addDate">
                    </div>
                </div>
                <div class="edit-form-row">
                    <div class="edit-form-group" style="flex: 1;">
                        <label class="edit-label">
                            <input type="checkbox" id="addSuccessionCheck" onchange="toggleAddSuccession()">
                            Add Successions
                        </label>
                        <div id="addSuccessionOptions" style="display: none; margin-top: 10px;">
                            <div style="display: flex; gap: 10px; align-items: center;">
                                <input type="number" class="edit-input" id="addSuccessionCount" value="4" min="1" max="20" style="width: 70px;">
                                <span>plantings every</span>
                                <input type="number" class="edit-input" id="addInterval" value="7" min="1" style="width: 70px;">
                                <select class="edit-input" id="addIntervalUnit" style="width: 100px;">
                                    <option value="days">days</option>
                                    <option value="weeks">weeks</option>
                                </select>
                            </div>
                        </div>
                    </div>
                </div>
                <div id="addPlantingSummary" style="margin-top: 15px; padding: 12px; background: rgba(45, 90, 39, 0.2); border-radius: 8px; font-size: 0.9rem;">
                    <strong>Summary:</strong> Select crop and dates to see planting summary
                </div>
            </div>
            <div class="edit-modal-footer">
                <button class="edit-btn edit-btn-cancel" onclick="closeAddPlantingModal()">Cancel</button>
                <button class="edit-btn edit-btn-save" onclick="saveAddPlanting()">
                    <i class="fas fa-plus"></i> Add Planting
                </button>
            </div>
        </div>
    </div>

    <!-- Gap Analysis Tooltip -->
    <div class="gap-tooltip" id="gapTooltip">
        <div class="gap-tooltip-header">
            <span style="font-size: 1.2rem;">ðŸ“…</span>
            <span class="gap-tooltip-title">Open Field Space</span>
        </div>
        <div class="gap-tooltip-row">
            <span class="gap-tooltip-label">Duration:</span>
            <span class="gap-tooltip-value" id="gapDuration">--</span>
        </div>
        <div class="gap-tooltip-row">
            <span class="gap-tooltip-label">Date Range:</span>
            <span class="gap-tooltip-value" id="gapDateRange">--</span>
        </div>
        <div class="gap-tooltip-row">
            <span class="gap-tooltip-label">Field:</span>
            <span class="gap-tooltip-value" id="gapField">--</span>
        </div>
        <div class="gap-tooltip-hint">
            <i class="fas fa-lightbulb"></i> Click to add a planting here
        </div>
    </div>

    <div class="tooltip" id="tooltip">
        <div class="tooltip-header">
            <span class="tooltip-icon" id="tooltipIcon">ðŸŒ±</span>
            <div>
                <div class="tooltip-title" id="tooltipTitle">Crop Name</div>
                <div class="tooltip-variety" id="tooltipVariety">Variety</div>
            </div>
        </div>
        <div class="tooltip-row" id="tooltipLockRow" style="display: none; color: #e63946;">
            <span class="tooltip-label">ðŸ”’ Locked:</span>
            <span id="tooltipLockReason">-</span>
        </div>
        <div class="tooltip-row">
            <span class="tooltip-label">Batch ID:</span>
            <span id="tooltipBatchId">-</span>
        </div>
        <div class="tooltip-row">
            <span class="tooltip-label">Field/Bed:</span>
            <span id="tooltipBed">-</span>
        </div>
        <div class="tooltip-row">
            <span class="tooltip-label">Method:</span>
            <span id="tooltipMethod">-</span>
        </div>
        <div class="tooltip-row" id="tooltipGHRow">
            <span class="tooltip-label">GH Sow:</span>
            <span id="tooltipGHSow">-</span>
        </div>
        <div class="tooltip-row">
            <span class="tooltip-label">In Field:</span>
            <span id="tooltipStart">-</span>
        </div>
        <div class="tooltip-row">
            <span class="tooltip-label">Last Harvest:</span>
            <span id="tooltipEnd">-</span>
        </div>
        <div class="tooltip-row">
            <span class="tooltip-label">Days in Field:</span>
            <span id="tooltipDuration">-</span>
        </div>
        <div class="tooltip-row">
            <span class="tooltip-label">Bed Feet:</span>
            <span id="tooltipBedFeet">-</span>
        </div>
        <div class="tooltip-row">
            <span class="tooltip-label">Status:</span>
            <span id="tooltipStatus">-</span>
        </div>
        <div class="tooltip-actions" id="tooltipActions">
            Drag to move | Resize edges to adjust dates
        </div>
    </div>

    <div class="toast" id="toast">
        <i class="fas fa-check-circle"></i>
        <span id="toastMessage">Action completed!</span>
    </div>

    <!-- Real-time drag date tooltip -->
    <div class="drag-tooltip" id="dragTooltip">
        <div class="drag-tooltip-crop" id="dragCrop">Lettuce</div>
        <div class="drag-tooltip-dates">
            <div class="drag-date-row">
                <span class="drag-date-label">GH Sow:</span>
                <span class="drag-date-value" id="dragGHSow">-</span>
            </div>
            <div class="drag-date-row">
                <span class="drag-date-label">In Field:</span>
                <span class="drag-date-value" id="dragFieldStart">Apr 15</span>
            </div>
            <div class="drag-date-row">
                <span class="drag-date-label">Harvest:</span>
                <span class="drag-date-value" id="dragHarvest">Jun 20</span>
            </div>
        </div>
    </div>

    <script>
        // API Configuration
        const API_URL = 'https://script.google.com/macros/s/AKfycbz23N_RluRDlJheaK0vTZmvfIkd5yyMblNizASjuuo6vsNibuoWIPt04KuZOCKEwaoj/exec';

        // State
        let plantings = [];
        let filteredPlantings = [];
        let fields = [];
        let zoomLevel = 'week';
        let viewMode = 'field'; // 'field', 'crop', or 'variety'
        let dayWidth = 20;
        let timelineStart = new Date('2026-01-01');
        let timelineEnd = new Date('2026-12-31');
        let pendingUpdates = new Map();
        let saveTimeout = null;

        // Ghost tracking for moved plantings (shows original position until submitted)
        let originalPositions = new Map(); // id -> { field, bed, fieldStartDate, left, top, rowGroup }
        let ghostElements = new Map(); // id -> ghost DOM element

        // All available beds (even if empty) - will be populated from API or defaults
        let allBeds = [];
        // Field configurations: { fieldCode: numberOfBeds } - loaded from API
        let FIELD_CONFIG = {};
        let DEFAULT_FIELDS = [];
        let allFieldsData = []; // Full field data from API

        // Crop icons - expanded for actual farm crops
        const cropIcons = {
            'Tomatoes': 'ðŸ…', 'Tomatillos': 'ðŸ…', 'Lettuce': 'ðŸ¥¬', 'Peppers': 'ðŸ«‘',
            'Basil': 'ðŸŒ¿', 'Carrots': 'ðŸ¥•', 'Kale': 'ðŸ¥—', 'Spinach': 'ðŸƒ',
            'Cucumbers': 'ðŸ¥’', 'Beans': 'ðŸ«˜', 'Squash': 'ðŸŽƒ', 'Winter Squash': 'ðŸŽƒ',
            'Onions': 'ðŸ§…', 'Garlic': 'ðŸ§„', 'Broccoli': 'ðŸ¥¦', 'Cabbage': 'ðŸ¥¬',
            'Corn': 'ðŸŒ½', 'Peas': 'ðŸ«›', 'Beets': 'ðŸŸ£', 'Cauliflower': 'ðŸ¥¦',
            'Eggplant': 'ðŸ†', 'Fennel': 'ðŸŒ¿', 'Radicchio': 'ðŸ¥¬', 'Swiss Chard': 'ðŸ¥¬',
            'Bok Choy': 'ðŸ¥¬', 'Collard Greens': 'ðŸ¥¬', 'Kohlrabi': 'ðŸ¥¬',
            'Napa Cabbage': 'ðŸ¥¬', 'Scallions': 'ðŸ§…', 'Parsley': 'ðŸŒ¿',
            'Dandelions': 'ðŸŒ¿', 'Endive': 'ðŸ¥¬', 'Escarole': 'ðŸ¥¬',
            'Zucchini': 'ðŸ¥’', 'Summer Squash': 'ðŸ¥’', 'Melons': 'ðŸˆ',
            'Watermelon': 'ðŸ‰', 'Potatoes': 'ðŸ¥”', 'Sweet Potatoes': 'ðŸ ',
            'Turnips': 'ðŸŸ£', 'Radishes': 'ðŸŸ£', 'Rutabaga': 'ðŸŸ£'
        };

        // Crop colors from REF_CropProfiles (primary color per crop)
        const cropColors = {
            'Lettuce': '#2E8B57',
            'Kale': '#006400',
            'Basil': '#228B22',
            'Broccoli': '#0C360C',
            'Beets': '#820B55',
            'Carrots': '#FF8C00',
            'Eggplant': '#B22222',
            'Tomatoes': '#DC143C',
            'Tomatillos': '#FF6347',
            'Peppers': '#E74C3C',
            'Winter Squash': '#D35400',
            'Fennel': '#F1C40F',
            'Cabbage': '#1E4D2B',
            'Cauliflower': '#2E8B57',
            'Bok Choy': '#155815',
            'Collard Greens': '#006400',
            'Kohlrabi': '#2E8B57',
            'Radicchio': '#7B241C',
            'Swiss Chard': '#C71585',
            'Scallions': '#D8BFD8',
            'Parsley': '#1E8449',
            'Spinach': '#1E8449',
            'Cucumbers': '#E67E22',
            'Beans': '#228B22',
            'Onions': '#DDA0DD',
            'Garlic': '#D8BFD8',
            'Endive': '#9370DB',
            'Escarole': '#9932CC',
            'Napa Cabbage': '#1E4D2B',
            'Dandelions': '#9370DB'
        };

        // Will be populated from API
        let cropProfileColors = {};

        // Initialize
        document.addEventListener('DOMContentLoaded', async function() {
            await loadFields();    // Load field config first
            loadCropProfiles();    // Load colors
            loadPlantings();       // Then load plantings
        });

        // Load field configuration from API
        async function loadFields() {
            try {
                const response = await fetch(`${API_URL}?action=getFields`);
                const data = await response.json();

                if (data.success && data.fields) {
                    allFieldsData = data.fields;
                    FIELD_CONFIG = data.fieldConfig || {};
                    DEFAULT_FIELDS = Object.keys(FIELD_CONFIG).sort();

                    console.log(`Loaded ${data.count} fields from API:`, DEFAULT_FIELDS);
                } else {
                    console.warn('Failed to load fields, using fallback');
                    useFallbackFields();
                }
            } catch (error) {
                console.error('Error loading fields:', error);
                useFallbackFields();
            }
        }

        // Fallback if API fails
        function useFallbackFields() {
            FIELD_CONFIG = {
                'F3L': 12, 'F7M': 10, 'F11M': 10, 'HOL': 12,
                'IL': 11, 'IOL': 8, 'JL': 10, 'JS1': 15,
                'JS4': 10, 'JS6': 10, 'JS10': 14, 'M': 14,
                'SO': 12, 'Z3': 15, 'Z5': 6
            };
            DEFAULT_FIELDS = Object.keys(FIELD_CONFIG).sort();
            allFieldsData = [];
        }

        // Load crop profiles to get colors
        async function loadCropProfiles() {
            try {
                const response = await fetch(`${API_URL}?action=getCropProfiles`);
                const data = await response.json();

                if (data.success && data.data && data.data.length > 0) {
                    // Build color map from crop profiles
                    data.data.forEach(profile => {
                        const cropName = profile.Crop_Name || profile.crop_name || profile.Crop;
                        const colorHex = profile.Color_Hex || profile.color_hex || profile.Color;
                        if (cropName && colorHex && colorHex.startsWith('#')) {
                            cropProfileColors[cropName] = colorHex;
                        }
                    });
                }
            } catch (error) {
            }
        }

        // Load Plantings from API
        async function loadPlantings() {
            setSyncStatus('syncing', 'Loading...');

            try {
                // Use getPlanningData (matches your existing Apps Script)
                let response = await fetch(`${API_URL}?action=getPlanningData`);
                let data = await response.json();


                if (data.success && data.data && data.data.length > 0) {

                    const rawCount = data.data.length;
                    plantings = normalizeData(data.data);

                    if (plantings.length > 0) {
                        setSyncStatus('synced', `Live: ${plantings.length} plantings`);
                        showToast(`Loaded ${plantings.length} plantings from Google Sheets`, 'success');
                    } else {
                        console.warn('All plantings filtered out - check date fields in your data', {
                            Plan_GH_Sow: data.data[0]?.Plan_GH_Sow,
                            Plan_Transplant: data.data[0]?.Plan_Transplant,
                            Plan_Field_Sow: data.data[0]?.Plan_Field_Sow,
                            Last_Harvest: data.data[0]?.Last_Harvest
                        });
                        plantings = getDemoPlantings();
                        setSyncStatus('synced', 'Demo (no valid dates)');
                    }
                } else {
                    plantings = getDemoPlantings();
                    setSyncStatus('synced', 'Demo Mode');
                }
            } catch (error) {
                console.error('Error loading plantings:', error);
                plantings = getDemoPlantings();
                setSyncStatus('error', 'Offline - Demo');
            }

            extractFieldsAndCrops();
            applyFilters();
        }

        function normalizeData(data) {
            return data.map((p, index) => {
                // Extract field and bed from Target_Bed_ID (e.g., "Field F3L-01" -> field="F3L", bed="01")
                const targetBed = p.Target_Bed_ID || p.target_bed_id || p.Bed || p.bed || '';
                const { field, bedNum } = extractFieldAndBed(targetBed);

                // Determine planting method
                const plantingMethod = p.Planting_Method || p.planting_method || 'Transplant';

                // Parse ALL dates - store raw values for editing
                const planGHSow = parseFlexibleDate(p.Plan_GH_Sow || p.plan_gh_sow);
                const actGHSow = parseFlexibleDate(p.Act_GH_Sow || p.act_gh_sow);
                const planFieldSow = parseFlexibleDate(p.Plan_Field_Sow || p.plan_field_sow);
                const actFieldSow = parseFlexibleDate(p.Act_Field_Sow || p.act_field_sow);
                const planTransplant = parseFlexibleDate(p.Plan_Transplant || p.plan_transplant);
                const actTransplant = parseFlexibleDate(p.Act_Transplant || p.act_transplant);
                const firstHarvest = parseFlexibleDate(p.First_Harvest || p.first_harvest);
                let lastHarvest = parseFlexibleDate(p.Last_Harvest || p.last_harvest);

                // Determine field start date based on planting method
                let fieldStartDate;
                if (plantingMethod === 'Direct Seed') {
                    fieldStartDate = actFieldSow || planFieldSow;
                } else {
                    fieldStartDate = actTransplant || planTransplant;
                }

                // Get crop and variety
                const crop = p.Crop || p.crop || 'Unknown';
                const variety = p.Variety || p.variety || '';

                // Estimate missing dates if possible instead of skipping
                if (!fieldStartDate && !lastHarvest) {
                    // Both dates missing - skip this entry
                    return null;
                }

                // If only field start is missing, estimate from harvest date minus typical DTM
                if (!fieldStartDate && lastHarvest) {
                    const estStart = new Date(lastHarvest);
                    estStart.setDate(estStart.getDate() - 60); // Default 60 day crop
                    fieldStartDate = estStart.toISOString().split('T')[0];
                }

                // If only harvest is missing, estimate from field start plus typical DTM
                if (fieldStartDate && !lastHarvest) {
                    const estEnd = new Date(fieldStartDate);
                    estEnd.setDate(estEnd.getDate() + 60); // Default 60 day crop
                    lastHarvest = estEnd.toISOString().split('T')[0];
                }

                // Calculate days between key dates for proportional adjustments
                const ghSowDate = actGHSow || planGHSow;
                const daysGHToField = ghSowDate ? daysBetween(ghSowDate, fieldStartDate) : 0;
                const daysFieldToHarvest = daysBetween(fieldStartDate, lastHarvest);

                // Determine if locked (already sown in GH or field)
                const isLocked = !!(actGHSow || actFieldSow || actTransplant);
                const lockReason = actGHSow ? 'GH Sown' : actFieldSow ? 'Field Sown' : actTransplant ? 'Transplanted' : null;

                return {
                    id: p.Batch_ID || p.batch_id || p.ID || p.id || `planting-${index}`,
                    crop: crop,
                    variety: variety,
                    plantingMethod: plantingMethod,

                    // All dates stored for cascade updates
                    planGHSow: ghSowDate,
                    actGHSow: actGHSow,
                    planFieldSow: planFieldSow,
                    actFieldSow: actFieldSow,
                    planTransplant: planTransplant,
                    actTransplant: actTransplant,
                    firstHarvest: firstHarvest,
                    lastHarvest: lastHarvest,

                    // Calculated field dates for Gantt display
                    fieldStartDate: fieldStartDate,
                    harvestDate: lastHarvest,
                    seedDate: fieldStartDate, // Legacy compatibility

                    // Day offsets for cascade calculations
                    daysGHToField: daysGHToField,
                    daysFieldToHarvest: daysFieldToHarvest,

                    // Locking
                    isLocked: isLocked,
                    lockReason: lockReason,

                    // Field info
                    bed: targetBed,
                    field: field,
                    bedNum: bedNum,
                    bedFeet: parseInt(p.Feet_Used || p.feet_used || p.BedFeet || p.bedFeet || 50),
                    status: computeStatus(fieldStartDate, lastHarvest),
                    dtm: daysFieldToHarvest > 0 ? daysFieldToHarvest : 60,
                    trays: parseInt(p.Trays_Needed || p.trays_needed || 0),
                    plants: parseInt(p.Plants_Needed || p.plants_needed || 0),
                    rowIndex: p.rowIndex || index + 2
                };
            }).filter(p => p !== null);
        }

        // Parse dates in various formats: "5/15/2026 20:00:00", "2026-05-15", etc.
        function parseFlexibleDate(dateVal) {
            if (!dateVal) return null;

            // Already a Date object
            if (dateVal instanceof Date) {
                return isNaN(dateVal.getTime()) ? null : dateVal.toISOString().split('T')[0];
            }

            const str = String(dateVal).trim();
            if (!str) return null;

            // Try M/D/YYYY format (Google Sheets format)
            const mdyMatch = str.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})/);
            if (mdyMatch) {
                const [_, month, day, year] = mdyMatch;
                return `${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;
            }

            // Try ISO format YYYY-MM-DD
            const isoMatch = str.match(/^(\d{4})-(\d{2})-(\d{2})/);
            if (isoMatch) {
                return `${isoMatch[1]}-${isoMatch[2]}-${isoMatch[3]}`;
            }

            // Try to parse as Date
            try {
                const d = new Date(str);
                if (!isNaN(d.getTime())) {
                    return d.toISOString().split('T')[0];
                }
            } catch (e) {}

            return null;
        }

        function extractFieldAndBed(targetBed) {
            if (!targetBed) return { field: 'Unknown', bedNum: '01' };

            // Handle "Field F3L-01" format
            const fieldMatch = targetBed.match(/Field\s+([A-Z0-9]+)-?(\d*)/i);
            if (fieldMatch) {
                return {
                    field: fieldMatch[1].toUpperCase(),
                    bedNum: fieldMatch[2] || '01'
                };
            }

            // Handle "F3L-01" format (without "Field" prefix)
            const simpleMatch = targetBed.match(/^([A-Z0-9]+)-(\d+)$/i);
            if (simpleMatch) {
                return {
                    field: simpleMatch[1].toUpperCase(),
                    bedNum: simpleMatch[2]
                };
            }

            // Fallback
            return { field: targetBed.substring(0, 3).toUpperCase(), bedNum: '01' };
        }

        function formatDateString(date) {
            if (!date) return new Date().toISOString().split('T')[0];
            if (typeof date === 'string' && date.includes('T')) {
                return date.split('T')[0];
            }
            const d = new Date(date);
            return d.toISOString().split('T')[0];
        }

        function computeStatus(seedDate, harvestDate) {
            const today = new Date();
            const seed = new Date(seedDate);
            const harvest = new Date(harvestDate);
            const harvestEnd = new Date(harvest);
            harvestEnd.setDate(harvestEnd.getDate() + 14);

            if (today < seed) return 'seeding';
            if (today > harvestEnd) return 'completed';
            if (today >= harvest) return 'harvest';
            return 'growing';
        }

        function daysBetween(date1, date2) {
            const d1 = new Date(date1);
            const d2 = new Date(date2);
            return Math.ceil((d2 - d1) / (24 * 60 * 60 * 1000));
        }

        function extractFieldsAndCrops() {
            // Extract unique fields from plantings AND include all default fields
            const fieldSet = new Set(plantings.map(p => p.field));
            DEFAULT_FIELDS.forEach(f => fieldSet.add(f));
            fields = Array.from(fieldSet).filter(f => f).sort();

            // Generate all beds for all fields (using per-field bed count)
            allBeds = [];
            fields.forEach(field => {
                const bedCount = FIELD_CONFIG[field] || 12; // Default to 12 if not configured
                for (let i = 1; i <= bedCount; i++) {
                    const bedNum = String(i).padStart(2, '0');
                    allBeds.push({
                        field: field,
                        bed: `Field ${field}-${bedNum}`,
                        bedNum: bedNum,
                        group: `${field}|Field ${field}-${bedNum}`
                    });
                }
            });

            // Populate crop filter
            const cropSet = new Set(plantings.map(p => p.crop));
            const cropFilter = document.getElementById('cropFilter');
            cropFilter.innerHTML = '<option value="">All Crops</option>';
            Array.from(cropSet).sort().forEach(crop => {
                cropFilter.innerHTML += `<option value="${crop}">${crop}</option>`;
            });

            // Populate field filter
            const fieldFilter = document.getElementById('fieldFilter');
            fieldFilter.innerHTML = '<option value="">All Fields</option>';
            fields.forEach(field => {
                fieldFilter.innerHTML += `<option value="${field}">Field ${field}</option>`;
            });
        }

        // Demo Data - matches actual farm data structure
        function getDemoPlantings() {
            const demoData = [];
            const crops = [
                { name: 'Lettuce', variety: 'Salanova Formula Mix', method: 'Transplant', dtm: 52 },
                { name: 'Kale', variety: 'Black Magic', method: 'Transplant', dtm: 62 },
                { name: 'Kale', variety: 'Winterbor', method: 'Transplant', dtm: 90 },
                { name: 'Broccoli', variety: 'BC1611', method: 'Transplant', dtm: 43 },
                { name: 'Basil', variety: 'Prospera DMR', method: 'Paperpot', dtm: 116 },
                { name: 'Beets', variety: 'Formanova', method: 'Direct Seed', dtm: 52 },
                { name: 'Carrots', variety: 'Bolero', method: 'Direct Seed', dtm: 73 },
                { name: 'Eggplant', variety: 'Nigral', method: 'Transplant', dtm: 72 },
                { name: 'Winter Squash', variety: 'Delicata JS', method: 'Transplant', dtm: 105 },
                { name: 'Fennel', variety: 'Preludio', method: 'Transplant', dtm: 82 }
            ];

            const demoFields = ['F3L', 'HOL', 'IL', 'JL', 'JS1'];
            let id = 1;

            crops.forEach((crop, cropIndex) => {
                const successions = crop.name === 'Lettuce' ? 5 :
                                   crop.name === 'Carrots' ? 4 : 2;

                for (let s = 0; s < successions; s++) {
                    const transplantDate = new Date('2026-04-02');
                    transplantDate.setDate(transplantDate.getDate() + (s * 21) + (cropIndex * 7));

                    const harvestDate = new Date(transplantDate);
                    harvestDate.setDate(harvestDate.getDate() + crop.dtm);

                    const field = demoFields[cropIndex % demoFields.length];
                    const bedNum = ((s % 12) + 1).toString().padStart(2, '0');

                    demoData.push({
                        id: `26-${crop.name.substring(0,3).toUpperCase()}-${String(id++).padStart(4, '0')}`,
                        crop: crop.name,
                        variety: crop.variety,
                        plantingMethod: crop.method,
                        fieldStartDate: transplantDate.toISOString().split('T')[0],
                        harvestDate: harvestDate.toISOString().split('T')[0],
                        seedDate: transplantDate.toISOString().split('T')[0],
                        bed: `Field ${field}-${bedNum}`,
                        field: field,
                        bedNum: bedNum,
                        bedFeet: 200 + Math.floor(Math.random() * 300),
                        status: computeStatus(transplantDate, harvestDate),
                        dtm: crop.dtm
                    });
                }
            });

            return demoData;
        }

        // Apply Filters
        function applyFilters() {
            const cropFilter = document.getElementById('cropFilter').value;
            const fieldFilter = document.getElementById('fieldFilter').value;
            const statusFilters = Array.from(document.querySelectorAll('.checkbox-filter input:checked'))
                                      .map(cb => cb.dataset.status);

            filteredPlantings = plantings.filter(p => {
                if (cropFilter && p.crop !== cropFilter) return false;
                if (fieldFilter && p.field !== fieldFilter) return false;
                if (!statusFilters.includes(p.status)) return false;
                return true;
            });

            // Set fixed timeline for 2026 season (don't auto-calculate - prevents crashes with bad data)
            timelineStart = new Date('2026-01-01');
            timelineEnd = new Date('2026-12-31');

            updateStats();
            renderGantt();
        }

        function updateStats() {
            document.getElementById('totalPlantings').textContent = filteredPlantings.length;
            document.getElementById('activePlantings').textContent = filteredPlantings.filter(p => p.status === 'growing').length;
            document.getElementById('harvestReady').textContent = filteredPlantings.filter(p => p.status === 'harvest').length;
            document.getElementById('totalBedFeet').textContent = filteredPlantings.reduce((sum, p) => sum + (p.bedFeet || 0), 0);
        }

        // Set Zoom Level
        function setZoom(level) {
            zoomLevel = level;
            // dayWidth values: day=30, week=20, month=8, quarter=4, year=2
            const widths = { day: 30, week: 20, month: 8, quarter: 4, year: 2 };
            dayWidth = widths[level] || 20;

            document.querySelectorAll('#zoom-day, #zoom-week, #zoom-month, #zoom-quarter, #zoom-year').forEach(btn => btn.classList.remove('active'));
            document.getElementById(`zoom-${level}`).classList.add('active');

            // For quarter and year views, show full timeline
            if (level === 'quarter' || level === 'year') {
                timelineStart = new Date('2026-01-01');
                timelineEnd = new Date('2026-12-31');
            }

            renderGantt();
            updateRangeDisplay();
        }

        // Set View Mode (field, crop, variety)
        function setViewMode(mode) {
            viewMode = mode;

            // Update button states
            document.querySelectorAll('#view-field, #view-bed, #view-crop, #view-variety').forEach(btn => btn.classList.remove('active'));
            document.getElementById(`view-${mode}`).classList.add('active');

            // Update page title
            const titles = {
                'field': 'Field Calendar',
                'bed': 'Bed Calendar',
                'crop': 'Crop Calendar',
                'variety': 'Variety Calendar'
            };
            document.querySelector('.page-title').innerHTML = `<i class="fas fa-calendar-alt"></i> ${titles[mode] || 'Calendar'}`;

            renderGantt();
        }

        // Timeline Navigation Functions
        function navigateTimeline(days) {
            timelineStart.setDate(timelineStart.getDate() + days);
            timelineEnd.setDate(timelineEnd.getDate() + days);
            updateSliderPosition();
            renderGantt();
            updateRangeDisplay();
        }

        function onSliderChange(value) {
            const dayOfYear = parseInt(value);
            const yearStart = new Date('2026-01-01');
            timelineStart = new Date(yearStart);
            timelineStart.setDate(timelineStart.getDate() + dayOfYear);

            // Set end date based on view window (quarter and year show full year)
            const viewDaysMap = { day: 30, week: 90, month: 180, quarter: 365, year: 365 };
            const viewDays = viewDaysMap[zoomLevel] || 90;
            timelineEnd = new Date(timelineStart);
            timelineEnd.setDate(timelineEnd.getDate() + viewDays);

            // Cap at end of year
            const yearEnd = new Date('2026-12-31');
            if (timelineEnd > yearEnd) timelineEnd = yearEnd;

            renderGantt();
            updateRangeDisplay();
        }

        function goToToday() {
            const today = new Date();
            // Set timeline to start 2 weeks before today
            timelineStart = new Date(today);
            timelineStart.setDate(timelineStart.getDate() - 14);

            const viewDays = zoomLevel === 'day' ? 30 : zoomLevel === 'week' ? 90 : 180;
            timelineEnd = new Date(timelineStart);
            timelineEnd.setDate(timelineEnd.getDate() + viewDays);

            updateSliderPosition();
            renderGantt();
            updateRangeDisplay();
        }

        function showFullYear() {
            timelineStart = new Date('2026-01-01');
            timelineEnd = new Date('2026-12-31');
            setZoom('year'); // Full year view at smallest zoom
            document.getElementById('timelineSlider').value = 0;
            updateRangeDisplay();
        }

        function updateSliderPosition() {
            const yearStart = new Date('2026-01-01');
            const dayOfYear = Math.floor((timelineStart - yearStart) / (24 * 60 * 60 * 1000));
            document.getElementById('timelineSlider').value = Math.max(0, Math.min(365, dayOfYear));
        }

        function updateRangeDisplay() {
            const options = { month: 'short', day: 'numeric' };
            const startStr = timelineStart.toLocaleDateString('en-US', options);
            const endStr = timelineEnd.toLocaleDateString('en-US', options);
            document.getElementById('currentRange').textContent = `${startStr} - ${endStr}, 2026`;
        }

        // Render Gantt Chart
        function renderGantt() {
            const container = document.getElementById('ganttChart');

            if (filteredPlantings.length === 0) {
                container.innerHTML = `
                    <div class="loading">
                        <i class="fas fa-calendar-times" style="font-size: 3rem; margin-bottom: 1rem; color: var(--text-secondary);"></i>
                        <p>No plantings match your filters</p>
                    </div>
                `;
                return;
            }

            // Get grouping based on view mode
            let groups, headerIcon, headerLabel, getGroupName, getGroupMeta;

            if (viewMode === 'bed' || viewMode === 'field') {
                // Show ALL beds from allBeds array, not just beds with plantings
                // Filter by field if field filter is active
                const fieldFilter = document.getElementById('fieldFilter').value;
                const bedsToShow = fieldFilter
                    ? allBeds.filter(b => b.field === fieldFilter)
                    : allBeds;

                groups = bedsToShow.map(b => b.group);
                headerIcon = viewMode === 'field' ? 'fa-map' : 'fa-th';
                headerLabel = viewMode === 'field' ? 'Fields & Beds' : 'Beds';
                getGroupName = (group) => {
                    const [field, bed] = group.split('|');
                    // Handle both "Field F3L-01" and just "01" formats
                    const bedDisplay = bed.includes('Field') ? bed.replace('Field ', '') : `${field}-${bed}`;
                    return bedDisplay;
                };
                getGroupMeta = (plantings) => plantings.length > 0 ? `${plantings.length} plantings` : 'Empty';
            } else if (viewMode === 'crop') {
                groups = [...new Set(filteredPlantings.map(p => p.crop))].filter(c => c).sort();
                headerIcon = 'fa-seedling';
                headerLabel = 'Crops';
                getGroupName = (group) => group;
                getGroupMeta = (plantings) => `${plantings.length} plantings`;
            } else if (viewMode === 'variety') {
                groups = [...new Set(filteredPlantings.map(p => `${p.crop}|${p.variety || 'Unknown'}`))].filter(v => v).sort();
                headerIcon = 'fa-leaf';
                headerLabel = 'Varieties';
                getGroupName = (group) => {
                    const [crop, variety] = group.split('|');
                    return `${crop} - ${variety}`;
                };
                getGroupMeta = (plantings) => `${plantings.length} successions`;
            } else {
                // Default: field view
                groups = [...new Set(filteredPlantings.map(p => p.field))].sort();
                headerIcon = 'fa-map';
                headerLabel = 'Fields';
                getGroupName = (group) => `Field ${group}`;
                getGroupMeta = (plantings) => `${plantings.length} plantings`;
            }

            // Calculate timeline
            const totalDays = Math.ceil((timelineEnd - timelineStart) / (24 * 60 * 60 * 1000));
            const timelineWidth = totalDays * dayWidth;

            // Build labels HTML and rows HTML separately
            let labelsHtml = '';
            let rowsHtml = '';
            const rowHeights = [];

            // Render rows based on view mode
            groups.forEach((group, index) => {
                let groupPlantings;
                let isEmpty = false;

                if (viewMode === 'bed' || viewMode === 'field') {
                    // Both field and bed view show individual beds
                    const [field, bed] = group.split('|');
                    groupPlantings = filteredPlantings.filter(p => {
                        const pBed = p.bed || p.Bed || p.bedNumber || '1';
                        // Handle "Field F3L-01" format from allBeds
                        return p.field === field && (pBed === bed || `Field ${p.field}-${pBed.toString().padStart(2,'0')}` === bed);
                    });
                    isEmpty = groupPlantings.length === 0;
                } else if (viewMode === 'crop') {
                    groupPlantings = filteredPlantings.filter(p => p.crop === group);
                } else if (viewMode === 'variety') {
                    const [crop, variety] = group.split('|');
                    groupPlantings = filteredPlantings.filter(p => p.crop === crop && (p.variety || 'Unknown') === variety);
                } else {
                    groupPlantings = filteredPlantings.filter(p => p.field === group);
                }

                const stackedPlantings = calculateStacking(groupPlantings);
                const rowHeight = Math.max(50, (stackedPlantings.maxStack + 1) * 44);
                rowHeights.push(rowHeight);

                const emptyClass = isEmpty ? ' empty-bed' : '';

                // Label for left column
                labelsHtml += `
                    <div class="gantt-label${emptyClass}" style="height: ${rowHeight}px;">
                        <div class="field-name">${getGroupName(group)}</div>
                        <div class="field-meta">${getGroupMeta(groupPlantings)}</div>
                    </div>
                `;

                // Content row - store field and bed info for drop targeting
                const [rowField, rowBed] = group.split('|');
                rowsHtml += `
                    <div class="gantt-row${emptyClass}" data-group="${group}" data-field="${rowField}" data-bed="${rowBed}" style="height: ${rowHeight}px; width: ${timelineWidth}px;">
                        <div class="timeline-grid">
                            ${generateGridLines(totalDays)}
                        </div>
                        ${isEmpty ? '' : renderGaps(groupPlantings, getGroupName(group))}
                        ${renderTodayLine(totalDays)}
                        ${renderCropBars(stackedPlantings.plantings, group)}
                    </div>
                `;
            });

            // Build the grid structure
            container.innerHTML = `
                <!-- Corner cell -->
                <div class="gantt-corner">
                    <i class="fas ${headerIcon}"></i> ${headerLabel}
                </div>

                <!-- Header row (date headers) -->
                <div class="gantt-header-scroll" id="headerScroll">
                    <div class="gantt-header-inner" style="width: ${timelineWidth}px;">
                        <div class="gantt-months-row">
                            ${generateMonthHeaders(totalDays)}
                        </div>
                        <div class="gantt-days-row">
                            ${generateDayHeaders(totalDays)}
                        </div>
                    </div>
                </div>

                <!-- Labels column (field/bed names) -->
                <div class="gantt-labels-scroll" id="labelsScroll">
                    ${labelsHtml}
                </div>

                <!-- Main content area -->
                <div class="gantt-content-scroll" id="contentScroll">
                    <div class="gantt-content-inner" style="width: ${timelineWidth}px;">
                        ${rowsHtml}
                    </div>
                </div>
            `;

            // Set up synchronized scrolling
            setupScrollSync();

            // Initialize drag and resize
            initializeInteractions();
        }

        // Synchronized scrolling for sticky headers
        function setupScrollSync() {
            const contentScroll = document.getElementById('contentScroll');
            const headerScroll = document.getElementById('headerScroll');
            const labelsScroll = document.getElementById('labelsScroll');

            if (!contentScroll || !headerScroll || !labelsScroll) return;

            contentScroll.addEventListener('scroll', function() {
                // Sync horizontal scroll with header
                headerScroll.scrollLeft = contentScroll.scrollLeft;
                // Sync vertical scroll with labels
                labelsScroll.scrollTop = contentScroll.scrollTop;
            });
        }

        function generateMonthHeaders(totalDays) {
            let html = '';
            let currentDate = new Date(timelineStart);

            while (currentDate <= timelineEnd) {
                const monthStart = new Date(currentDate);
                const monthEnd = new Date(currentDate.getFullYear(), currentDate.getMonth() + 1, 0);
                const daysInView = Math.min(
                    Math.ceil((monthEnd - monthStart) / (24 * 60 * 60 * 1000)) + 1,
                    Math.ceil((timelineEnd - monthStart) / (24 * 60 * 60 * 1000)) + 1
                );

                const width = daysInView * dayWidth;
                const label = currentDate.toLocaleDateString('en-US', { month: 'short', year: '2-digit' });

                html += `<div class="gantt-month" style="width: ${width}px;">${label}</div>`;

                currentDate.setMonth(currentDate.getMonth() + 1);
                currentDate.setDate(1);
            }

            return html;
        }

        function generateDayHeaders(totalDays) {
            let html = '';
            const today = new Date();
            today.setHours(0, 0, 0, 0);

            for (let i = 0; i < totalDays; i++) {
                const date = new Date(timelineStart);
                date.setDate(date.getDate() + i);

                const isToday = date.getTime() === today.getTime();
                const isWeekend = date.getDay() === 0 || date.getDay() === 6;

                let label = '';
                if (zoomLevel === 'day') {
                    label = date.getDate();
                } else if (zoomLevel === 'week') {
                    if (date.getDay() === 1 || i === 0) {
                        label = date.getDate();
                    }
                } else {
                    if (date.getDate() === 1 || date.getDate() === 15) {
                        label = date.getDate();
                    }
                }

                const classes = ['gantt-day'];
                if (isToday) classes.push('today');
                if (isWeekend) classes.push('weekend');

                html += `<div class="${classes.join(' ')}" style="width: ${dayWidth}px;">${label}</div>`;
            }

            return html;
        }

        function generateGridLines(totalDays) {
            let html = '';
            for (let i = 0; i < totalDays; i++) {
                const date = new Date(timelineStart);
                date.setDate(date.getDate() + i);
                const isWeekStart = date.getDay() === 1;
                html += `<div class="grid-line ${isWeekStart ? 'week-start' : ''}" style="width: ${dayWidth}px;"></div>`;
            }
            return html;
        }

        function renderTodayLine(totalDays) {
            const today = new Date();
            if (today < timelineStart || today > timelineEnd) return '';

            const dayOffset = Math.ceil((today - timelineStart) / (24 * 60 * 60 * 1000));
            const left = dayOffset * dayWidth;

            return `
                <div class="today-line" style="left: ${left}px;">
                    <div class="today-marker">TODAY</div>
                </div>
            `;
        }

        function calculateStacking(fieldPlantings) {
            // Sort by start date
            const sorted = [...fieldPlantings].sort((a, b) => new Date(a.seedDate) - new Date(b.seedDate));

            const stacks = [];
            let maxStack = 0;

            sorted.forEach(planting => {
                const start = new Date(planting.seedDate);
                const end = new Date(planting.harvestDate);

                // Find the lowest stack level that doesn't overlap
                let stackLevel = 0;
                for (let i = 0; i < stacks.length; i++) {
                    const lastEnd = stacks[i];
                    if (start >= lastEnd) {
                        stackLevel = i;
                        break;
                    }
                    stackLevel = i + 1;
                }

                // Update the stack end date
                stacks[stackLevel] = end;
                planting.stackLevel = stackLevel;
                maxStack = Math.max(maxStack, stackLevel);
            });

            return { plantings: sorted, maxStack };
        }

        function renderCropBars(fieldPlantings, field) {
            let html = '';

            fieldPlantings.forEach(planting => {
                const startDate = new Date(planting.fieldStartDate || planting.seedDate);
                const endDate = new Date(planting.harvestDate);

                const startOffset = Math.max(0, (startDate - timelineStart) / (24 * 60 * 60 * 1000));
                const duration = Math.ceil((endDate - startDate) / (24 * 60 * 60 * 1000));

                const left = startOffset * dayWidth;
                const width = Math.max(duration * dayWidth, 60);
                const top = 8 + (planting.stackLevel * 44);

                const icon = cropIcons[planting.crop] || 'ðŸŒ±';

                // Build display text - show variety if bar is wide enough
                const displayText = width > 120
                    ? `${planting.crop} - ${planting.variety}`
                    : planting.crop;

                // Add locked class if already sown
                const lockedClass = planting.isLocked ? 'locked' : '';
                const lockIcon = planting.isLocked ? 'ðŸ”’ ' : '';

                // Get crop color - from API profiles, fallback to default colors
                const cropColor = getCropColor(planting.crop);
                const barStyle = cropColor
                    ? `background: linear-gradient(135deg, ${cropColor} 0%, ${lightenColor(cropColor, 20)} 100%);`
                    : '';

                // Add opacity for completed status
                const completedStyle = planting.status === 'completed' ? 'opacity: 0.6;' : '';

                html += `
                    <div class="crop-bar ${lockedClass}"
                         id="bar-${planting.id}"
                         data-id="${planting.id}"
                         data-field="${planting.field}"
                         data-crop="${planting.crop}"
                         data-locked="${planting.isLocked}"
                         data-start="${planting.fieldStartDate || planting.seedDate}"
                         data-end="${planting.harvestDate}"
                         style="left: ${left}px; width: ${width}px; top: ${top}px; ${barStyle} ${completedStyle} cursor: pointer;"
                         ondblclick="openEditModal('${planting.id}')"
                         onmouseenter="showTooltip(event, '${planting.id}')"
                         onmouseleave="hideTooltip()">
                        <div class="resize-handle resize-handle-left" data-edge="left"></div>
                        <span class="crop-bar-icon">${lockIcon}${icon}</span>
                        <div class="crop-bar-content">
                            <div class="crop-bar-name">${displayText}</div>
                            <div class="crop-bar-dates">${planting.variety ? planting.variety.substring(0, 15) : ''} ${planting.dtm}d</div>
                        </div>
                        <div class="resize-handle resize-handle-right" data-edge="right"></div>
                    </div>
                `;
            });

            return html;
        }

        // Render gaps (empty spaces) between plantings
        function renderGaps(fieldPlantings, groupName) {
            let html = '';

            // Escape group name for use in HTML/JS
            const safeGroupName = (groupName || '').replace(/'/g, "\\'").replace(/"/g, '&quot;');

            // Sort plantings by field start date
            const sorted = [...fieldPlantings].sort((a, b) => {
                const aStart = new Date(a.fieldStartDate || a.seedDate);
                const bStart = new Date(b.fieldStartDate || b.seedDate);
                return aStart - bStart;
            });

            // Find gaps
            const gaps = [];
            const seasonStart = new Date(timelineStart);
            const seasonEnd = new Date(timelineEnd);

            // Check for gap at the beginning of timeline
            if (sorted.length > 0) {
                const firstPlanting = sorted[0];
                const firstStart = new Date(firstPlanting.fieldStartDate || firstPlanting.seedDate);
                if (firstStart > seasonStart) {
                    const gapDays = Math.floor((firstStart - seasonStart) / (24 * 60 * 60 * 1000));
                    if (gapDays >= 7) {
                        gaps.push({
                            start: new Date(seasonStart),
                            end: new Date(firstStart),
                            type: 'before'
                        });
                    }
                }
            } else {
                // No plantings - entire timeline is a gap
                gaps.push({
                    start: new Date(seasonStart),
                    end: new Date(seasonEnd),
                    type: 'empty'
                });
            }

            // Check for gaps between plantings (non-overlapping)
            for (let i = 0; i < sorted.length - 1; i++) {
                const current = sorted[i];
                const next = sorted[i + 1];
                const currentEnd = new Date(current.harvestDate || current.lastHarvest || current.fieldStartDate);
                const nextStart = new Date(next.fieldStartDate || next.seedDate);

                // If there's a gap of at least 7 days
                if (!isNaN(currentEnd.getTime()) && !isNaN(nextStart.getTime())) {
                    const gapDays = Math.floor((nextStart - currentEnd) / (24 * 60 * 60 * 1000));
                    if (gapDays >= 7) {
                        gaps.push({
                            start: new Date(currentEnd),
                            end: new Date(nextStart),
                            type: 'between'
                        });
                    }
                }
            }

            // Check for gap at the end of timeline
            if (sorted.length > 0) {
                const lastPlanting = sorted[sorted.length - 1];
                const lastEnd = new Date(lastPlanting.harvestDate || lastPlanting.lastHarvest || lastPlanting.fieldStartDate);
                if (!isNaN(lastEnd.getTime()) && lastEnd < seasonEnd) {
                    const gapDays = Math.floor((seasonEnd - lastEnd) / (24 * 60 * 60 * 1000));
                    if (gapDays >= 7) {
                        gaps.push({
                            start: new Date(lastEnd),
                            end: new Date(seasonEnd),
                            type: 'after'
                        });
                    }
                }
            }

            // Render gap indicators
            gaps.forEach((gap, index) => {
                const startOffset = Math.max(0, (gap.start - timelineStart) / (24 * 60 * 60 * 1000));
                const gapDuration = Math.ceil((gap.end - gap.start) / (24 * 60 * 60 * 1000));

                // Only show gaps that are visible in the timeline and have width
                if (startOffset >= 0 && gapDuration > 0) {
                    const left = startOffset * dayWidth;
                    const width = Math.max(gapDuration * dayWidth, 20); // Minimum 20px width for clickability

                    // Format dates for data attributes
                    const startStr = gap.start.toISOString().split('T')[0];
                    const endStr = gap.end.toISOString().split('T')[0];

                    html += `
                        <div class="field-gap"
                             data-group="${safeGroupName}"
                             data-start="${startStr}"
                             data-end="${endStr}"
                             data-days="${gapDuration}"
                             style="left: ${left}px; width: ${width}px;"
                             onmouseenter="showGapTooltip(event, '${safeGroupName}', '${startStr}', '${endStr}', ${gapDuration})"
                             onmousemove="moveGapTooltip(event)"
                             onmouseleave="hideGapTooltip()">
                        </div>
                    `;
                }
            });

            return html;
        }

        // Gap tooltip functions
        function showGapTooltip(event, groupName, startDate, endDate, days) {
            const tooltip = document.getElementById('gapTooltip');

            // Format dates nicely
            const start = new Date(startDate);
            const end = new Date(endDate);
            const startStr = start.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
            const endStr = end.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });

            document.getElementById('gapDuration').textContent = `${days} days`;
            document.getElementById('gapDateRange').textContent = `${startStr} - ${endStr}`;
            document.getElementById('gapField').textContent = groupName;

            // Position tooltip
            tooltip.style.left = (event.clientX + 15) + 'px';
            tooltip.style.top = (event.clientY + 15) + 'px';
            tooltip.classList.add('visible');
        }

        function moveGapTooltip(event) {
            const tooltip = document.getElementById('gapTooltip');
            tooltip.style.left = (event.clientX + 15) + 'px';
            tooltip.style.top = (event.clientY + 15) + 'px';
        }

        function hideGapTooltip() {
            document.getElementById('gapTooltip').classList.remove('visible');
        }

        // Get crop color from profiles or fallback
        function getCropColor(cropName) {
            // First check API-loaded colors
            if (cropProfileColors[cropName]) {
                return cropProfileColors[cropName];
            }
            // Then check default colors
            if (cropColors[cropName]) {
                return cropColors[cropName];
            }
            // Default fallback
            return '#2d5a27';
        }

        // Lighten a hex color by a percentage
        function lightenColor(hex, percent) {
            const num = parseInt(hex.replace('#', ''), 16);
            const amt = Math.round(2.55 * percent);
            const R = Math.min(255, (num >> 16) + amt);
            const G = Math.min(255, ((num >> 8) & 0x00FF) + amt);
            const B = Math.min(255, (num & 0x0000FF) + amt);
            return '#' + (0x1000000 + R * 0x10000 + G * 0x100 + B).toString(16).slice(1);
        }

        // Track current drag state for date display
        let currentDragPlanting = null;

        // Initialize Drag and Resize with interact.js
        function initializeInteractions() {
            interact('.crop-bar:not(.locked)')
                .draggable({
                    inertia: false,
                    modifiers: [
                        interact.modifiers.restrictRect({
                            restriction: '.gantt-body',
                            endOnly: true
                        })
                    ],
                    autoScroll: true,
                    listeners: {
                        start(event) {
                            // Double-check not locked
                            if (event.target.dataset.locked === 'true') {
                                showToast('This planting is locked (already sown)', 'error');
                                return false;
                            }
                            event.target.classList.add('dragging');
                            hideTooltip();

                            // Setup drag tooltip
                            const id = event.target.dataset.id;
                            currentDragPlanting = plantings.find(p => p.id === id);

                            // Create ghost at original position (only if not already moved)
                            if (!originalPositions.has(id)) {
                                createGhost(id, event.target);
                            }

                            if (currentDragPlanting) {
                                showDragTooltip(event, currentDragPlanting);
                            }
                        },
                        move(event) {
                            const target = event.target;
                            const x = (parseFloat(target.getAttribute('data-x')) || parseFloat(target.style.left)) + event.dx;
                            const y = (parseFloat(target.getAttribute('data-y')) || parseFloat(target.style.top)) + event.dy;

                            target.style.left = `${x}px`;
                            target.style.top = `${y}px`;
                            target.setAttribute('data-x', x);
                            target.setAttribute('data-y', y);

                            // Highlight drop target row
                            const dropTarget = getRowAtPosition(event.clientY);
                            document.querySelectorAll('.gantt-row').forEach(el => el.classList.remove('drop-target'));
                            if (dropTarget) dropTarget.classList.add('drop-target');

                            // Update real-time date display
                            if (currentDragPlanting) {
                                updateDragTooltip(event, x);
                            }
                        },
                        end(event) {
                            event.target.classList.remove('dragging');
                            document.querySelectorAll('.gantt-row').forEach(el => el.classList.remove('drop-target'));
                            hideDragTooltip();

                            const target = event.target;
                            const id = target.dataset.id;
                            const newLeft = parseFloat(target.style.left);

                            // Calculate new start date from position
                            const daysFromStart = Math.round(newLeft / dayWidth);
                            const newStartDate = new Date(timelineStart);
                            newStartDate.setDate(newStartDate.getDate() + daysFromStart);

                            // Check for row change (field + bed)
                            const dropTargetRow = getRowAtPosition(event.clientY);
                            let newField = target.dataset.field;
                            let newBed = null;

                            if (dropTargetRow) {
                                newField = dropTargetRow.dataset.field;
                                newBed = dropTargetRow.dataset.bed; // e.g., "Field F3L-01"

                                // If dropping to a different row, move the element to that row
                                const currentRow = target.closest('.gantt-row');
                                if (currentRow && currentRow !== dropTargetRow) {
                                    // Move the bar element to the new row
                                    dropTargetRow.appendChild(target);
                                    // Reset Y position since we moved to new row
                                    target.style.top = '4px';
                                    target.setAttribute('data-y', '4');
                                }
                            }

                            // Mark as moved
                            target.classList.add('moved');

                            // Update planting with date cascade (no re-render!)
                            updatePlantingDates(id, newStartDate, null, newField, newBed);
                            currentDragPlanting = null;
                        }
                    }
                })
                .resizable({
                    edges: { left: '.resize-handle-left', right: '.resize-handle-right' },
                    listeners: {
                        start(event) {
                            if (event.target.dataset.locked === 'true') {
                                showToast('This planting is locked (already sown)', 'error');
                                return false;
                            }
                            event.target.classList.add('resizing');
                            hideTooltip();

                            // Setup drag tooltip for resize
                            const id = event.target.dataset.id;
                            currentDragPlanting = plantings.find(p => p.id === id);
                            if (currentDragPlanting) {
                                showDragTooltip(event, currentDragPlanting);
                            }
                        },
                        move(event) {
                            const target = event.target;
                            let x = parseFloat(target.style.left) || 0;
                            let width = event.rect.width;

                            // Handle left edge resize
                            if (event.edges.left) {
                                x += event.deltaRect.left;
                            }

                            target.style.width = `${width}px`;
                            target.style.left = `${x}px`;

                            // Update real-time date display for resize
                            if (currentDragPlanting) {
                                updateResizeTooltip(event, x, width);
                            }
                        },
                        end(event) {
                            event.target.classList.remove('resizing');
                            hideDragTooltip();

                            const target = event.target;
                            const id = target.dataset.id;
                            const left = parseFloat(target.style.left);
                            const width = parseFloat(target.style.width);

                            // Calculate new dates
                            const startDays = Math.round(left / dayWidth);
                            const durationDays = Math.round(width / dayWidth);

                            const newStartDate = new Date(timelineStart);
                            newStartDate.setDate(newStartDate.getDate() + startDays);

                            const newEndDate = new Date(newStartDate);
                            newEndDate.setDate(newEndDate.getDate() + durationDays);

                            updatePlantingDates(id, newStartDate, newEndDate, null);
                            currentDragPlanting = null;
                        }
                    },
                    modifiers: [
                        interact.modifiers.restrictSize({
                            min: { width: 40 }
                        })
                    ]
                });

            // Add click handler for locked bars
            document.querySelectorAll('.crop-bar.locked').forEach(bar => {
                bar.addEventListener('click', () => {
                    showToast('Locked: Already sown. Confirm termination to unlock.', 'warning');
                });
            });
        }

        // Show drag tooltip with current planting info
        function showDragTooltip(event, planting) {
            const tooltip = document.getElementById('dragTooltip');
            document.getElementById('dragCrop').textContent = `${planting.crop} - ${planting.variety}`;

            // Show GH sow row only if applicable
            const ghRow = document.getElementById('dragGHSow').parentElement;
            if (planting.planGHSow && planting.plantingMethod !== 'Direct Seed') {
                ghRow.style.display = 'flex';
                document.getElementById('dragGHSow').textContent = formatShortDate(planting.planGHSow);
            } else {
                ghRow.style.display = 'none';
            }

            document.getElementById('dragFieldStart').textContent = formatShortDate(planting.fieldStartDate);
            document.getElementById('dragHarvest').textContent = formatShortDate(planting.harvestDate);

            tooltip.style.left = (event.clientX + 20) + 'px';
            tooltip.style.top = (event.clientY - 80) + 'px';
            tooltip.classList.add('show');
        }

        // Update drag tooltip with new calculated dates
        function updateDragTooltip(event, newLeft) {
            if (!currentDragPlanting) return;

            const tooltip = document.getElementById('dragTooltip');
            tooltip.style.left = (event.clientX + 20) + 'px';
            tooltip.style.top = (event.clientY - 80) + 'px';

            // Calculate new dates based on position
            const daysFromStart = Math.round(newLeft / dayWidth);
            const newFieldStart = new Date(timelineStart);
            newFieldStart.setDate(newFieldStart.getDate() + daysFromStart);

            // Calculate day shift
            const oldFieldStart = new Date(currentDragPlanting.fieldStartDate);
            const dayShift = Math.round((newFieldStart - oldFieldStart) / (24 * 60 * 60 * 1000));

            // Calculate cascaded dates
            let newGHSow = null;
            if (currentDragPlanting.planGHSow) {
                const oldGH = new Date(currentDragPlanting.planGHSow);
                newGHSow = new Date(oldGH);
                newGHSow.setDate(newGHSow.getDate() + dayShift);
            }

            const oldHarvest = new Date(currentDragPlanting.harvestDate);
            const newHarvest = new Date(oldHarvest);
            newHarvest.setDate(newHarvest.getDate() + dayShift);

            // Update display with highlight for changed dates
            const fieldEl = document.getElementById('dragFieldStart');
            const harvestEl = document.getElementById('dragHarvest');
            const ghEl = document.getElementById('dragGHSow');

            fieldEl.textContent = formatShortDate(newFieldStart.toISOString().split('T')[0]);
            harvestEl.textContent = formatShortDate(newHarvest.toISOString().split('T')[0]);

            if (newGHSow) {
                ghEl.textContent = formatShortDate(newGHSow.toISOString().split('T')[0]);
            }

            // Add changed class if dates are different
            if (dayShift !== 0) {
                fieldEl.classList.add('changed');
                harvestEl.classList.add('changed');
                if (newGHSow) ghEl.classList.add('changed');
            } else {
                fieldEl.classList.remove('changed');
                harvestEl.classList.remove('changed');
                ghEl.classList.remove('changed');
            }
        }

        // Update tooltip for resize operations
        function updateResizeTooltip(event, newLeft, newWidth) {
            if (!currentDragPlanting) return;

            const tooltip = document.getElementById('dragTooltip');
            tooltip.style.left = (event.clientX + 20) + 'px';
            tooltip.style.top = (event.clientY - 80) + 'px';

            // Calculate new dates
            const startDays = Math.round(newLeft / dayWidth);
            const durationDays = Math.round(newWidth / dayWidth);

            const newFieldStart = new Date(timelineStart);
            newFieldStart.setDate(newFieldStart.getDate() + startDays);

            const newHarvest = new Date(newFieldStart);
            newHarvest.setDate(newHarvest.getDate() + durationDays);

            // Calculate GH sow if start date changed
            const oldFieldStart = new Date(currentDragPlanting.fieldStartDate);
            const dayShift = Math.round((newFieldStart - oldFieldStart) / (24 * 60 * 60 * 1000));

            let newGHSow = null;
            if (currentDragPlanting.planGHSow) {
                const oldGH = new Date(currentDragPlanting.planGHSow);
                newGHSow = new Date(oldGH);
                newGHSow.setDate(newGHSow.getDate() + dayShift);
            }

            // Update display
            const fieldEl = document.getElementById('dragFieldStart');
            const harvestEl = document.getElementById('dragHarvest');
            const ghEl = document.getElementById('dragGHSow');

            fieldEl.textContent = formatShortDate(newFieldStart.toISOString().split('T')[0]);
            harvestEl.textContent = formatShortDate(newHarvest.toISOString().split('T')[0]);

            if (newGHSow) {
                ghEl.textContent = formatShortDate(newGHSow.toISOString().split('T')[0]);
            }

            // Highlight changes
            fieldEl.classList.add('changed');
            harvestEl.classList.add('changed');
            if (newGHSow) ghEl.classList.add('changed');
        }

        function hideDragTooltip() {
            document.getElementById('dragTooltip').classList.remove('show');
        }

        function formatShortDate(dateStr) {
            if (!dateStr) return '-';
            const date = new Date(dateStr);
            return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
        }

        // Format date for Google Sheets (M/D/YYYY format)
        function formatDateForSheet(dateStr) {
            if (!dateStr) return '';
            try {
                const date = new Date(dateStr);
                if (isNaN(date.getTime())) return dateStr; // Return as-is if invalid
                const month = date.getMonth() + 1;
                const day = date.getDate();
                const year = date.getFullYear();
                return `${month}/${day}/${year}`;
            } catch (e) {
                return dateStr; // Return as-is if error
            }
        }

        function getFieldAtPosition(clientY) {
            const fieldRows = document.querySelectorAll('.field-timeline');
            for (const row of fieldRows) {
                const rect = row.getBoundingClientRect();
                if (clientY >= rect.top && clientY <= rect.bottom) {
                    return row;
                }
            }
            return null;
        }

        // Get the gantt row at a Y position (for drop targeting)
        function getRowAtPosition(clientY) {
            const rows = document.querySelectorAll('.gantt-row');
            for (const row of rows) {
                const rect = row.getBoundingClientRect();
                if (clientY >= rect.top && clientY <= rect.bottom) {
                    return row;
                }
            }
            return null;
        }

        // Create a ghost element at the original position of a dragged planting
        function createGhost(plantingId, element) {
            // Don't create duplicate ghosts
            if (ghostElements.has(plantingId)) return;

            const rect = element.getBoundingClientRect();
            const parentRect = element.parentElement.getBoundingClientRect();

            // Store original position info
            const planting = plantings.find(p => p.id === plantingId);
            if (!planting) return;

            originalPositions.set(plantingId, {
                field: planting.field,
                bed: planting.bed,
                fieldStartDate: planting.fieldStartDate,
                left: parseFloat(element.style.left),
                top: parseFloat(element.style.top) || 0,
                rowGroup: element.closest('.gantt-row')?.dataset.group
            });

            // Create ghost element
            const ghost = document.createElement('div');
            ghost.className = 'crop-bar-ghost';
            ghost.style.cssText = `
                left: ${element.style.left};
                top: ${element.style.top || '0px'};
                width: ${element.style.width};
                height: ${element.offsetHeight}px;
                background-color: ${element.style.backgroundColor};
            `;
            ghost.dataset.ghostFor = plantingId;

            // Insert ghost into the same parent
            element.parentElement.appendChild(ghost);
            ghostElements.set(plantingId, ghost);
        }

        // Clear all ghost elements (called on submit or discard)
        function clearAllGhosts() {
            ghostElements.forEach((ghost, id) => {
                ghost.remove();
            });
            ghostElements.clear();
            originalPositions.clear();

            // Remove 'moved' class from all bars
            document.querySelectorAll('.crop-bar.moved').forEach(bar => {
                bar.classList.remove('moved');
            });
        }

        // Update Planting Dates
        // CASCADE ALL DATES when field start changes
        function updatePlantingDates(id, newFieldStartDate, newEndDate, newField, newBed = null) {
            const planting = plantings.find(p => p.id === id);
            if (!planting) return;

            // Check if locked
            if (planting.isLocked) {
                showToast(`Cannot move: ${planting.lockReason}`, 'error');
                // Snap back by re-rendering just this element would be complex,
                // for locked items we do need to re-render to restore position
                applyFilters();
                return;
            }

            const oldFieldStart = new Date(planting.fieldStartDate);
            const oldHarvest = new Date(planting.harvestDate);

            // Calculate shift in days
            let dayShift = 0;
            if (newFieldStartDate) {
                dayShift = Math.round((newFieldStartDate - oldFieldStart) / (24 * 60 * 60 * 1000));
            }

            // --- CASCADE ALL DATES ---

            // 1. Update GH Sow date (shift by same amount)
            if (planting.planGHSow) {
                const oldGHSow = new Date(planting.planGHSow);
                oldGHSow.setDate(oldGHSow.getDate() + dayShift);
                planting.planGHSow = oldGHSow.toISOString().split('T')[0];
            }

            // 2. Update field start date (transplant or field sow)
            if (newFieldStartDate) {
                const newStartStr = newFieldStartDate.toISOString().split('T')[0];
                planting.fieldStartDate = newStartStr;
                planting.seedDate = newStartStr; // Legacy

                if (planting.plantingMethod === 'Direct Seed') {
                    planting.planFieldSow = newStartStr;
                } else {
                    planting.planTransplant = newStartStr;
                }
            }

            // 3. Update First Harvest (shift by same amount if exists)
            if (planting.firstHarvest) {
                const oldFirst = new Date(planting.firstHarvest);
                oldFirst.setDate(oldFirst.getDate() + dayShift);
                planting.firstHarvest = oldFirst.toISOString().split('T')[0];
            }

            // 4. Update Last Harvest
            if (newEndDate) {
                // User explicitly set new end date (resized)
                planting.harvestDate = newEndDate.toISOString().split('T')[0];
                planting.lastHarvest = planting.harvestDate;
            } else {
                // Maintain original duration (dragged)
                const shiftedHarvest = new Date(oldHarvest);
                shiftedHarvest.setDate(shiftedHarvest.getDate() + dayShift);
                planting.harvestDate = shiftedHarvest.toISOString().split('T')[0];
                planting.lastHarvest = planting.harvestDate;
            }

            // Update duration
            planting.dtm = daysBetween(planting.fieldStartDate, planting.harvestDate);
            planting.daysFieldToHarvest = planting.dtm;

            // 5. Update field and bed assignment
            if (newBed) {
                // Full bed was provided (e.g., "Field F3L-01")
                planting.bed = newBed;
                planting.field = newField;
                // Extract bed number
                const bedNumMatch = newBed.match(/(\d+)$/);
                planting.bedNum = bedNumMatch ? bedNumMatch[1] : '01';
            } else if (newField && newField !== planting.field) {
                // Only field changed, preserve bed number
                planting.field = newField;
                const bedNum = planting.bedNum || planting.bed.match(/\d+$/)?.[0] || '01';
                planting.bed = `Field ${newField}-${bedNum}`;
            }

            // Update status
            planting.status = computeStatus(planting.fieldStartDate, planting.harvestDate);

            // Queue for sync to Google Sheets
            queueUpdate(planting);

            // NO re-render - bar is already visually positioned correctly!
            // applyFilters(); // REMOVED - prevents scroll reset

            // Show confirmation with all dates
            const ghSowInfo = planting.planGHSow ? `GH: ${formatDisplayDate(planting.planGHSow)} â†’ ` : '';
            const bedInfo = planting.bed ? ` | ${planting.bed}` : '';
            showToast(`${planting.crop}: ${ghSowInfo}Field: ${formatDisplayDate(planting.fieldStartDate)} â†’ Harvest: ${formatDisplayDate(planting.harvestDate)}${bedInfo}`, 'success');
        }

        // Queue updates for batch saving
        function queueUpdate(planting) {
            pendingUpdates.set(planting.id, planting);

            // Update pending count display and show submit button
            updatePendingDisplay();
        }

        // Update the pending changes display
        function updatePendingDisplay() {
            const count = pendingUpdates.size;
            const submitBtn = document.getElementById('submitChangesBtn');
            const discardBtn = document.getElementById('discardBtn');
            const pendingCountEl = document.getElementById('pendingCount');

            if (count > 0) {
                submitBtn.classList.add('visible');
                discardBtn.classList.add('visible');
                pendingCountEl.textContent = count;
                setSyncStatus('pending', `${count} pending`);
            } else {
                submitBtn.classList.remove('visible');
                discardBtn.classList.remove('visible');
                setSyncStatus('synced', 'Synced');
            }
        }

        // Discard all pending changes and reload
        function discardChanges() {
            if (pendingUpdates.size === 0 && ghostElements.size === 0) return;

            if (confirm(`Discard ${pendingUpdates.size} pending change(s)? This will reload the calendar.`)) {
                pendingUpdates.clear();
                clearAllGhosts(); // Clear ghost elements
                updatePendingDisplay();
                loadPlantings(); // Reload from server to restore original positions
                showToast('Changes discarded', 'info');
            }
        }

        // Save to Google Sheets - CASCADE ALL DATES
        async function saveToGoogleSheets() {
            if (pendingUpdates.size === 0) return;

            const updates = Array.from(pendingUpdates.values());
            const saveCount = updates.length;
            pendingUpdates.clear();

            // Show saving status
            setSyncStatus('syncing', `Saving ${saveCount}...`);
            document.getElementById('submitChangesBtn').classList.remove('visible');
            document.getElementById('discardBtn').classList.remove('visible');

            try {
                for (const planting of updates) {
                    // Construct proper Target_Bed_ID format
                    const bedNum = planting.bedNum || (planting.bed ? planting.bed.match(/\d+$/)?.[0] : null) || '01';
                    const properBedId = planting.field ? `Field ${planting.field}-${bedNum}` : planting.bed;

                    // Use correct column names from actual sheet structure
                    // CASCADE: Update ALL related dates - auto-format to M/D/YYYY for Google Sheets
                    const updateData = {
                        action: 'updatePlanting',
                        id: planting.id,
                        Batch_ID: planting.id,
                        Target_Bed_ID: properBedId,
                        First_Harvest: formatDateForSheet(planting.firstHarvest),
                        Last_Harvest: formatDateForSheet(planting.harvestDate || planting.lastHarvest)
                    };

                    // Update GH Sow date if it exists
                    if (planting.planGHSow) {
                        updateData.Plan_GH_Sow = formatDateForSheet(planting.planGHSow);
                    }

                    // Update correct field start date based on planting method
                    if (planting.plantingMethod === 'Direct Seed') {
                        updateData.Plan_Field_Sow = formatDateForSheet(planting.planFieldSow || planting.fieldStartDate);
                    } else {
                        updateData.Plan_Transplant = formatDateForSheet(planting.planTransplant || planting.fieldStartDate);
                    }


                    // Use GET with URL parameters to avoid CORS preflight issues
                    const params = new URLSearchParams(updateData);
                    const response = await fetch(`${API_URL}?${params.toString()}`, {
                        method: 'GET',
                        redirect: 'follow'
                    });
                    const result = await response.json();

                    if (!result.success) {
                        console.error('Update failed:', result.error);
                        showToast(`Update failed: ${result.error}`, 'error');
                    } else {
                    }
                }

                setSyncStatus('synced', 'Saved');
                showToast(`Saved ${saveCount} change(s) to Google Sheets`, 'success');
                updatePendingDisplay();

                // Clear all ghosts - changes are now committed
                clearAllGhosts();
            } catch (error) {
                console.error('Error saving to Google Sheets:', error);
                setSyncStatus('error', 'Save Failed');
                showToast('Failed to save changes', 'error');
                updatePendingDisplay();
            }
        }

        // Sync Status Indicator
        function setSyncStatus(status, text) {
            const indicator = document.getElementById('syncIndicator');
            const textEl = document.getElementById('syncText');

            indicator.className = `sync-indicator ${status}`;
            textEl.textContent = text;
        }

        // Edit Modal Functions
        let currentEditingPlanting = null;

        function openEditModal(id) {
            const planting = plantings.find(p => p.id === id);
            if (!planting) return;

            currentEditingPlanting = planting;

            // Populate form fields
            document.getElementById('editBatchId').value = planting.id;
            document.getElementById('editCrop').value = planting.crop || '';
            document.getElementById('editVariety').value = planting.variety || '';
            document.getElementById('editField').value = planting.field || '';
            document.getElementById('editBed').value = planting.bedNum || '';
            document.getElementById('editBedFeet').value = planting.bedFeet || '';
            document.getElementById('editDTM').value = planting.dtm || planting.DTM || planting.daysToMaturity || '';
            document.getElementById('editHarvestWindow').value = planting.harvestWindow || '';
            document.getElementById('editNotes').value = planting.notes || '';

            // Format dates for date inputs (YYYY-MM-DD)
            const formatForInput = (dateStr) => {
                if (!dateStr) return '';
                try {
                    const date = new Date(dateStr);
                    if (isNaN(date.getTime())) return '';
                    return date.toISOString().split('T')[0];
                } catch (e) {
                    return '';
                }
            };

            const formatDisplay = (dateStr) => {
                if (!dateStr) return '--';
                try {
                    const date = new Date(dateStr);
                    if (isNaN(date.getTime())) return '--';
                    return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                } catch (e) {
                    return '--';
                }
            };

            // Determine planting method
            const method = planting.method || planting.plantingMethod ||
                          (planting.planGHSow || planting.seedDate ? 'Transplant' : 'Direct Seed');

            if (method === 'Direct Seed') {
                document.getElementById('methodDirect').checked = true;
            } else {
                document.getElementById('methodTransplant').checked = true;
            }
            updateMethodFields();

            // Populate dates
            document.getElementById('editGHSow').value = formatForInput(planting.planGHSow || planting.seedDate);
            document.getElementById('editTransplant').value = formatForInput(planting.planTransplant || planting.fieldStartDate);
            document.getElementById('editFieldSow').value = formatForInput(planting.fieldSow || planting.planTransplant || planting.fieldStartDate);
            document.getElementById('editFirstHarvest').value = formatForInput(planting.firstHarvest);
            document.getElementById('editLastHarvest').value = formatForInput(planting.harvestDate || planting.lastHarvest);

            // Update modal header info
            const icon = cropIcons[planting.crop] || 'ðŸŒ±';
            document.getElementById('editModalIcon').textContent = icon;
            document.getElementById('editModalCropName').textContent = `${planting.crop || 'Unknown Crop'} - ${planting.variety || 'Unknown Variety'}`;
            document.getElementById('editModalBatchId').textContent = `Batch ID: ${planting.id}`;

            // Build current schedule display
            let scheduleHTML = '';
            const ghSow = planting.planGHSow || planting.seedDate;
            const transplant = planting.planTransplant || planting.fieldStartDate;
            const firstHarvest = planting.firstHarvest;
            const lastHarvest = planting.harvestDate || planting.lastHarvest;

            if (method === 'Transplant' || ghSow) {
                scheduleHTML += `<div style="display: flex; gap: 2rem; flex-wrap: wrap;">`;
                scheduleHTML += `<span><strong>GH Sow:</strong> ${formatDisplay(ghSow)}</span>`;
                scheduleHTML += `<span><strong>Transplant:</strong> ${formatDisplay(transplant)}</span>`;
                scheduleHTML += `<span><strong>First Harvest:</strong> ${formatDisplay(firstHarvest)}</span>`;
                scheduleHTML += `<span><strong>Last Harvest:</strong> ${formatDisplay(lastHarvest)}</span>`;
                scheduleHTML += `</div>`;
            } else {
                scheduleHTML += `<div style="display: flex; gap: 2rem; flex-wrap: wrap;">`;
                scheduleHTML += `<span><strong>Field Sow:</strong> ${formatDisplay(transplant)}</span>`;
                scheduleHTML += `<span><strong>First Harvest:</strong> ${formatDisplay(firstHarvest)}</span>`;
                scheduleHTML += `<span><strong>Last Harvest:</strong> ${formatDisplay(lastHarvest)}</span>`;
                scheduleHTML += `</div>`;
            }
            scheduleHTML += `<div style="margin-top: 0.5rem; color: var(--text-secondary);"><strong>Location:</strong> Field ${planting.field || '--'}${planting.bed ? ` / Bed ${planting.bed}` : ''} | <strong>Bed Feet:</strong> ${planting.bedFeet || '--'}</div>`;

            document.getElementById('editCurrentSchedule').innerHTML = scheduleHTML;

            // Show modal
            document.getElementById('editModal').classList.add('active');
        }

        function updateMethodFields() {
            const isTransplant = document.getElementById('methodTransplant').checked;
            const transplantDates = document.getElementById('transplantDates');
            const directSeedDates = document.getElementById('directSeedDates');

            if (isTransplant) {
                transplantDates.style.display = 'block';
                directSeedDates.style.display = 'none';
                document.getElementById('methodTransplantLabel').style.border = '2px solid var(--primary)';
                document.getElementById('methodDirectLabel').style.border = '2px solid transparent';
            } else {
                transplantDates.style.display = 'none';
                directSeedDates.style.display = 'block';
                document.getElementById('methodDirectLabel').style.border = '2px solid var(--primary)';
                document.getElementById('methodTransplantLabel').style.border = '2px solid transparent';
            }
        }

        function closeEditModal() {
            document.getElementById('editModal').classList.remove('active');
            currentEditingPlanting = null;
        }

        async function saveEditModal() {
            if (!currentEditingPlanting) return;

            const saveBtn = document.getElementById('editSaveBtn');
            saveBtn.disabled = true;
            saveBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Saving...';

            try {
                const isTransplant = document.getElementById('methodTransplant').checked;
                const plantingMethod = isTransplant ? 'Transplant' : 'Direct Seed';

                // Construct Target_Bed_ID from field and bed number
                const fieldVal = document.getElementById('editField').value;
                const bedNum = document.getElementById('editBed').value;
                const targetBedId = fieldVal ? `Field ${fieldVal}-${bedNum || '01'}` : '';

                const updateData = {
                    action: 'updatePlanting',
                    id: document.getElementById('editBatchId').value,
                    Crop: document.getElementById('editCrop').value,
                    Variety: document.getElementById('editVariety').value,
                    Target_Bed_ID: targetBedId,
                    Feet_Used: document.getElementById('editBedFeet').value,
                    Planting_Method: plantingMethod,
                    Notes: document.getElementById('editNotes').value
                };

                // Add dates with proper formatting based on planting method
                const firstHarvest = document.getElementById('editFirstHarvest').value;
                const lastHarvest = document.getElementById('editLastHarvest').value;

                if (isTransplant) {
                    const ghSow = document.getElementById('editGHSow').value;
                    const transplant = document.getElementById('editTransplant').value;
                    if (ghSow) updateData.Plan_GH_Sow = formatDateForSheet(ghSow);
                    if (transplant) updateData.Plan_Transplant = formatDateForSheet(transplant);
                } else {
                    const fieldSow = document.getElementById('editFieldSow').value;
                    if (fieldSow) updateData.Plan_Transplant = formatDateForSheet(fieldSow);
                    // Clear GH Sow for direct seed
                    updateData.Plan_GH_Sow = '';
                }

                if (firstHarvest) updateData.First_Harvest = formatDateForSheet(firstHarvest);
                if (lastHarvest) updateData.Last_Harvest = formatDateForSheet(lastHarvest);

                // Use GET with URL parameters to avoid CORS preflight issues
                const params = new URLSearchParams(updateData);
                const response = await fetch(`${API_URL}?${params.toString()}`, {
                    method: 'GET',
                    redirect: 'follow'
                });

                const result = await response.json();

                if (result.success) {
                    // Update local data
                    currentEditingPlanting.crop = updateData.Crop;
                    currentEditingPlanting.variety = updateData.Variety;
                    currentEditingPlanting.field = fieldVal;
                    currentEditingPlanting.bedNum = bedNum;
                    currentEditingPlanting.bed = targetBedId;
                    currentEditingPlanting.bedFeet = parseInt(updateData.Feet_Used) || 0;
                    currentEditingPlanting.plantingMethod = plantingMethod;
                    currentEditingPlanting.notes = updateData.Notes;

                    if (isTransplant) {
                        const ghSow = document.getElementById('editGHSow').value;
                        const transplant = document.getElementById('editTransplant').value;
                        if (ghSow) currentEditingPlanting.planGHSow = ghSow;
                        if (transplant) {
                            currentEditingPlanting.planTransplant = transplant;
                            currentEditingPlanting.fieldStartDate = transplant;
                        }
                    } else {
                        const fieldSow = document.getElementById('editFieldSow').value;
                        if (fieldSow) {
                            currentEditingPlanting.planTransplant = fieldSow;
                            currentEditingPlanting.fieldStartDate = fieldSow;
                        }
                        currentEditingPlanting.planGHSow = null;
                    }

                    if (firstHarvest) currentEditingPlanting.firstHarvest = firstHarvest;
                    if (lastHarvest) currentEditingPlanting.harvestDate = lastHarvest;

                    closeEditModal();
                    applyFilters();
                    showToast('Planting updated successfully!', 'success');
                } else {
                    showToast('Failed to update: ' + (result.error || 'Unknown error'), 'error');
                }
            } catch (error) {
                console.error('Error saving planting:', error);
                showToast('Error saving planting: ' + error.message, 'error');
            } finally {
                saveBtn.disabled = false;
                saveBtn.innerHTML = '<i class="fas fa-save"></i> Save Changes';
            }
        }

        // Close modal on overlay click
        document.getElementById('editModal').addEventListener('click', function(e) {
            if (e.target === this) closeEditModal();
        });

        // Close modal on Escape key
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') closeEditModal();
        });

        // Tooltip
        function showTooltip(event, id) {
            const planting = plantings.find(p => p.id === id);
            if (!planting) return;

            const tooltip = document.getElementById('tooltip');
            const icon = cropIcons[planting.crop] || 'ðŸŒ±';

            document.getElementById('tooltipIcon').textContent = icon;
            document.getElementById('tooltipTitle').textContent = planting.crop;
            document.getElementById('tooltipVariety').textContent = planting.variety;
            document.getElementById('tooltipBatchId').textContent = planting.id;
            document.getElementById('tooltipBed').textContent = planting.bed;
            document.getElementById('tooltipMethod').textContent = planting.plantingMethod || 'Transplant';

            // GH Sow date (hide row if not applicable)
            const ghRow = document.getElementById('tooltipGHRow');
            if (planting.planGHSow && planting.plantingMethod !== 'Direct Seed') {
                ghRow.style.display = 'flex';
                document.getElementById('tooltipGHSow').textContent = formatDisplayDate(planting.planGHSow);
            } else {
                ghRow.style.display = 'none';
            }

            document.getElementById('tooltipStart').textContent = formatDisplayDate(planting.fieldStartDate || planting.seedDate);
            document.getElementById('tooltipEnd').textContent = formatDisplayDate(planting.harvestDate);
            document.getElementById('tooltipDuration').textContent = `${planting.dtm} days`;
            document.getElementById('tooltipBedFeet').textContent = `${planting.bedFeet} ft`;
            document.getElementById('tooltipStatus').textContent = planting.status.charAt(0).toUpperCase() + planting.status.slice(1);

            // Lock status
            const lockRow = document.getElementById('tooltipLockRow');
            const actions = document.getElementById('tooltipActions');
            if (planting.isLocked) {
                lockRow.style.display = 'flex';
                document.getElementById('tooltipLockReason').textContent = planting.lockReason;
                actions.textContent = 'Locked - Confirm termination to edit';
                actions.style.color = '#e63946';
            } else {
                lockRow.style.display = 'none';
                actions.textContent = 'Drag to move | Resize edges to adjust dates';
                actions.style.color = 'var(--text-secondary)';
            }

            tooltip.style.left = (event.pageX + 15) + 'px';
            tooltip.style.top = (event.pageY + 15) + 'px';
            tooltip.classList.add('show');
        }

        function hideTooltip() {
            document.getElementById('tooltip').classList.remove('show');
        }

        function formatDisplayDate(dateStr) {
            const date = new Date(dateStr);
            return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
        }

        // Refresh Data
        async function refreshData() {
            showToast('Refreshing data...', 'warning');
            await loadPlantings();
            showToast('Data refreshed', 'success');
        }

        // Toast
        function showToast(message, type = 'success') {
            const toast = document.getElementById('toast');
            const icon = toast.querySelector('i');

            toast.className = `toast ${type}`;
            icon.className = type === 'success' ? 'fas fa-check-circle' :
                            type === 'error' ? 'fas fa-exclamation-circle' :
                            'fas fa-sync-alt';

            document.getElementById('toastMessage').textContent = message;
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), 3000);
        }

        // ========================================
        // ADD PLANTING MODAL
        // ========================================
        let addNurseryDays = 21;
        let addDTM = 60;
        let addRows = 3;
        let addSpacing = 6;

        function openAddPlantingModal(presetDate = null) {
            // Populate crop dropdown
            const cropSelect = document.getElementById('addCrop');
            const uniqueCrops = [...new Set(cropProfiles.map(p => p.Crop))].sort();
            cropSelect.innerHTML = '<option value="">Select crop...</option>' +
                uniqueCrops.map(c => `<option value="${c}">${c}</option>`).join('') +
                '<option value="__add_new__">+ Add New Crop...</option>';

            // Reset form
            document.getElementById('addVariety').innerHTML = '<option value="">Select variety...</option>';
            document.getElementById('addNewCrop').style.display = 'none';
            document.getElementById('addNewVariety').style.display = 'none';
            document.getElementById('addMethod').value = 'Transplant';
            document.getElementById('addTraySize').value = '128';
            document.getElementById('addFeet').value = '100';
            document.getElementById('addBed').value = '';
            document.getElementById('addDateType').value = 'transplant';
            document.getElementById('addDate').value = presetDate || new Date().toISOString().split('T')[0];
            document.getElementById('addSuccessionCheck').checked = false;
            document.getElementById('addSuccessionOptions').style.display = 'none';

            updateAddPlantingSummary();

            // Show modal
            document.getElementById('addPlantingModal').classList.add('active');
        }

        function closeAddPlantingModal() {
            document.getElementById('addPlantingModal').classList.remove('active');
        }

        function onAddCropChange() {
            const crop = document.getElementById('addCrop').value;
            const varietySelect = document.getElementById('addVariety');
            const newCropInput = document.getElementById('addNewCrop');
            const newVarietyInput = document.getElementById('addNewVariety');

            if (crop === '__add_new__') {
                newCropInput.style.display = 'block';
                newCropInput.focus();
                varietySelect.innerHTML = '<option value="">Select variety...</option>' +
                    '<option value="__add_new__">+ Add New Variety...</option>';
                newVarietyInput.style.display = 'none';
                return;
            } else {
                newCropInput.style.display = 'none';
                newCropInput.value = '';
            }

            const varieties = cropProfiles
                .filter(p => p.Crop === crop)
                .map(p => p.Variety)
                .filter(v => v);
            const uniqueVarieties = [...new Set(varieties)];

            varietySelect.innerHTML = '<option value="">Select variety...</option>' +
                uniqueVarieties.map(v => `<option value="${v}">${v}</option>`).join('') +
                '<option value="__add_new__">+ Add New Variety...</option>';

            if (uniqueVarieties.length > 0) {
                varietySelect.value = uniqueVarieties[0];
                onAddVarietyChange();
            }
        }

        function onAddVarietyChange() {
            const crop = document.getElementById('addCrop').value;
            const variety = document.getElementById('addVariety').value;
            const newVarietyInput = document.getElementById('addNewVariety');

            if (variety === '__add_new__') {
                newVarietyInput.style.display = 'block';
                newVarietyInput.focus();
                // Set defaults for new variety
                document.getElementById('addMethod').value = 'Transplant';
                document.getElementById('addTraySize').value = '128';
                addNurseryDays = 21;
                addDTM = 60;
                addRows = 3;
                addSpacing = 6;
                return;
            } else {
                newVarietyInput.style.display = 'none';
                newVarietyInput.value = '';
            }

            const profile = cropProfiles.find(p => p.Crop === crop && p.Variety === variety) ||
                           cropProfiles.find(p => p.Crop === crop);

            if (profile) {
                document.getElementById('addMethod').value = profile.Planting_Method || 'Transplant';
                document.getElementById('addTraySize').value = profile.Tray_Cell_Count || '128';
                addNurseryDays = profile.Nursery_Days || 21;
                addDTM = profile.DTM || 60;
                addRows = profile.Rows_Per_Bed || 3;
                addSpacing = profile.Spacing || 6;
            }

            updateAddPlantingSummary();
        }

        function toggleAddSuccession() {
            const checked = document.getElementById('addSuccessionCheck').checked;
            document.getElementById('addSuccessionOptions').style.display = checked ? 'block' : 'none';
            updateAddPlantingSummary();
        }

        function updateAddPlantingSummary() {
            const crop = document.getElementById('addCrop').value;
            const variety = document.getElementById('addVariety').value;
            const feet = parseInt(document.getElementById('addFeet').value) || 100;
            const succession = document.getElementById('addSuccessionCheck').checked;
            const count = succession ? parseInt(document.getElementById('addSuccessionCount').value) || 1 : 1;

            if (!crop || crop === '__add_new__') {
                document.getElementById('addPlantingSummary').innerHTML =
                    '<strong>Summary:</strong> Select a crop to see planting summary';
                return;
            }

            const totalFeet = feet * count;
            const plantsPerFoot = addRows * (12 / addSpacing);
            const totalPlants = Math.ceil(totalFeet * plantsPerFoot);
            const traySize = parseInt(document.getElementById('addTraySize').value) || 128;
            const traysNeeded = Math.ceil(totalPlants / traySize);

            document.getElementById('addPlantingSummary').innerHTML = `
                <strong>Summary:</strong> ${count} planting${count > 1 ? 's' : ''} Ã— ${feet} ft = ${totalFeet} total ft<br>
                <span style="color: var(--text-secondary);">
                    Plants: ~${totalPlants.toLocaleString()} | Trays: ${traysNeeded} |
                    Nursery: ${addNurseryDays} days | DTM: ${addDTM} days
                </span>
            `;
        }

        async function saveAddPlanting() {
            let crop = document.getElementById('addCrop').value;
            let variety = document.getElementById('addVariety').value;
            const method = document.getElementById('addMethod').value;
            const traySize = document.getElementById('addTraySize').value;
            const feet = document.getElementById('addFeet').value;
            const bed = document.getElementById('addBed').value;
            const dateType = document.getElementById('addDateType').value;
            const targetDate = document.getElementById('addDate').value;

            // Handle new crop/variety
            const isNewCrop = crop === '__add_new__';
            const isNewVariety = variety === '__add_new__';

            if (isNewCrop) {
                crop = document.getElementById('addNewCrop').value.trim();
                if (!crop) {
                    showToast('Please enter a crop name', 'error');
                    return;
                }
            }

            if (isNewVariety) {
                variety = document.getElementById('addNewVariety').value.trim();
                if (!variety) {
                    showToast('Please enter a variety name', 'error');
                    return;
                }
            }

            if (!crop || !targetDate) {
                showToast('Please select crop and date', 'error');
                return;
            }

            const successionEnabled = document.getElementById('addSuccessionCheck').checked;
            const successionCount = successionEnabled ? parseInt(document.getElementById('addSuccessionCount').value) : 1;
            const interval = parseInt(document.getElementById('addInterval').value) || 7;
            const intervalUnit = document.getElementById('addIntervalUnit').value;
            const intervalDays = intervalUnit === 'weeks' ? interval * 7 : interval;

            try {
                // Create new crop profile if adding new crop or variety
                if (isNewCrop || isNewVariety) {
                    const profileParams = new URLSearchParams({
                        action: 'createCropProfile',
                        crop: crop,
                        variety: variety || 'Standard',
                        plantingMethod: method,
                        trayCellCount: traySize,
                        nurseryDays: addNurseryDays,
                        dtm: addDTM,
                        rowsPerBed: addRows,
                        spacing: addSpacing
                    });

                    const profileResponse = await fetch(`${API_URL}?${profileParams}`);
                    const profileResult = await profileResponse.json();

                    if (profileResult.success) {
                        showToast(`New ${isNewCrop ? 'crop' : 'variety'} added!`, 'success');
                    }
                }

                // Save plantings
                for (let i = 0; i < successionCount; i++) {
                    const offsetDays = i * intervalDays;
                    const plantingDate = new Date(targetDate);
                    plantingDate.setDate(plantingDate.getDate() + offsetDays);

                    const params = new URLSearchParams({
                        action: 'savePlanting',
                        crop: crop,
                        variety: variety || 'Standard',
                        method: method,
                        traySize: traySize,
                        feet: feet,
                        Target_Bed_ID: bed,
                        dateType: dateType,
                        targetDate: plantingDate.toISOString().split('T')[0],
                        nurseryDays: addNurseryDays,
                        dtm: addDTM,
                        rows: addRows,
                        spacing: addSpacing
                    });

                    await fetch(`${API_URL}?${params}`);
                }

                showToast(`${successionCount} planting(s) added!`, 'success');
                closeAddPlantingModal();

                // Refresh calendar
                await loadPlantings();

            } catch (error) {
                console.error('Error saving planting:', error);
                showToast('Error saving planting', 'error');
            }
        }

        // Close add modal on overlay click
        document.getElementById('addPlantingModal').addEventListener('click', function(e) {
            if (e.target === this) closeAddPlantingModal();
        });

        // Close add modal on Escape key
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                closeAddPlantingModal();
                closeEditModal();
            }
        });
    </script>
</body>
</html>
