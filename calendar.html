<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visual Calendar - Tiny Seed OS</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/interactjs/dist/interact.min.js"></script>
    <script src="web_app/auth-guard.js" data-required-role="Employee"></script>
    <style>
        :root {
            --primary: #2d5a27;
            --primary-light: #4a7c43;
            --primary-dark: #1e3d1a;
            --secondary: #f4a261;
            --accent: #e76f51;
            --success: #2a9d8f;
            --warning: #e9c46a;
            --danger: #e63946;
            --bg-dark: #1a1a2e;
            --bg-card: #16213e;
            --bg-light: #0f3460;
            --text-primary: #edf2f4;
            --text-secondary: #8d99ae;
            --border: rgba(255,255,255,0.1);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, var(--bg-dark) 0%, #0f0f1a 100%);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
        }

        .header {
            background: rgba(22, 33, 62, 0.95);
            backdrop-filter: blur(20px);
            border-bottom: 1px solid var(--border);
            padding: 1rem 2rem;
            padding-left: 300px; /* Account for sidebar width (280px) + some padding */
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1000;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .back-btn {
            background: var(--bg-light);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 10px 15px;
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.3s;
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .back-btn:hover {
            background: var(--primary);
            border-color: var(--primary);
        }

        .page-title {
            font-size: 1.5rem;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .page-title i { color: #3498db; }

        .header-controls {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .zoom-controls {
            display: flex;
            background: var(--bg-light);
            border-radius: 10px;
            overflow: hidden;
        }

        .zoom-btn {
            background: none;
            border: none;
            padding: 8px 12px;
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 500;
            font-size: 0.85rem;
            white-space: nowrap;
        }

        .zoom-btn:hover, .zoom-btn.active {
            background: var(--primary);
        }

        .sync-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            background: var(--bg-light);
            border-radius: 10px;
            font-size: 0.85rem;
        }

        .sync-indicator.syncing {
            color: var(--warning);
        }

        .sync-indicator.synced {
            color: var(--success);
        }

        .sync-indicator.error {
            color: var(--danger);
        }

        .sync-indicator.pending {
            color: var(--secondary);
        }

        .sync-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: currentColor;
        }

        .sync-indicator.syncing .sync-dot {
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        .submit-changes-btn {
            display: none;
            padding: 10px 20px;
            background: var(--secondary);
            color: var(--bg-dark);
            border: none;
            border-radius: 10px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            gap: 8px;
            align-items: center;
        }

        .submit-changes-btn.visible {
            display: flex;
        }

        .submit-changes-btn:hover {
            background: var(--accent);
            transform: translateY(-2px);
        }

        .submit-changes-btn .badge {
            background: var(--bg-dark);
            color: var(--secondary);
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.8rem;
        }

        .discard-btn {
            display: none;
            padding: 8px 12px;
            background: transparent;
            color: var(--text-secondary);
            border: 1px solid var(--border);
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.3s;
        }

        .discard-btn.visible {
            display: flex;
        }

        .discard-btn:hover {
            color: var(--danger);
            border-color: var(--danger);
        }

        .main-container {
            padding: 80px 0 0;
            min-height: 100vh;
        }

        /* Sidebar */
        .sidebar {
            position: fixed;
            top: 80px;
            left: 0;
            width: 280px;
            height: calc(100vh - 80px);
            background: var(--bg-card);
            border-right: 1px solid var(--border);
            padding: 1.5rem;
            overflow-y: auto;
            z-index: 100;
        }

        .sidebar-section {
            margin-bottom: 1.5rem;
        }

        .sidebar-title {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 1rem;
        }

        .filter-group {
            margin-bottom: 1rem;
        }

        .filter-group label {
            display: block;
            font-size: 0.85rem;
            margin-bottom: 6px;
            color: var(--text-secondary);
        }

        .filter-control {
            width: 100%;
            padding: 10px 14px;
            background: var(--bg-light);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 0.9rem;
        }

        .filter-control:focus {
            outline: none;
            border-color: var(--primary);
        }

        /* Unassigned Plantings Right Sidebar - Gantt-Style Timeline */
        .unassigned-panel {
            position: fixed;
            top: 80px;
            right: 0;
            width: 520px;
            height: calc(100vh - 80px);
            background: var(--bg-card);
            border-left: 1px solid var(--border);
            padding: 0;
            overflow-y: auto;
            overflow-x: hidden;
            z-index: 100;
            transform: translateX(100%);
            transition: transform 0.3s ease;
        }

        .unassigned-panel.open {
            transform: translateX(0);
        }

        .unassigned-toggle {
            position: fixed;
            top: 50%;
            right: 0;
            transform: translateY(-50%);
            background: var(--primary);
            color: white;
            border: none;
            padding: 15px 8px;
            border-radius: 8px 0 0 8px;
            cursor: pointer;
            z-index: 101;
            writing-mode: vertical-rl;
            text-orientation: mixed;
            font-size: 0.8rem;
            font-weight: 600;
            transition: all 0.3s;
        }

        .unassigned-toggle:hover {
            background: var(--primary-light);
            padding-right: 12px;
        }

        .unassigned-toggle.open {
            right: 520px;
        }

        .unassigned-toggle .badge {
            background: var(--danger);
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            margin-bottom: 8px;
            writing-mode: horizontal-tb;
        }

        .unassigned-header {
            position: sticky;
            top: 0;
            background: var(--bg-card);
            padding: 1rem;
            border-bottom: 1px solid var(--border);
            z-index: 10;
        }

        .unassigned-header h3 {
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .unassigned-header h3 i { color: var(--warning); }

        .unassigned-count {
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        .unassigned-search {
            width: 100%;
            padding: 8px 12px;
            background: var(--bg-light);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-primary);
            margin-top: 0.75rem;
            font-size: 0.85rem;
        }

        .crop-group {
            border-bottom: 1px solid var(--border);
        }

        .crop-group-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            cursor: pointer;
            background: rgba(255,255,255,0.02);
            transition: background 0.2s;
        }

        .crop-group-header:hover {
            background: rgba(255,255,255,0.05);
        }

        .crop-group-title {
            font-weight: 600;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .crop-group-title .crop-color {
            width: 12px;
            height: 12px;
            border-radius: 3px;
        }

        .crop-group-count {
            background: var(--bg-light);
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        .crop-group-items {
            display: none;
            padding: 4px 8px 8px;
            background: rgba(0,0,0,0.2);
        }

        .crop-group.expanded .crop-group-items {
            display: block;
        }

        /* Mini Timeline Header */
        .unassigned-timeline-header {
            display: flex;
            padding: 0 8px;
            margin-bottom: 4px;
            margin-left: 100px;
            font-size: 0.65rem;
            color: var(--text-secondary);
        }

        .unassigned-timeline-header span {
            flex: 1;
            text-align: center;
            border-left: 1px solid var(--border);
            padding: 2px 0;
        }

        /* Gantt-style planting item */
        .unassigned-item {
            display: flex;
            align-items: center;
            background: transparent;
            border: none;
            padding: 4px 0;
            margin-bottom: 2px;
            cursor: grab;
            transition: all 0.2s;
            min-height: 28px;
        }

        .unassigned-item:hover {
            background: rgba(255,255,255,0.03);
        }

        .unassigned-item:active {
            cursor: grabbing;
        }

        .unassigned-item.dragging {
            opacity: 0.5;
        }

        .unassigned-item-label {
            width: 100px;
            flex-shrink: 0;
            font-size: 0.75rem;
            padding-right: 8px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .unassigned-item-label .variety-name {
            font-weight: 500;
        }

        .unassigned-item-label .item-meta {
            font-size: 0.65rem;
            color: var(--text-secondary);
        }

        .unassigned-item-timeline {
            flex: 1;
            position: relative;
            height: 24px;
            background: rgba(255,255,255,0.02);
            border-radius: 3px;
        }

        .unassigned-item-bar {
            position: absolute;
            height: 20px;
            top: 2px;
            border-radius: 4px;
            cursor: grab;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.65rem;
            color: white;
            font-weight: 500;
            min-width: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            transition: transform 0.15s, box-shadow 0.15s;
        }

        .unassigned-item-bar:hover {
            transform: scale(1.02);
            box-shadow: 0 3px 8px rgba(0,0,0,0.4);
            z-index: 5;
        }

        .unassigned-item-bar.urgent {
            animation: pulse-urgent 2s infinite;
        }

        @keyframes pulse-urgent {
            0%, 100% { box-shadow: 0 2px 4px rgba(0,0,0,0.3); }
            50% { box-shadow: 0 2px 12px rgba(233, 196, 106, 0.6); }
        }

        .unassigned-item-bar .bar-label {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            padding: 0 4px;
        }

        .unassigned-item-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 6px;
        }

        .unassigned-item-variety {
            font-weight: 500;
            font-size: 0.85rem;
        }

        .unassigned-item-id {
            font-size: 0.7rem;
            color: var(--text-secondary);
            font-family: monospace;
        }

        .unassigned-item-details {
            font-size: 0.75rem;
            color: var(--text-secondary);
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }

        .unassigned-item-details span {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .unassigned-item-warning {
            color: var(--warning);
            font-size: 0.75rem;
            margin-top: 6px;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .drop-zone-highlight {
            background: rgba(45, 90, 39, 0.3) !important;
            border: 2px dashed var(--primary) !important;
        }

        .checkbox-filters {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .checkbox-filter {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 12px;
            background: var(--bg-light);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .checkbox-filter:hover {
            background: var(--primary);
        }

        .checkbox-filter input {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
        }

        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        .status-dot.seeding { background: #8e44ad; }
        .status-dot.growing { background: var(--success); }
        .status-dot.harvest { background: var(--secondary); }
        .status-dot.completed { background: var(--text-secondary); }

        .legend {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 0.85rem;
        }

        .legend-color {
            width: 24px;
            height: 12px;
            border-radius: 4px;
        }

        /* Gantt Container - Main layout wrapper */
        .gantt-container {
            margin-left: 280px;
            padding: 1.5rem;
            padding-top: 0.5rem;
            position: relative;
            height: calc(100vh - 80px);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .gantt-wrapper {
            flex: 1;
            background: var(--bg-card);
            border-radius: 16px;
            border: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            min-height: 0;
        }

        /* The gantt-chart uses CSS Grid for sticky headers */
        .gantt-chart {
            flex: 1;
            display: grid;
            grid-template-columns: 200px 1fr;
            grid-template-rows: auto 1fr;
            min-height: 0;
            overflow: hidden;
        }

        /* Corner cell - top left, always visible */
        .gantt-corner {
            grid-row: 1;
            grid-column: 1;
            background: var(--bg-light);
            border-right: 2px solid var(--border);
            border-bottom: 2px solid var(--border);
            padding: 1rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
            z-index: 30;
        }

        /* Header row - scrolls horizontally only */
        .gantt-header-scroll {
            grid-row: 1;
            grid-column: 2;
            overflow-x: hidden;
            overflow-y: hidden;
            border-bottom: 2px solid var(--border);
            background: var(--bg-card);
            z-index: 20;
        }

        .gantt-header-inner {
            display: flex;
            flex-direction: column;
        }

        /* Labels column - scrolls vertically only */
        .gantt-labels-scroll {
            grid-row: 2;
            grid-column: 1;
            overflow-x: hidden;
            overflow-y: hidden;
            border-right: 2px solid var(--border);
            background: var(--bg-card);
            z-index: 20;
        }

        /* Main content - scrolls both ways */
        .gantt-content-scroll {
            grid-row: 2;
            grid-column: 2;
            overflow: auto;
            position: relative;
        }

        .gantt-content-inner {
            position: relative;
        }

        /* Field label in the labels column */
        .gantt-label {
            padding: 1rem;
            border-bottom: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            justify-content: center;
            background: var(--bg-card);
        }

        .gantt-label:nth-child(even) {
            background: #1a1a2e;
        }

        /* Timeline row in the content area */
        .gantt-row {
            position: relative;
            border-bottom: 1px solid var(--border);
        }

        .gantt-row:nth-child(even) {
            background: rgba(0, 0, 0, 0.1);
        }

        .gantt-body {
            position: relative;
        }

        /* Gap indicator styles for empty field space */
        .field-gap {
            position: absolute;
            height: calc(100% - 16px);
            top: 8px;
            background: repeating-linear-gradient(
                45deg,
                transparent,
                transparent 8px,
                rgba(46, 204, 113, 0.08) 8px,
                rgba(46, 204, 113, 0.08) 16px
            );
            border: 1px dashed rgba(46, 204, 113, 0.3);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            z-index: 1;
        }

        .field-gap:hover {
            background: repeating-linear-gradient(
                45deg,
                transparent,
                transparent 8px,
                rgba(46, 204, 113, 0.2) 8px,
                rgba(46, 204, 113, 0.2) 16px
            );
            border-color: rgba(46, 204, 113, 0.6);
            box-shadow: 0 0 15px rgba(46, 204, 113, 0.2);
        }

        .field-gap::after {
            content: '+';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.5rem;
            color: rgba(46, 204, 113, 0.4);
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .field-gap:hover::after {
            opacity: 1;
        }

        /* Gap tooltip */
        .gap-tooltip {
            position: fixed;
            background: var(--bg-card);
            border: 1px solid var(--primary);
            border-radius: 12px;
            padding: 1rem;
            z-index: 1000;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            min-width: 200px;
        }

        .gap-tooltip.visible {
            opacity: 1;
        }

        .gap-tooltip-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid var(--border);
        }

        .gap-tooltip-title {
            font-weight: 700;
            color: var(--primary-light);
        }

        .gap-tooltip-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 6px;
            font-size: 0.9rem;
        }

        .gap-tooltip-label {
            color: var(--text-secondary);
        }

        .gap-tooltip-value {
            font-weight: 600;
            color: var(--text-primary);
        }

        .gap-tooltip-hint {
            margin-top: 10px;
            padding-top: 8px;
            border-top: 1px solid var(--border);
            font-size: 0.8rem;
            color: var(--text-secondary);
            text-align: center;
        }

        /* Edit Modal Styles */
        .edit-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
        }

        .edit-modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .edit-modal {
            background: var(--bg-card);
            border-radius: 16px;
            border: 1px solid var(--border);
            width: 90%;
            max-width: 600px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        }

        .edit-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1.5rem;
            border-bottom: 1px solid var(--border);
            background: var(--bg-light);
            border-radius: 16px 16px 0 0;
        }

        .edit-modal-title {
            font-size: 1.25rem;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .edit-modal-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 5px;
            transition: color 0.2s;
        }

        .edit-modal-close:hover {
            color: var(--danger);
        }

        .edit-modal-body {
            padding: 1.5rem;
        }

        .edit-form-group {
            margin-bottom: 1.25rem;
        }

        .edit-form-label {
            display: block;
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 6px;
        }

        .edit-form-input {
            width: 100%;
            padding: 10px 14px;
            background: var(--bg-light);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 0.95rem;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .edit-form-input:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(46, 204, 113, 0.2);
        }

        .edit-form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
        }

        .edit-modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 1rem;
            padding: 1.5rem;
            border-top: 1px solid var(--border);
            background: var(--bg-light);
            border-radius: 0 0 16px 16px;
        }

        .edit-btn {
            padding: 10px 24px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .edit-btn-cancel {
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text-secondary);
        }

        .edit-btn-cancel:hover {
            background: var(--bg-card);
            color: var(--text-primary);
        }

        .edit-btn-save {
            background: var(--primary);
            border: none;
            color: white;
        }

        .edit-btn-save:hover {
            background: var(--primary-light);
            transform: translateY(-1px);
        }

        .edit-btn-save:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        /* Stats Bar */
        .stats-bar {
            display: flex;
            gap: 2rem;
            padding: 1rem 1.5rem;
            background: var(--bg-light);
            border-bottom: 1px solid var(--border);
            flex-wrap: wrap;
        }

        .stat-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .stat-value {
            font-size: 1.25rem;
            font-weight: 700;
            color: var(--primary-light);
        }

        .stat-label {
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        /* STICKY DATE HEADER - Sticks to top when scrolling vertically */
        .gantt-header {
            display: flex;
            border-bottom: 2px solid var(--border);
            position: sticky;
            top: 0;
            background: var(--bg-card);
            z-index: 100;
        }

        /* CORNER CELL - Sticks both left AND top */
        .gantt-field-header {
            width: 180px;
            min-width: 180px;
            padding: 1rem;
            background: var(--bg-light);
            border-right: 2px solid var(--border);
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
            position: sticky;
            left: 0;
            z-index: 110;
            box-shadow: 2px 2px 10px rgba(0,0,0,0.4);
        }

        .gantt-timeline-header {
            display: flex;
            flex-direction: column;
        }

        .gantt-months-row {
            display: flex;
            border-bottom: 1px solid var(--border);
        }

        .gantt-month {
            text-align: center;
            padding: 8px;
            font-weight: 600;
            font-size: 0.9rem;
            background: var(--bg-light);
            border-right: 1px solid var(--border);
            flex-shrink: 0;
        }

        .gantt-days-row {
            display: flex;
        }

        .gantt-day {
            text-align: center;
            padding: 4px;
            font-size: 0.7rem;
            color: var(--text-secondary);
            border-right: 1px solid rgba(255,255,255,0.05);
            flex-shrink: 0;
        }

        .gantt-day.today {
            background: rgba(244, 162, 97, 0.3);
            color: var(--secondary);
            font-weight: 600;
        }

        .gantt-day.weekend {
            background: rgba(0,0,0,0.2);
        }

        /* Gantt Body - Field Rows */
        .field-row {
            display: flex;
            border-bottom: 1px solid var(--border);
            min-height: 80px;
            position: relative;
        }

        .field-row:nth-child(even) {
            background: rgba(0, 0, 0, 0.1);
        }

        /* STICKY FIELD LABEL - Sticks to left when scrolling horizontally */
        .field-label {
            width: 180px;
            min-width: 180px;
            padding: 1rem;
            border-right: 2px solid var(--border);
            background: var(--bg-card);
            display: flex;
            flex-direction: column;
            justify-content: center;
            position: sticky;
            left: 0;
            z-index: 50;
            box-shadow: 2px 0 10px rgba(0,0,0,0.3);
        }

        .field-row:nth-child(even) .field-label {
            background: #1a1a2e;
        }

        .field-name {
            font-weight: 700;
            font-size: 1rem;
            margin-bottom: 4px;
        }

        .field-meta {
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        .field-timeline {
            position: relative;
            min-height: 80px;
        }

        /* Grid lines */
        .timeline-grid {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            pointer-events: none;
        }

        .grid-line {
            border-right: 1px solid rgba(255,255,255,0.03);
            flex-shrink: 0;
        }

        .grid-line.week-start {
            border-right-color: rgba(255,255,255,0.08);
        }

        /* Today Line */
        .today-line {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background: var(--danger);
            z-index: 25;
            pointer-events: none;
        }

        .today-marker {
            position: absolute;
            top: -24px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--danger);
            color: white;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.65rem;
            font-weight: 700;
            white-space: nowrap;
        }

        /* Crop Bars */
        .crop-bar {
            position: absolute;
            height: 36px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            padding: 0 10px;
            font-size: 0.75rem;
            font-weight: 600;
            color: white;
            cursor: grab;
            transition: box-shadow 0.2s, transform 0.1s;
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            z-index: 20;
            touch-action: none;
            user-select: none;
        }

        .crop-bar:hover {
            box-shadow: 0 4px 16px rgba(0,0,0,0.4);
            z-index: 30;
        }

        .crop-bar.dragging {
            cursor: grabbing;
            box-shadow: 0 8px 30px rgba(0,0,0,0.5);
            z-index: 100;
            opacity: 0.9;
        }

        /* Ghost element showing original position */
        .crop-bar-ghost {
            position: absolute;
            opacity: 0.3;
            pointer-events: none;
            border: 2px dashed rgba(255,255,255,0.5);
            background: repeating-linear-gradient(
                45deg,
                transparent,
                transparent 5px,
                rgba(255,255,255,0.1) 5px,
                rgba(255,255,255,0.1) 10px
            );
            z-index: 5;
        }

        .crop-bar-ghost::after {
            content: 'Original';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 0.7rem;
            color: rgba(255,255,255,0.6);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* Moved indicator on actual bar */
        .crop-bar.moved {
            box-shadow: 0 0 0 2px var(--secondary), 0 4px 12px rgba(244, 162, 97, 0.4);
        }

        .crop-bar.moved::before {
            content: '‚ü≤';
            position: absolute;
            top: -8px;
            right: -8px;
            background: var(--secondary);
            color: var(--bg-dark);
            width: 18px;
            height: 18px;
            border-radius: 50%;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }

        /* Empty bed row styling */
        .gantt-row.empty-bed {
            background: rgba(255,255,255,0.02);
        }

        .gantt-label.empty-bed {
            opacity: 0.5;
        }

        .gantt-label.empty-bed .field-meta {
            font-style: italic;
        }

        .crop-bar.resizing {
            z-index: 100;
        }

        .crop-bar.seeding {
            background: linear-gradient(135deg, #8e44ad 0%, #9b59b6 100%);
        }

        .crop-bar.growing {
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-light) 100%);
        }

        .crop-bar.harvest {
            background: linear-gradient(135deg, var(--secondary) 0%, var(--accent) 100%);
        }

        .crop-bar.completed {
            background: linear-gradient(135deg, #555 0%, #777 100%);
            opacity: 0.7;
        }

        .crop-bar.locked {
            border: 2px solid #e63946;
            cursor: not-allowed;
        }

        .crop-bar.locked .resize-handle {
            display: none;
        }

        /* Drag Tooltip - Real-time date display */
        .drag-tooltip {
            position: fixed;
            background: rgba(22, 33, 62, 0.98);
            border: 2px solid var(--primary);
            border-radius: 12px;
            padding: 12px 16px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            z-index: 2000;
            display: none;
            pointer-events: none;
            min-width: 180px;
        }

        .drag-tooltip.show {
            display: block;
        }

        .drag-tooltip-crop {
            font-weight: 700;
            font-size: 1rem;
            margin-bottom: 8px;
            padding-bottom: 8px;
            border-bottom: 1px solid var(--border);
            color: var(--primary-light);
        }

        .drag-date-row {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
            font-size: 0.9rem;
        }

        .drag-date-label {
            color: var(--text-secondary);
        }

        .drag-date-value {
            font-weight: 600;
            color: var(--text-primary);
            font-family: 'Courier New', monospace;
        }

        .drag-date-value.changed {
            color: var(--secondary);
            animation: pulse-date 0.3s ease;
        }

        @keyframes pulse-date {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        /* Timeline Navigation Bar */
        .timeline-nav {
            position: fixed;
            top: 65px;
            left: 280px;
            right: 0;
            background: rgba(22, 33, 62, 0.98);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid var(--border);
            padding: 10px 20px;
            display: flex;
            align-items: center;
            gap: 15px;
            z-index: 500;
        }

        .nav-btn {
            background: var(--bg-light);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 8px 12px;
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 2px;
        }

        .nav-btn:hover {
            background: var(--primary);
            border-color: var(--primary);
        }

        .nav-btn.today-btn {
            background: var(--primary);
            font-weight: 600;
        }

        .timeline-slider-container {
            flex: 1;
            max-width: 500px;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .timeline-slider {
            width: 100%;
            height: 8px;
            -webkit-appearance: none;
            background: var(--bg-light);
            border-radius: 4px;
            outline: none;
        }

        .timeline-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: var(--primary);
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }

        .timeline-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: var(--primary);
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid white;
        }

        .timeline-months {
            display: flex;
            justify-content: space-between;
            font-size: 0.65rem;
            color: var(--text-secondary);
            padding: 0 5px;
        }

        .current-range {
            background: var(--bg-light);
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--secondary);
            white-space: nowrap;
        }

        .main-container {
            padding: 130px 0 0; /* Adjusted for timeline nav */
        }

        @media (max-width: 1024px) {
            .timeline-nav {
                left: 0;
                top: 60px;
            }
            .main-container {
                padding-top: 180px;
            }
        }

        .crop-bar-icon {
            margin-right: 6px;
            font-size: 1rem;
        }

        .crop-bar-content {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .crop-bar-name {
            font-weight: 700;
        }

        .crop-bar-dates {
            font-size: 0.65rem;
            opacity: 0.9;
        }

        /* Resize Handles */
        .resize-handle {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 12px;
            cursor: ew-resize;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .crop-bar:hover .resize-handle {
            opacity: 1;
        }

        .resize-handle-left {
            left: 0;
            border-radius: 6px 0 0 6px;
            background: linear-gradient(90deg, rgba(0,0,0,0.3), transparent);
        }

        .resize-handle-right {
            right: 0;
            border-radius: 0 6px 6px 0;
            background: linear-gradient(-90deg, rgba(0,0,0,0.3), transparent);
        }

        .resize-handle::before {
            content: '';
            width: 3px;
            height: 20px;
            background: rgba(255,255,255,0.5);
            border-radius: 2px;
        }

        /* Drop Zone Highlight */
        .field-timeline.drop-target {
            background: rgba(45, 90, 39, 0.2);
        }

        .gantt-row.drop-target {
            background: rgba(45, 90, 39, 0.3) !important;
            box-shadow: inset 0 0 0 2px var(--primary);
        }

        /* Tooltip */
        .tooltip {
            position: fixed;
            background: var(--bg-card);
            border: 1px solid var(--primary);
            border-radius: 12px;
            padding: 1rem;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            z-index: 1000;
            max-width: 300px;
            display: none;
            pointer-events: none;
        }

        .tooltip.show {
            display: block;
        }

        .tooltip-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border);
        }

        .tooltip-icon {
            font-size: 1.5rem;
        }

        .tooltip-title {
            font-weight: 700;
            font-size: 1.1rem;
        }

        .tooltip-variety {
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .tooltip-row {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
            font-size: 0.9rem;
        }

        .tooltip-label {
            color: var(--text-secondary);
        }

        .tooltip-actions {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid var(--border);
            font-size: 0.75rem;
            color: var(--text-secondary);
            text-align: center;
        }

        /* Buttons */
        .btn {
            padding: 10px 20px;
            border-radius: 10px;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            border: none;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-light) 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(45, 90, 39, 0.3);
        }

        .btn-secondary {
            background: var(--bg-light);
            color: var(--text-primary);
            border: 1px solid var(--border);
        }

        /* Toast */
        .toast {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            background: var(--bg-card);
            border: 1px solid var(--primary);
            border-radius: 12px;
            padding: 1rem 1.5rem;
            display: flex;
            align-items: center;
            gap: 12px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            transform: translateX(150%);
            transition: transform 0.3s ease;
            z-index: 2000;
        }

        .toast.show { transform: translateX(0); }
        .toast.success i { color: var(--success); }
        .toast.error i { color: var(--danger); }
        .toast.warning i { color: var(--warning); }

        /* Loading */
        .loading {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 4rem;
            color: var(--text-secondary);
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 1rem;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Mobile */
        @media (max-width: 1024px) {
            .header {
                padding-left: 1rem;
                flex-wrap: wrap;
                gap: 0.5rem;
            }
            .header-controls {
                flex-wrap: wrap;
                gap: 0.5rem;
            }
            .sidebar {
                transform: translateX(-100%);
                transition: transform 0.3s;
            }
            .sidebar.show {
                transform: translateX(0);
            }
            .gantt-container {
                margin-left: 0;
            }
        }

        /* Larger screens - ensure header controls don't get cut off */
        @media (min-width: 1600px) {
            .header-controls {
                gap: 1.5rem;
            }
        }

        /* ============================================= */
        /* KEYBOARD SHORTCUTS HELP */
        /* ============================================= */
        .keyboard-help {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 1rem;
            font-size: 0.75rem;
            color: var(--text-secondary);
            z-index: 2000;
            display: none;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .keyboard-help.visible {
            display: block;
        }

        .keyboard-help h4 {
            color: var(--text-primary);
            margin-bottom: 0.5rem;
            font-size: 0.85rem;
        }

        .keyboard-help kbd {
            background: var(--bg-light);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: monospace;
            margin-right: 0.5rem;
            font-size: 0.7rem;
        }

        .keyboard-help div {
            margin-bottom: 0.25rem;
        }

        /* ============================================= */
        /* PRINT STYLES */
        /* ============================================= */
        @media print {
            body {
                background: white !important;
                color: black !important;
                -webkit-print-color-adjust: exact;
                print-color-adjust: exact;
            }

            .header,
            .sidebar,
            .zoom-controls,
            .tooltip,
            .toast,
            .drag-tooltip,
            .keyboard-help,
            .modal-overlay,
            .legend-section button,
            #addPlantingModal,
            #editModal {
                display: none !important;
            }

            .gantt-container {
                margin-left: 0 !important;
                margin-top: 0 !important;
                padding: 0 !important;
            }

            .gantt-header {
                position: relative !important;
                background: #f0f0f0 !important;
            }

            .field-row {
                background: white !important;
                border: 1px solid #ddd !important;
            }

            .field-label {
                background: #f5f5f5 !important;
                color: black !important;
                border-right: 1px solid #ddd !important;
            }

            .crop-bar {
                border: 1px solid #333 !important;
                box-shadow: none !important;
            }

            .crop-bar .bar-text {
                color: white !important;
                text-shadow: none !important;
            }

            .month-label,
            .day-label {
                color: black !important;
            }

            .today-line {
                background: red !important;
            }

            .grid-line {
                background: #eee !important;
            }

            .grid-line.month-start {
                background: #ccc !important;
            }

            @page {
                margin: 0.25in;
                size: landscape;
            }

            /* Show date range for context */
            .gantt-header::before {
                content: 'Tiny Seed Farm - Visual Calendar';
                display: block;
                text-align: center;
                padding: 10px;
                font-weight: bold;
                font-size: 14pt;
            }
        }

        /* ============================================= */
        /* PLANNING ASSISTANT - AI CHAT INTERFACE */
        /* ============================================= */
        .planning-assistant {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 10000;
            font-family: 'Inter', sans-serif;
        }

        .assistant-toggle {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-light) 100%);
            border: none;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            box-shadow: 0 4px 20px rgba(45, 90, 39, 0.4);
            transition: all 0.3s ease;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .assistant-toggle:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 30px rgba(45, 90, 39, 0.5);
        }

        .assistant-toggle.has-suggestions {
            animation: pulse-glow 2s infinite;
        }

        @keyframes pulse-glow {
            0%, 100% { box-shadow: 0 4px 20px rgba(45, 90, 39, 0.4); }
            50% { box-shadow: 0 4px 30px rgba(244, 162, 97, 0.6); }
        }

        .assistant-toggle .notification-badge {
            position: absolute;
            top: -5px;
            right: -5px;
            background: var(--danger);
            color: white;
            font-size: 0.7rem;
            font-weight: 700;
            min-width: 20px;
            height: 20px;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0 6px;
        }

        .assistant-toggle .notification-badge:empty,
        .assistant-toggle .notification-badge[data-count="0"] {
            display: none;
        }

        .assistant-panel {
            position: absolute;
            bottom: 70px;
            right: 0;
            width: 420px;
            height: 600px;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
            display: none;
            flex-direction: column;
            overflow: hidden;
            transform-origin: bottom right;
            animation: slideUp 0.3s ease;
        }

        .assistant-panel.open {
            display: flex;
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: scale(0.9) translateY(20px);
            }
            to {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
        }

        .assistant-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 1.25rem;
            background: linear-gradient(135deg, var(--primary-dark) 0%, var(--primary) 100%);
            border-bottom: 1px solid var(--border);
        }

        .assistant-title {
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: 600;
            font-size: 1rem;
            color: white;
        }

        .assistant-title i {
            font-size: 1.25rem;
        }

        .assistant-close {
            background: rgba(255,255,255,0.1);
            border: none;
            color: white;
            width: 32px;
            height: 32px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1.25rem;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }

        .assistant-close:hover {
            background: rgba(255,255,255,0.2);
        }

        .assistant-suggestions {
            padding: 0.75rem;
            background: rgba(244, 162, 97, 0.1);
            border-bottom: 1px solid var(--border);
            max-height: 150px;
            overflow-y: auto;
        }

        .assistant-suggestions:empty {
            display: none;
        }

        .suggestion-card {
            background: var(--bg-light);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 0.75rem 1rem;
            margin-bottom: 0.5rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .suggestion-card:last-child {
            margin-bottom: 0;
        }

        .suggestion-card:hover {
            border-color: var(--primary);
            background: rgba(45, 90, 39, 0.1);
        }

        .suggestion-card .suggestion-icon {
            margin-right: 8px;
        }

        .suggestion-card .suggestion-text {
            font-size: 0.85rem;
        }

        .suggestion-card .suggestion-meta {
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-top: 4px;
        }

        .assistant-messages {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .message {
            max-width: 85%;
            padding: 0.75rem 1rem;
            border-radius: 12px;
            font-size: 0.9rem;
            line-height: 1.5;
        }

        .message.user {
            align-self: flex-end;
            background: var(--primary);
            color: white;
            border-bottom-right-radius: 4px;
        }

        .message.assistant {
            align-self: flex-start;
            background: var(--bg-light);
            border: 1px solid var(--border);
            border-bottom-left-radius: 4px;
        }

        .message.assistant .message-actions {
            margin-top: 0.75rem;
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .message-action-btn {
            padding: 6px 12px;
            border-radius: 6px;
            border: 1px solid var(--border);
            background: transparent;
            color: var(--text-primary);
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .message-action-btn:hover {
            background: var(--primary);
            border-color: var(--primary);
            color: white;
        }

        .message-action-btn.primary {
            background: var(--primary);
            border-color: var(--primary);
            color: white;
        }

        .message-action-btn.danger {
            border-color: var(--danger);
            color: var(--danger);
        }

        .message-action-btn.danger:hover {
            background: var(--danger);
            color: white;
        }

        .message .preview-box {
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
            padding: 0.75rem;
            margin-top: 0.5rem;
            font-family: monospace;
            font-size: 0.8rem;
        }

        .message .preview-box .preview-row {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .message .preview-box .preview-row:last-child {
            border-bottom: none;
        }

        .message .preview-box .changed {
            color: var(--secondary);
        }

        .message.typing .dots {
            display: inline-flex;
            gap: 4px;
        }

        .message.typing .dot {
            width: 8px;
            height: 8px;
            background: var(--text-secondary);
            border-radius: 50%;
            animation: typing 1.4s infinite;
        }

        .message.typing .dot:nth-child(2) { animation-delay: 0.2s; }
        .message.typing .dot:nth-child(3) { animation-delay: 0.4s; }

        @keyframes typing {
            0%, 60%, 100% { transform: translateY(0); }
            30% { transform: translateY(-8px); }
        }

        .assistant-input-area {
            display: flex;
            gap: 0.5rem;
            padding: 1rem;
            border-top: 1px solid var(--border);
            background: var(--bg-card);
        }

        .assistant-input-area input {
            flex: 1;
            padding: 0.75rem 1rem;
            border-radius: 10px;
            border: 1px solid var(--border);
            background: var(--bg-light);
            color: var(--text-primary);
            font-size: 0.9rem;
            outline: none;
            transition: border-color 0.2s;
        }

        .assistant-input-area input:focus {
            border-color: var(--primary);
        }

        .assistant-input-area input::placeholder {
            color: var(--text-secondary);
        }

        .assistant-input-area button {
            width: 44px;
            height: 44px;
            border-radius: 10px;
            border: none;
            background: var(--primary);
            color: white;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .assistant-input-area button:hover {
            background: var(--primary-light);
            transform: scale(1.05);
        }

        .assistant-input-area button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        /* Quick action chips in input */
        .quick-actions {
            display: flex;
            gap: 6px;
            padding: 0 1rem 0.5rem;
            flex-wrap: wrap;
        }

        .quick-action-chip {
            padding: 6px 12px;
            border-radius: 20px;
            background: rgba(45, 90, 39, 0.15);
            border: 1px solid rgba(45, 90, 39, 0.3);
            color: var(--primary-light);
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .quick-action-chip:hover {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }

        /* Mobile responsive */
        @media (max-width: 480px) {
            .assistant-panel {
                width: calc(100vw - 20px);
                height: calc(100vh - 100px);
                right: 10px;
                bottom: 80px;
                border-radius: 12px;
            }
        }
    </style>
</head>
<body>
    <header class="header">
        <div class="header-left">
            <a href="index.html" class="back-btn">
                <i class="fas fa-arrow-left"></i>
                <span>Back</span>
            </a>
            <h1 class="page-title">
                <i class="fas fa-calendar-alt"></i>
                Field & Crop Calendar
            </h1>
        </div>
        <div class="header-controls">
            <div class="sync-indicator synced" id="syncIndicator">
                <span class="sync-dot"></span>
                <span id="syncText">Synced</span>
            </div>
            <button class="submit-changes-btn" id="submitChangesBtn" onclick="saveToGoogleSheets()">
                <i class="fas fa-cloud-upload-alt"></i>
                Submit Changes
                <span class="badge" id="pendingCount">0</span>
            </button>
            <button class="discard-btn" id="discardBtn" onclick="discardChanges()">
                <i class="fas fa-times"></i> Discard
            </button>
            <div class="zoom-controls">
                <button class="zoom-btn active" onclick="setViewMode('field')" id="view-field">By Field</button>
                <button class="zoom-btn" onclick="setViewMode('bed')" id="view-bed">By Bed</button>
                <button class="zoom-btn" onclick="setViewMode('crop')" id="view-crop">By Crop</button>
                <button class="zoom-btn" onclick="setViewMode('variety')" id="view-variety">By Variety</button>
            </div>
            <div class="zoom-controls">
                <button class="zoom-btn" onclick="setZoom('day')" id="zoom-day">Day</button>
                <button class="zoom-btn active" onclick="setZoom('week')" id="zoom-week">Week</button>
                <button class="zoom-btn" onclick="setZoom('month')" id="zoom-month">Month</button>
                <button class="zoom-btn" onclick="setZoom('quarter')" id="zoom-quarter">Quarter</button>
                <button class="zoom-btn" onclick="setZoom('year')" id="zoom-year">Full Year</button>
            </div>
            <button class="btn btn-secondary" onclick="showFullYear()">
                <i class="fas fa-expand"></i> Full Year
            </button>
            <button class="btn btn-primary" onclick="window.location.href='succession.html'">
                <i class="fas fa-plus"></i> Add Planting
            </button>
        </div>
    </header>

    <!-- Timeline Navigation Bar -->
    <div class="timeline-nav" id="timelineNav">
        <button class="nav-btn" onclick="navigateTimeline(-30)" title="Previous Month">
            <i class="fas fa-chevron-left"></i><i class="fas fa-chevron-left"></i>
        </button>
        <button class="nav-btn" onclick="navigateTimeline(-7)" title="Previous Week">
            <i class="fas fa-chevron-left"></i>
        </button>
        <div class="timeline-slider-container">
            <input type="range" id="timelineSlider" class="timeline-slider"
                   min="0" max="365" value="0"
                   oninput="onSliderChange(this.value)">
            <div class="timeline-months">
                <span>Jan</span><span>Feb</span><span>Mar</span><span>Apr</span>
                <span>May</span><span>Jun</span><span>Jul</span><span>Aug</span>
                <span>Sep</span><span>Oct</span><span>Nov</span><span>Dec</span>
            </div>
        </div>
        <button class="nav-btn" onclick="navigateTimeline(7)" title="Next Week">
            <i class="fas fa-chevron-right"></i>
        </button>
        <button class="nav-btn" onclick="navigateTimeline(30)" title="Next Month">
            <i class="fas fa-chevron-right"></i><i class="fas fa-chevron-right"></i>
        </button>
        <button class="nav-btn today-btn" onclick="goToToday()" title="Go to Today">
            Today
        </button>
        <div class="current-range" id="currentRange">Jan 1 - Dec 31, 2026</div>
    </div>

    <aside class="sidebar" id="sidebar">
        <div class="sidebar-section">
            <h3 class="sidebar-title">Filters</h3>

            <div class="filter-group">
                <label>Date Range</label>
                <select class="filter-control" id="dateRange" onchange="applyFilters()">
                    <option value="season">Full Season 2026</option>
                    <option value="month">This Month</option>
                    <option value="quarter">This Quarter</option>
                </select>
            </div>

            <div class="filter-group">
                <label>Crop</label>
                <select class="filter-control" id="cropFilter" onchange="applyFilters()">
                    <option value="">All Crops</option>
                </select>
            </div>

            <div class="filter-group">
                <label>Field</label>
                <select class="filter-control" id="fieldFilter" onchange="applyFilters()">
                    <option value="">All Fields</option>
                </select>
            </div>
        </div>

        <div class="sidebar-section">
            <h3 class="sidebar-title">Status</h3>
            <div class="checkbox-filters">
                <label class="checkbox-filter">
                    <input type="checkbox" checked onchange="applyFilters()" data-status="seeding">
                    <span class="status-dot seeding"></span>
                    <span>Seeding</span>
                </label>
                <label class="checkbox-filter">
                    <input type="checkbox" checked onchange="applyFilters()" data-status="growing">
                    <span class="status-dot growing"></span>
                    <span>Growing</span>
                </label>
                <label class="checkbox-filter">
                    <input type="checkbox" checked onchange="applyFilters()" data-status="harvest">
                    <span class="status-dot harvest"></span>
                    <span>Harvest Ready</span>
                </label>
                <label class="checkbox-filter">
                    <input type="checkbox" onchange="applyFilters()" data-status="completed">
                    <span class="status-dot completed"></span>
                    <span>Completed</span>
                </label>
            </div>
        </div>

        <div class="sidebar-section">
            <h3 class="sidebar-title">Legend</h3>
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: linear-gradient(135deg, #8e44ad 0%, #9b59b6 100%);"></div>
                    <span>Seeding Phase</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: linear-gradient(135deg, var(--primary) 0%, var(--primary-light) 100%);"></div>
                    <span>Growing Phase</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: linear-gradient(135deg, var(--secondary) 0%, var(--accent) 100%);"></div>
                    <span>Harvest Window</span>
                </div>
            </div>
        </div>

        <div class="sidebar-section">
            <h3 class="sidebar-title">Instructions</h3>
            <div style="font-size: 0.8rem; color: var(--text-secondary); line-height: 1.6;">
                <p><strong>Drag</strong> bars to move between fields</p>
                <p><strong>Resize</strong> by dragging edges to adjust duration</p>
                <p>Changes sync to Google Sheets automatically</p>
            </div>
        </div>

        <div class="sidebar-section">
            <button class="btn btn-primary" style="width: 100%; margin-bottom: 10px;" onclick="openAddPlantingModal()">
                <i class="fas fa-plus"></i> Add Planting
            </button>
            <button class="btn btn-secondary" style="width: 100%;" onclick="refreshData()">
                <i class="fas fa-sync-alt"></i> Refresh Data
            </button>
        </div>
    </aside>

    <main class="main-container">
        <div class="gantt-container">
            <div class="gantt-wrapper">
                <div class="stats-bar">
                    <div class="stat-item">
                        <span class="stat-value" id="totalPlantings">--</span>
                        <span class="stat-label">Plantings</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-value" id="activePlantings">--</span>
                        <span class="stat-label">Active</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-value" id="harvestReady">--</span>
                        <span class="stat-label">Harvest Ready</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-value" id="totalBedFeet">--</span>
                        <span class="stat-label">Bed Feet</span>
                    </div>
                </div>

                <div class="gantt-chart" id="ganttChart">
                    <div class="loading">
                        <div class="spinner"></div>
                        <p>Loading calendar...</p>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <!-- Unassigned Plantings Panel - Right Sidebar -->
    <button class="unassigned-toggle" id="unassignedToggle" onclick="toggleUnassignedPanel()">
        <span class="badge" id="unassignedBadge">0</span>
        Unassigned
    </button>

    <aside class="unassigned-panel" id="unassignedPanel">
        <div class="unassigned-header">
            <h3><i class="fas fa-exclamation-triangle"></i> Unassigned Plantings</h3>
            <div class="unassigned-count" id="unassignedPanelCount">0 plantings need bed assignment</div>
            <input type="text" class="unassigned-search" placeholder="Search crops..." oninput="filterUnassigned(this.value)">
        </div>
        <div id="unassignedContent">
            <!-- Populated by JavaScript - organized by crop -->
        </div>
    </aside>

    <!-- Edit Planting Modal -->
    <div class="edit-modal-overlay" id="editModal">
        <div class="edit-modal" style="max-width: 700px;">
            <div class="edit-modal-header">
                <div class="edit-modal-title">
                    <span id="editModalIcon" style="font-size: 1.5rem;">üå±</span>
                    <div>
                        <div style="font-size: 1.1rem;" id="editModalCropName">Edit Planting</div>
                        <div style="font-size: 0.8rem; color: var(--text-secondary); font-weight: normal;" id="editModalBatchId">Batch ID: --</div>
                    </div>
                </div>
                <button class="edit-modal-close" onclick="closeEditModal()">&times;</button>
            </div>
            <div class="edit-modal-body">
                <input type="hidden" id="editBatchId">

                <!-- Current Info Banner -->
                <div style="background: var(--bg-light); border-radius: 8px; padding: 1rem; margin-bottom: 1.25rem; border-left: 4px solid var(--primary);">
                    <div style="font-size: 0.8rem; color: var(--text-secondary); margin-bottom: 0.5rem;">CURRENT SCHEDULE</div>
                    <div id="editCurrentSchedule" style="font-size: 0.9rem; line-height: 1.6;">Loading...</div>
                </div>

                <!-- Planting Method Toggle -->
                <div class="edit-form-group">
                    <label class="edit-form-label">Planting Method</label>
                    <div style="display: flex; gap: 1rem;">
                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 10px 16px; background: var(--bg-light); border-radius: 8px; border: 2px solid transparent; transition: all 0.2s;" id="methodTransplantLabel">
                            <input type="radio" name="plantingMethod" value="Transplant" id="methodTransplant" onchange="updateMethodFields()">
                            <span>üå± Transplant</span>
                            <span style="font-size: 0.75rem; color: var(--text-secondary);">(Start in GH)</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 10px 16px; background: var(--bg-light); border-radius: 8px; border: 2px solid transparent; transition: all 0.2s;" id="methodDirectLabel">
                            <input type="radio" name="plantingMethod" value="Direct Seed" id="methodDirect" onchange="updateMethodFields()">
                            <span>üåæ Direct Seed</span>
                            <span style="font-size: 0.75rem; color: var(--text-secondary);">(Sow in field)</span>
                        </label>
                    </div>
                </div>

                <!-- Crop & Variety -->
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1.25rem;">
                    <div class="edit-form-group" style="margin-bottom: 0;">
                        <label class="edit-form-label">Crop</label>
                        <input type="text" class="edit-form-input" id="editCrop">
                    </div>
                    <div class="edit-form-group" style="margin-bottom: 0;">
                        <label class="edit-form-label">Variety</label>
                        <input type="text" class="edit-form-input" id="editVariety">
                    </div>
                </div>

                <!-- Location -->
                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 1rem; margin-bottom: 1.25rem;">
                    <div class="edit-form-group" style="margin-bottom: 0;">
                        <label class="edit-form-label">Field</label>
                        <input type="text" class="edit-form-input" id="editField">
                    </div>
                    <div class="edit-form-group" style="margin-bottom: 0;">
                        <label class="edit-form-label">Bed</label>
                        <input type="text" class="edit-form-input" id="editBed" placeholder="e.g., 1">
                    </div>
                    <div class="edit-form-group" style="margin-bottom: 0;">
                        <label class="edit-form-label">Bed Feet</label>
                        <input type="number" class="edit-form-input" id="editBedFeet">
                    </div>
                </div>

                <!-- Dates Section -->
                <div style="background: var(--bg-light); border-radius: 8px; padding: 1rem; margin-bottom: 1.25rem;">
                    <div style="font-size: 0.85rem; font-weight: 600; margin-bottom: 1rem; display: flex; align-items: center; gap: 8px;">
                        <i class="fas fa-calendar-alt" style="color: var(--primary);"></i>
                        Schedule Dates
                    </div>

                    <!-- Transplant dates (shown when Transplant selected) -->
                    <div id="transplantDates">
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1rem;">
                            <div class="edit-form-group" style="margin-bottom: 0;">
                                <label class="edit-form-label">üè† GH Sow Date</label>
                                <input type="date" class="edit-form-input" id="editGHSow">
                            </div>
                            <div class="edit-form-group" style="margin-bottom: 0;">
                                <label class="edit-form-label">üåø Transplant to Field</label>
                                <input type="date" class="edit-form-input" id="editTransplant">
                            </div>
                        </div>
                    </div>

                    <!-- Direct Seed dates (shown when Direct Seed selected) -->
                    <div id="directSeedDates" style="display: none;">
                        <div class="edit-form-group" style="margin-bottom: 1rem;">
                            <label class="edit-form-label">üåæ Field Sow Date</label>
                            <input type="date" class="edit-form-input" id="editFieldSow">
                        </div>
                    </div>

                    <!-- Harvest dates (always shown) -->
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                        <div class="edit-form-group" style="margin-bottom: 0;">
                            <label class="edit-form-label">ü•¨ First Harvest</label>
                            <input type="date" class="edit-form-input" id="editFirstHarvest">
                        </div>
                        <div class="edit-form-group" style="margin-bottom: 0;">
                            <label class="edit-form-label">üèÅ Last Harvest</label>
                            <input type="date" class="edit-form-input" id="editLastHarvest">
                        </div>
                    </div>
                </div>

                <!-- Days to Maturity (info only) -->
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1.25rem;">
                    <div class="edit-form-group" style="margin-bottom: 0;">
                        <label class="edit-form-label">Days to Maturity</label>
                        <input type="number" class="edit-form-input" id="editDTM" placeholder="e.g., 65">
                    </div>
                    <div class="edit-form-group" style="margin-bottom: 0;">
                        <label class="edit-form-label">Harvest Window (days)</label>
                        <input type="number" class="edit-form-input" id="editHarvestWindow" placeholder="e.g., 21">
                    </div>
                </div>

                <!-- Notes -->
                <div class="edit-form-group">
                    <label class="edit-form-label">Notes</label>
                    <textarea class="edit-form-input" id="editNotes" rows="2" placeholder="Any notes about this planting..."></textarea>
                </div>
            </div>
            <div class="edit-modal-footer">
                <button class="edit-btn edit-btn-cancel" onclick="closeEditModal()">Cancel</button>
                <button class="edit-btn edit-btn-save" id="editSaveBtn" onclick="saveEditModal()">
                    <i class="fas fa-save"></i> Save Changes
                </button>
            </div>
        </div>
    </div>

    <!-- Add Planting Modal -->
    <div class="edit-modal-overlay" id="addPlantingModal">
        <div class="edit-modal" style="max-width: 600px;">
            <div class="edit-modal-header">
                <div class="edit-modal-title">
                    <span style="font-size: 1.5rem;">üå±</span>
                    <div>
                        <div style="font-size: 1.1rem;">Add New Planting</div>
                        <div style="font-size: 0.8rem; color: var(--text-secondary); font-weight: normal;">Create a new planting on the calendar</div>
                    </div>
                </div>
                <button class="edit-modal-close" onclick="closeAddPlantingModal()">&times;</button>
            </div>
            <div class="edit-modal-body">
                <div class="edit-form-row">
                    <div class="edit-form-group">
                        <label class="edit-label">Crop</label>
                        <select class="edit-input" id="addCrop" onchange="onAddCropChange()">
                            <option value="">Select crop...</option>
                        </select>
                        <input type="text" class="edit-input" id="addNewCrop" placeholder="Enter new crop name..." style="display: none; margin-top: 6px;">
                    </div>
                    <div class="edit-form-group">
                        <label class="edit-label">Variety</label>
                        <select class="edit-input" id="addVariety" onchange="onAddVarietyChange()">
                            <option value="">Select variety...</option>
                        </select>
                        <input type="text" class="edit-input" id="addNewVariety" placeholder="Enter new variety name..." style="display: none; margin-top: 6px;">
                    </div>
                </div>
                <div class="edit-form-row">
                    <div class="edit-form-group">
                        <label class="edit-label">Planting Method</label>
                        <select class="edit-input" id="addMethod">
                            <option value="Transplant">Transplant</option>
                            <option value="Direct Seed">Direct Seed</option>
                        </select>
                    </div>
                    <div class="edit-form-group">
                        <label class="edit-label">Tray Size</label>
                        <select class="edit-input" id="addTraySize">
                            <option value="128">128-cell</option>
                            <option value="72">72-cell</option>
                            <option value="50">50-cell</option>
                            <option value="32">32-cell</option>
                        </select>
                    </div>
                </div>
                <div class="edit-form-row">
                    <div class="edit-form-group">
                        <label class="edit-label">Bed Feet</label>
                        <input type="number" class="edit-input" id="addFeet" value="100" min="1">
                    </div>
                    <div class="edit-form-group">
                        <label class="edit-label">Target Field/Bed</label>
                        <input type="text" class="edit-input" id="addBed" placeholder="e.g., F1L-01">
                    </div>
                </div>
                <div class="edit-form-row">
                    <div class="edit-form-group">
                        <label class="edit-label">Date Type</label>
                        <select class="edit-input" id="addDateType">
                            <option value="transplant">Transplant Date</option>
                            <option value="ghSow">GH Sow Date</option>
                            <option value="fieldSow">Field Sow Date</option>
                            <option value="harvest">First Harvest Date</option>
                        </select>
                    </div>
                    <div class="edit-form-group">
                        <label class="edit-label">Date</label>
                        <input type="date" class="edit-input" id="addDate">
                    </div>
                </div>
                <div class="edit-form-row">
                    <div class="edit-form-group" style="flex: 1;">
                        <label class="edit-label">
                            <input type="checkbox" id="addSuccessionCheck" onchange="toggleAddSuccession()">
                            Add Successions
                        </label>
                        <div id="addSuccessionOptions" style="display: none; margin-top: 10px;">
                            <div style="display: flex; gap: 10px; align-items: center;">
                                <input type="number" class="edit-input" id="addSuccessionCount" value="4" min="1" max="20" style="width: 70px;">
                                <span>plantings every</span>
                                <input type="number" class="edit-input" id="addInterval" value="7" min="1" style="width: 70px;">
                                <select class="edit-input" id="addIntervalUnit" style="width: 100px;">
                                    <option value="days">days</option>
                                    <option value="weeks">weeks</option>
                                </select>
                            </div>
                        </div>
                    </div>
                </div>
                <div id="addPlantingSummary" style="margin-top: 15px; padding: 12px; background: rgba(45, 90, 39, 0.2); border-radius: 8px; font-size: 0.9rem;">
                    <strong>Summary:</strong> Select crop and dates to see planting summary
                </div>
            </div>
            <div class="edit-modal-footer">
                <button class="edit-btn edit-btn-cancel" onclick="closeAddPlantingModal()">Cancel</button>
                <button class="edit-btn edit-btn-save" onclick="saveAddPlanting()">
                    <i class="fas fa-plus"></i> Add Planting
                </button>
            </div>
        </div>
    </div>

    <!-- Gap Analysis Tooltip -->
    <div class="gap-tooltip" id="gapTooltip">
        <div class="gap-tooltip-header">
            <span style="font-size: 1.2rem;">üìÖ</span>
            <span class="gap-tooltip-title">Open Field Space</span>
        </div>
        <div class="gap-tooltip-row">
            <span class="gap-tooltip-label">Duration:</span>
            <span class="gap-tooltip-value" id="gapDuration">--</span>
        </div>
        <div class="gap-tooltip-row">
            <span class="gap-tooltip-label">Date Range:</span>
            <span class="gap-tooltip-value" id="gapDateRange">--</span>
        </div>
        <div class="gap-tooltip-row">
            <span class="gap-tooltip-label">Field:</span>
            <span class="gap-tooltip-value" id="gapField">--</span>
        </div>
        <div class="gap-tooltip-hint">
            <i class="fas fa-lightbulb"></i> Click to add a planting here
        </div>
    </div>

    <div class="tooltip" id="tooltip">
        <div class="tooltip-header">
            <span class="tooltip-icon" id="tooltipIcon">üå±</span>
            <div>
                <div class="tooltip-title" id="tooltipTitle">Crop Name</div>
                <div class="tooltip-variety" id="tooltipVariety">Variety</div>
            </div>
        </div>
        <div class="tooltip-row" id="tooltipLockRow" style="display: none; color: #e63946;">
            <span class="tooltip-label">üîí Locked:</span>
            <span id="tooltipLockReason">-</span>
        </div>
        <div class="tooltip-row">
            <span class="tooltip-label">Batch ID:</span>
            <span id="tooltipBatchId">-</span>
        </div>
        <div class="tooltip-row">
            <span class="tooltip-label">Field/Bed:</span>
            <span id="tooltipBed">-</span>
        </div>
        <div class="tooltip-row">
            <span class="tooltip-label">Method:</span>
            <span id="tooltipMethod">-</span>
        </div>
        <div class="tooltip-row" id="tooltipGHRow">
            <span class="tooltip-label">GH Sow:</span>
            <span id="tooltipGHSow">-</span>
        </div>
        <div class="tooltip-row">
            <span class="tooltip-label">In Field:</span>
            <span id="tooltipStart">-</span>
        </div>
        <div class="tooltip-row">
            <span class="tooltip-label">Last Harvest:</span>
            <span id="tooltipEnd">-</span>
        </div>
        <div class="tooltip-row">
            <span class="tooltip-label">Days in Field:</span>
            <span id="tooltipDuration">-</span>
        </div>
        <div class="tooltip-row">
            <span class="tooltip-label">Bed Feet:</span>
            <span id="tooltipBedFeet">-</span>
        </div>
        <div class="tooltip-row">
            <span class="tooltip-label">Status:</span>
            <span id="tooltipStatus">-</span>
        </div>
        <div class="tooltip-actions" id="tooltipActions">
            Drag to move | Resize edges to adjust dates
        </div>
    </div>

    <div class="toast" id="toast">
        <i class="fas fa-check-circle"></i>
        <span id="toastMessage">Action completed!</span>
    </div>

    <!-- Real-time drag date tooltip -->
    <div class="drag-tooltip" id="dragTooltip">
        <div class="drag-tooltip-crop" id="dragCrop">Lettuce</div>
        <div class="drag-tooltip-dates">
            <div class="drag-date-row">
                <span class="drag-date-label">GH Sow:</span>
                <span class="drag-date-value" id="dragGHSow">-</span>
            </div>
            <div class="drag-date-row">
                <span class="drag-date-label">In Field:</span>
                <span class="drag-date-value" id="dragFieldStart">Apr 15</span>
            </div>
            <div class="drag-date-row">
                <span class="drag-date-label">Harvest:</span>
                <span class="drag-date-value" id="dragHarvest">Jun 20</span>
            </div>
        </div>
    </div>

    <!-- Keyboard Shortcuts Help Panel -->
    <div class="keyboard-help" id="keyboardHelp">
        <h4><i class="fas fa-keyboard"></i> Keyboard Shortcuts</h4>
        <div><kbd>N</kbd> New planting</div>
        <div><kbd>T</kbd> Go to today</div>
        <div><kbd>R</kbd> Refresh data</div>
        <div><kbd>P</kbd> Print calendar</div>
        <div><kbd>F</kbd> Toggle fullscreen</div>
        <div><kbd>1-4</kbd> Zoom levels</div>
        <div><kbd>?</kbd> Toggle this help</div>
        <div><kbd>Esc</kbd> Close modals</div>
        <div><kbd>‚Üê‚Üí</kbd> Navigate timeline</div>
    </div>

    <script src="web_app/api-config.js"></script>
    <script>
        // API Configuration
        const API_URL = TINY_SEED_API.MAIN_API;

        // =============================================
        // KEYBOARD SHORTCUTS
        // =============================================
        document.addEventListener('keydown', function(e) {
            // Don't trigger when typing in inputs
            if (e.target.matches('input, textarea, select')) return;

            const key = e.key.toLowerCase();

            switch (key) {
                case 'n':
                    openAddPlantingModal();
                    break;
                case 't':
                    goToToday();
                    break;
                case 'r':
                    loadPlantings();
                    showToast('Refreshing calendar data...', 'info');
                    break;
                case 'p':
                    window.print();
                    break;
                case 'f':
                    toggleFullscreen();
                    break;
                case '1':
                    setZoom(50);
                    break;
                case '2':
                    setZoom(80);
                    break;
                case '3':
                    setZoom(100);
                    break;
                case '4':
                    setZoom(120);
                    break;
                case '?':
                    toggleKeyboardHelp();
                    break;
                case 'u':
                    toggleUnassignedPanel();
                    break;
                case 'arrowleft':
                    navigateTimeline(-7);
                    break;
                case 'arrowright':
                    navigateTimeline(7);
                    break;
            }
        });

        function toggleKeyboardHelp() {
            document.getElementById('keyboardHelp')?.classList.toggle('visible');
        }

        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
        }

        // State
        let plantings = [];
        let filteredPlantings = [];
        let fields = [];
        let zoomLevel = 'week';
        let viewMode = 'field'; // 'field', 'crop', or 'variety'
        let dayWidth = 20;
        let timelineStart = new Date('2026-01-01');
        let timelineEnd = new Date('2026-12-31');
        let pendingUpdates = new Map();
        let saveTimeout = null;

        // Ghost tracking for moved plantings (shows original position until submitted)
        let originalPositions = new Map(); // id -> { field, bed, fieldStartDate, left, top, rowGroup }
        let ghostElements = new Map(); // id -> ghost DOM element

        // All available beds (even if empty) - will be populated from API or defaults
        let allBeds = [];
        // Field configurations: { fieldCode: numberOfBeds } - loaded from API
        let FIELD_CONFIG = {};
        let DEFAULT_FIELDS = [];
        let allFieldsData = []; // Full field data from API

        // Crop icons - expanded for actual farm crops
        const cropIcons = {
            'Tomatoes': 'üçÖ', 'Tomatillos': 'üçÖ', 'Lettuce': 'ü•¨', 'Peppers': 'ü´ë',
            'Basil': 'üåø', 'Carrots': 'ü•ï', 'Kale': 'ü•ó', 'Spinach': 'üçÉ',
            'Cucumbers': 'ü•í', 'Beans': 'ü´ò', 'Squash': 'üéÉ', 'Winter Squash': 'üéÉ',
            'Onions': 'üßÖ', 'Garlic': 'üßÑ', 'Broccoli': 'ü•¶', 'Cabbage': 'ü•¨',
            'Corn': 'üåΩ', 'Peas': 'ü´õ', 'Beets': 'üü£', 'Cauliflower': 'ü•¶',
            'Eggplant': 'üçÜ', 'Fennel': 'üåø', 'Radicchio': 'ü•¨', 'Swiss Chard': 'ü•¨',
            'Bok Choy': 'ü•¨', 'Collard Greens': 'ü•¨', 'Kohlrabi': 'ü•¨',
            'Napa Cabbage': 'ü•¨', 'Scallions': 'üßÖ', 'Parsley': 'üåø',
            'Dandelions': 'üåø', 'Endive': 'ü•¨', 'Escarole': 'ü•¨',
            'Zucchini': 'ü•í', 'Summer Squash': 'ü•í', 'Melons': 'üçà',
            'Watermelon': 'üçâ', 'Potatoes': 'ü•î', 'Sweet Potatoes': 'üç†',
            'Turnips': 'üü£', 'Radishes': 'üü£', 'Rutabaga': 'üü£'
        };

        // Crop colors from REF_CropProfiles (primary color per crop)
        const cropColors = {
            'Lettuce': '#2E8B57',
            'Kale': '#006400',
            'Basil': '#228B22',
            'Broccoli': '#0C360C',
            'Beets': '#820B55',
            'Carrots': '#FF8C00',
            'Eggplant': '#B22222',
            'Tomatoes': '#DC143C',
            'Tomatillos': '#FF6347',
            'Peppers': '#E74C3C',
            'Winter Squash': '#D35400',
            'Fennel': '#F1C40F',
            'Cabbage': '#1E4D2B',
            'Cauliflower': '#2E8B57',
            'Bok Choy': '#155815',
            'Collard Greens': '#006400',
            'Kohlrabi': '#2E8B57',
            'Radicchio': '#7B241C',
            'Swiss Chard': '#C71585',
            'Scallions': '#D8BFD8',
            'Parsley': '#1E8449',
            'Spinach': '#1E8449',
            'Cucumbers': '#E67E22',
            'Beans': '#228B22',
            'Onions': '#DDA0DD',
            'Garlic': '#D8BFD8',
            'Endive': '#9370DB',
            'Escarole': '#9932CC',
            'Napa Cabbage': '#1E4D2B',
            'Dandelions': '#9370DB'
        };

        // Will be populated from API
        let cropProfileColors = {};

        // Initialize
        document.addEventListener('DOMContentLoaded', async function() {
            await loadFields();    // Load field config first
            loadCropProfiles();    // Load colors
            loadPlantings();       // Then load plantings
        });

        // Load field configuration from API
        async function loadFields() {
            try {
                const response = await fetch(`${API_URL}?action=getFields`);
                const data = await response.json();

                if (data.success && data.fields) {
                    allFieldsData = data.fields;
                    FIELD_CONFIG = data.fieldConfig || {};
                    DEFAULT_FIELDS = Object.keys(FIELD_CONFIG).sort();

                    console.log(`Loaded ${data.count} fields from API:`, DEFAULT_FIELDS);
                } else {
                    console.warn('Failed to load fields, using fallback');
                    useFallbackFields();
                }
            } catch (error) {
                console.error('Error loading fields:', error);
                useFallbackFields();
            }
        }

        // Fallback if API fails
        function useFallbackFields() {
            FIELD_CONFIG = {
                'F3L': 12, 'F7M': 10, 'F11M': 10, 'HOL': 12,
                'IL': 11, 'IOL': 8, 'JL': 10, 'JS1': 15,
                'JS4': 10, 'JS6': 10, 'JS10': 14, 'M': 14,
                'SO': 12, 'Z3': 15, 'Z5': 6
            };
            DEFAULT_FIELDS = Object.keys(FIELD_CONFIG).sort();
            allFieldsData = [];
        }

        // Load crop profiles to get colors
        async function loadCropProfiles() {
            try {
                const response = await fetch(`${API_URL}?action=getCropProfiles`);
                const data = await response.json();

                if (data.success && data.data && data.data.length > 0) {
                    // Build color map from crop profiles
                    data.data.forEach(profile => {
                        const cropName = profile.Crop_Name || profile.crop_name || profile.Crop;
                        const colorHex = profile.Color_Hex || profile.color_hex || profile.Color;
                        if (cropName && colorHex && colorHex.startsWith('#')) {
                            cropProfileColors[cropName] = colorHex;
                        }
                    });
                }
            } catch (error) {
            }
        }

        // Load Plantings from API
        async function loadPlantings() {
            setSyncStatus('syncing', 'Loading...');

            try {
                // Use getPlanningData (matches your existing Apps Script)
                let response = await fetch(`${API_URL}?action=getPlanningData`);
                let data = await response.json();


                if (data.success && data.data && data.data.length > 0) {

                    const rawCount = data.data.length;
                    plantings = normalizeData(data.data);

                    if (plantings.length > 0) {
                        setSyncStatus('synced', `Live: ${plantings.length} plantings`);
                        showToast(`Loaded ${plantings.length} plantings from Google Sheets`, 'success');
                    } else {
                        console.warn('All plantings filtered out - check date fields in your data', {
                            Plan_GH_Sow: data.data[0]?.Plan_GH_Sow,
                            Plan_Transplant: data.data[0]?.Plan_Transplant,
                            Plan_Field_Sow: data.data[0]?.Plan_Field_Sow,
                            Last_Harvest: data.data[0]?.Last_Harvest
                        });
                        plantings = getDemoPlantings();
                        setSyncStatus('synced', 'Demo (no valid dates)');
                    }
                } else {
                    plantings = getDemoPlantings();
                    setSyncStatus('synced', 'Demo Mode');
                }
            } catch (error) {
                console.error('Error loading plantings:', error);
                plantings = getDemoPlantings();
                setSyncStatus('error', 'Offline - Demo');
            }

            extractFieldsAndCrops();
            applyFilters();
            populateUnassignedPanel(); // Populate unassigned plantings sidebar
        }

        function normalizeData(data) {
            return data.map((p, index) => {
                // Extract field and bed from Target_Bed_ID (e.g., "Field F3L-01" -> field="F3L", bed="01")
                const targetBed = p.Target_Bed_ID || p.target_bed_id || p.Bed || p.bed || '';
                const { field, bedNum, isUnassigned } = extractFieldAndBed(targetBed);

                // Determine planting method
                const plantingMethod = p.Planting_Method || p.planting_method || 'Transplant';

                // Parse ALL dates - store raw values for editing
                const planGHSow = parseFlexibleDate(p.Plan_GH_Sow || p.plan_gh_sow);
                const actGHSow = parseFlexibleDate(p.Act_GH_Sow || p.act_gh_sow);
                const planFieldSow = parseFlexibleDate(p.Plan_Field_Sow || p.plan_field_sow);
                const actFieldSow = parseFlexibleDate(p.Act_Field_Sow || p.act_field_sow);
                const planTransplant = parseFlexibleDate(p.Plan_Transplant || p.plan_transplant);
                const actTransplant = parseFlexibleDate(p.Act_Transplant || p.act_transplant);
                const firstHarvest = parseFlexibleDate(p.First_Harvest || p.first_harvest);
                let lastHarvest = parseFlexibleDate(p.Last_Harvest || p.last_harvest);

                // Determine field start date based on planting method
                let fieldStartDate;
                if (plantingMethod === 'Direct Seed') {
                    fieldStartDate = actFieldSow || planFieldSow;
                } else {
                    fieldStartDate = actTransplant || planTransplant;
                }

                // Get crop and variety
                const crop = p.Crop || p.crop || 'Unknown';
                const variety = p.Variety || p.variety || '';

                // Estimate missing dates if possible instead of skipping
                if (!fieldStartDate && !lastHarvest) {
                    // Both dates missing - skip this entry
                    return null;
                }

                // If only field start is missing, estimate from harvest date minus typical DTM
                if (!fieldStartDate && lastHarvest) {
                    const estStart = new Date(lastHarvest);
                    estStart.setDate(estStart.getDate() - 60); // Default 60 day crop
                    fieldStartDate = estStart.toISOString().split('T')[0];
                }

                // If only harvest is missing, estimate from field start plus typical DTM
                if (fieldStartDate && !lastHarvest) {
                    const estEnd = new Date(fieldStartDate);
                    estEnd.setDate(estEnd.getDate() + 60); // Default 60 day crop
                    lastHarvest = estEnd.toISOString().split('T')[0];
                }

                // Calculate days between key dates for proportional adjustments
                const ghSowDate = actGHSow || planGHSow;
                const daysGHToField = ghSowDate ? daysBetween(ghSowDate, fieldStartDate) : 0;
                const daysFieldToHarvest = daysBetween(fieldStartDate, lastHarvest);

                // Determine if locked (already sown in GH or field)
                const isLocked = !!(actGHSow || actFieldSow || actTransplant);
                const lockReason = actGHSow ? 'GH Sown' : actFieldSow ? 'Field Sown' : actTransplant ? 'Transplanted' : null;

                return {
                    id: p.Batch_ID || p.batch_id || p.ID || p.id || `planting-${index}`,
                    crop: crop,
                    variety: variety,
                    plantingMethod: plantingMethod,

                    // All dates stored for cascade updates
                    planGHSow: ghSowDate,
                    actGHSow: actGHSow,
                    planFieldSow: planFieldSow,
                    actFieldSow: actFieldSow,
                    planTransplant: planTransplant,
                    actTransplant: actTransplant,
                    firstHarvest: firstHarvest,
                    lastHarvest: lastHarvest,

                    // Calculated field dates for Gantt display
                    fieldStartDate: fieldStartDate,
                    harvestDate: lastHarvest,
                    seedDate: fieldStartDate, // Legacy compatibility

                    // Day offsets for cascade calculations
                    daysGHToField: daysGHToField,
                    daysFieldToHarvest: daysFieldToHarvest,

                    // Locking
                    isLocked: isLocked,
                    lockReason: lockReason,

                    // Field info
                    bed: targetBed,
                    field: field,
                    bedNum: bedNum,
                    isUnassigned: isUnassigned || false,
                    bedFeet: parseInt(p.Bed_Feet || p.Feet_Used || p.feet_used || p.BedFeet || p.bedFeet || 0),
                    status: computeStatus(fieldStartDate, lastHarvest),
                    dtm: daysFieldToHarvest > 0 ? daysFieldToHarvest : 60,
                    trays: parseInt(p.Trays_Needed || p.trays_needed || 0),
                    plants: parseInt(p.Plants_Needed || p.plants_needed || 0),
                    rowIndex: p.rowIndex || index + 2
                };
            }).filter(p => p !== null);
        }

        // Parse dates in various formats: "5/15/2026 20:00:00", "2026-05-15", etc.
        function parseFlexibleDate(dateVal) {
            if (!dateVal) return null;

            // Already a Date object
            if (dateVal instanceof Date) {
                return isNaN(dateVal.getTime()) ? null : dateVal.toISOString().split('T')[0];
            }

            const str = String(dateVal).trim();
            if (!str) return null;

            // Try M/D/YYYY format (Google Sheets format)
            const mdyMatch = str.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})/);
            if (mdyMatch) {
                const [_, month, day, year] = mdyMatch;
                return `${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;
            }

            // Try ISO format YYYY-MM-DD
            const isoMatch = str.match(/^(\d{4})-(\d{2})-(\d{2})/);
            if (isoMatch) {
                return `${isoMatch[1]}-${isoMatch[2]}-${isoMatch[3]}`;
            }

            // Try to parse as Date
            try {
                const d = new Date(str);
                if (!isNaN(d.getTime())) {
                    return d.toISOString().split('T')[0];
                }
            } catch (e) {}

            return null;
        }

        function extractFieldAndBed(targetBed) {
            if (!targetBed) return { field: 'Unassigned', bedNum: '00', isUnassigned: true };

            // FIXED 2026-01-23: Handle "Unassigned" explicitly instead of creating fake "UNA" field
            if (targetBed.toLowerCase() === 'unassigned' || targetBed.toLowerCase() === 'tbd' || targetBed === '') {
                return { field: 'Unassigned', bedNum: '00', isUnassigned: true };
            }

            // Handle "Field F3L-01" format
            const fieldMatch = targetBed.match(/Field\s+([A-Z0-9]+)-?(\d*)/i);
            if (fieldMatch) {
                return {
                    field: fieldMatch[1].toUpperCase(),
                    bedNum: fieldMatch[2] || '01',
                    isUnassigned: false
                };
            }

            // Handle "F3L-01" format (without "Field" prefix)
            const simpleMatch = targetBed.match(/^([A-Z0-9]+)-(\d+)$/i);
            if (simpleMatch) {
                return {
                    field: simpleMatch[1].toUpperCase(),
                    bedNum: simpleMatch[2],
                    isUnassigned: false
                };
            }

            // Fallback - mark as unassigned to avoid creating fake fields
            return { field: 'Unassigned', bedNum: '00', isUnassigned: true };
        }

        function formatDateString(date) {
            if (!date) return new Date().toISOString().split('T')[0];
            if (typeof date === 'string' && date.includes('T')) {
                return date.split('T')[0];
            }
            const d = new Date(date);
            return d.toISOString().split('T')[0];
        }

        function computeStatus(seedDate, harvestDate) {
            const today = new Date();
            const seed = new Date(seedDate);
            const harvest = new Date(harvestDate);
            const harvestEnd = new Date(harvest);
            harvestEnd.setDate(harvestEnd.getDate() + 14);

            if (today < seed) return 'seeding';
            if (today > harvestEnd) return 'completed';
            if (today >= harvest) return 'harvest';
            return 'growing';
        }

        function daysBetween(date1, date2) {
            const d1 = new Date(date1);
            const d2 = new Date(date2);
            return Math.ceil((d2 - d1) / (24 * 60 * 60 * 1000));
        }

        function extractFieldsAndCrops() {
            // Extract unique fields from plantings AND include all default fields
            // FIXED 2026-01-23: Filter out "Unassigned" from regular field list
            const fieldSet = new Set(plantings.map(p => p.field));
            DEFAULT_FIELDS.forEach(f => fieldSet.add(f));
            fields = Array.from(fieldSet)
                .filter(f => f && f !== 'Unassigned' && f !== 'Unknown' && f !== 'UNA')
                .sort();

            // Generate all beds for all fields (using per-field bed count)
            allBeds = [];
            fields.forEach(field => {
                const bedCount = FIELD_CONFIG[field] || 12; // Default to 12 if not configured
                for (let i = 1; i <= bedCount; i++) {
                    const bedNum = String(i).padStart(2, '0');
                    allBeds.push({
                        field: field,
                        bed: `Field ${field}-${bedNum}`,
                        bedNum: bedNum,
                        group: `${field}|Field ${field}-${bedNum}`
                    });
                }
            });

            // Populate crop filter
            const cropSet = new Set(plantings.map(p => p.crop));
            const cropFilter = document.getElementById('cropFilter');
            cropFilter.innerHTML = '<option value="">All Crops</option>';
            Array.from(cropSet).sort().forEach(crop => {
                cropFilter.innerHTML += `<option value="${crop}">${crop}</option>`;
            });

            // Populate field filter
            const fieldFilter = document.getElementById('fieldFilter');
            fieldFilter.innerHTML = '<option value="">All Fields</option>';
            fields.forEach(field => {
                fieldFilter.innerHTML += `<option value="${field}">Field ${field}</option>`;
            });
        }

        // Demo Data - matches actual farm data structure
        function getDemoPlantings() {
            const demoData = [];
            const crops = [
                { name: 'Lettuce', variety: 'Salanova Formula Mix', method: 'Transplant', dtm: 52 },
                { name: 'Kale', variety: 'Black Magic', method: 'Transplant', dtm: 62 },
                { name: 'Kale', variety: 'Winterbor', method: 'Transplant', dtm: 90 },
                { name: 'Broccoli', variety: 'BC1611', method: 'Transplant', dtm: 43 },
                { name: 'Basil', variety: 'Prospera DMR', method: 'Paperpot', dtm: 116 },
                { name: 'Beets', variety: 'Formanova', method: 'Direct Seed', dtm: 52 },
                { name: 'Carrots', variety: 'Bolero', method: 'Direct Seed', dtm: 73 },
                { name: 'Eggplant', variety: 'Nigral', method: 'Transplant', dtm: 72 },
                { name: 'Winter Squash', variety: 'Delicata JS', method: 'Transplant', dtm: 105 },
                { name: 'Fennel', variety: 'Preludio', method: 'Transplant', dtm: 82 }
            ];

            const demoFields = ['F3L', 'HOL', 'IL', 'JL', 'JS1'];
            let id = 1;

            crops.forEach((crop, cropIndex) => {
                const successions = crop.name === 'Lettuce' ? 5 :
                                   crop.name === 'Carrots' ? 4 : 2;

                for (let s = 0; s < successions; s++) {
                    const transplantDate = new Date('2026-04-02');
                    transplantDate.setDate(transplantDate.getDate() + (s * 21) + (cropIndex * 7));

                    const harvestDate = new Date(transplantDate);
                    harvestDate.setDate(harvestDate.getDate() + crop.dtm);

                    const field = demoFields[cropIndex % demoFields.length];
                    const bedNum = ((s % 12) + 1).toString().padStart(2, '0');

                    demoData.push({
                        id: `26-${crop.name.substring(0,3).toUpperCase()}-${String(id++).padStart(4, '0')}`,
                        crop: crop.name,
                        variety: crop.variety,
                        plantingMethod: crop.method,
                        fieldStartDate: transplantDate.toISOString().split('T')[0],
                        harvestDate: harvestDate.toISOString().split('T')[0],
                        seedDate: transplantDate.toISOString().split('T')[0],
                        bed: `Field ${field}-${bedNum}`,
                        field: field,
                        bedNum: bedNum,
                        bedFeet: 200 + Math.floor(Math.random() * 300),
                        status: computeStatus(transplantDate, harvestDate),
                        dtm: crop.dtm
                    });
                }
            });

            return demoData;
        }

        // Apply Filters
        function applyFilters() {
            const cropFilter = document.getElementById('cropFilter').value;
            const fieldFilter = document.getElementById('fieldFilter').value;
            const statusFilters = Array.from(document.querySelectorAll('.checkbox-filter input:checked'))
                                      .map(cb => cb.dataset.status);

            filteredPlantings = plantings.filter(p => {
                if (cropFilter && p.crop !== cropFilter) return false;
                if (fieldFilter && p.field !== fieldFilter) return false;
                if (!statusFilters.includes(p.status)) return false;
                return true;
            });

            // Set fixed timeline for 2026 season (don't auto-calculate - prevents crashes with bad data)
            timelineStart = new Date('2026-01-01');
            timelineEnd = new Date('2026-12-31');

            updateStats();
            renderGantt();
        }

        function updateStats() {
            document.getElementById('totalPlantings').textContent = filteredPlantings.length;
            document.getElementById('activePlantings').textContent = filteredPlantings.filter(p => p.status === 'growing').length;
            document.getElementById('harvestReady').textContent = filteredPlantings.filter(p => p.status === 'harvest').length;
            document.getElementById('totalBedFeet').textContent = filteredPlantings.reduce((sum, p) => sum + (p.bedFeet || 0), 0);
        }

        // Set Zoom Level
        function setZoom(level) {
            zoomLevel = level;
            // dayWidth values: day=30, week=20, month=8, quarter=4, year=2
            const widths = { day: 30, week: 20, month: 8, quarter: 4, year: 2 };
            dayWidth = widths[level] || 20;

            document.querySelectorAll('#zoom-day, #zoom-week, #zoom-month, #zoom-quarter, #zoom-year').forEach(btn => btn.classList.remove('active'));
            document.getElementById(`zoom-${level}`).classList.add('active');

            // For quarter and year views, show full timeline
            if (level === 'quarter' || level === 'year') {
                timelineStart = new Date('2026-01-01');
                timelineEnd = new Date('2026-12-31');
            }

            renderGantt();
            updateRangeDisplay();
        }

        // Set View Mode (field, crop, variety)
        function setViewMode(mode) {
            viewMode = mode;

            // Update button states
            document.querySelectorAll('#view-field, #view-bed, #view-crop, #view-variety').forEach(btn => btn.classList.remove('active'));
            document.getElementById(`view-${mode}`).classList.add('active');

            // Update page title
            const titles = {
                'field': 'Field Calendar',
                'bed': 'Bed Calendar',
                'crop': 'Crop Calendar',
                'variety': 'Variety Calendar'
            };
            document.querySelector('.page-title').innerHTML = `<i class="fas fa-calendar-alt"></i> ${titles[mode] || 'Calendar'}`;

            // Hide unassigned sidebar in crop/variety view (shows ALL plantings including unassigned)
            const unassignedToggle = document.getElementById('unassignedToggle');
            const unassignedPanel = document.getElementById('unassignedPanel');
            if (mode === 'crop' || mode === 'variety') {
                // In crop/variety view, hide sidebar - we show ALL plantings on chart
                if (unassignedToggle) unassignedToggle.style.display = 'none';
                if (unassignedPanel) unassignedPanel.classList.remove('open');
            } else {
                // In field/bed view, show sidebar toggle
                if (unassignedToggle) unassignedToggle.style.display = 'flex';
            }

            renderGantt();
        }

        // Timeline Navigation Functions
        function navigateTimeline(days) {
            timelineStart.setDate(timelineStart.getDate() + days);
            timelineEnd.setDate(timelineEnd.getDate() + days);
            updateSliderPosition();
            renderGantt();
            updateRangeDisplay();
        }

        function onSliderChange(value) {
            const dayOfYear = parseInt(value);
            const yearStart = new Date('2026-01-01');
            timelineStart = new Date(yearStart);
            timelineStart.setDate(timelineStart.getDate() + dayOfYear);

            // Set end date based on view window (quarter and year show full year)
            const viewDaysMap = { day: 30, week: 90, month: 180, quarter: 365, year: 365 };
            const viewDays = viewDaysMap[zoomLevel] || 90;
            timelineEnd = new Date(timelineStart);
            timelineEnd.setDate(timelineEnd.getDate() + viewDays);

            // Cap at end of year
            const yearEnd = new Date('2026-12-31');
            if (timelineEnd > yearEnd) timelineEnd = yearEnd;

            renderGantt();
            updateRangeDisplay();
        }

        function goToToday() {
            const today = new Date();
            // Set timeline to start 2 weeks before today
            timelineStart = new Date(today);
            timelineStart.setDate(timelineStart.getDate() - 14);

            const viewDays = zoomLevel === 'day' ? 30 : zoomLevel === 'week' ? 90 : 180;
            timelineEnd = new Date(timelineStart);
            timelineEnd.setDate(timelineEnd.getDate() + viewDays);

            updateSliderPosition();
            renderGantt();
            updateRangeDisplay();
        }

        function showFullYear() {
            timelineStart = new Date('2026-01-01');
            timelineEnd = new Date('2026-12-31');
            setZoom('year'); // Full year view at smallest zoom
            document.getElementById('timelineSlider').value = 0;
            updateRangeDisplay();
        }

        function updateSliderPosition() {
            const yearStart = new Date('2026-01-01');
            const dayOfYear = Math.floor((timelineStart - yearStart) / (24 * 60 * 60 * 1000));
            document.getElementById('timelineSlider').value = Math.max(0, Math.min(365, dayOfYear));
        }

        function updateRangeDisplay() {
            const options = { month: 'short', day: 'numeric' };
            const startStr = timelineStart.toLocaleDateString('en-US', options);
            const endStr = timelineEnd.toLocaleDateString('en-US', options);
            document.getElementById('currentRange').textContent = `${startStr} - ${endStr}, 2026`;
        }

        // Render Gantt Chart
        function renderGantt() {
            const container = document.getElementById('ganttChart');

            if (filteredPlantings.length === 0) {
                container.innerHTML = `
                    <div class="loading">
                        <i class="fas fa-calendar-times" style="font-size: 3rem; margin-bottom: 1rem; color: var(--text-secondary);"></i>
                        <p>No plantings match your filters</p>
                    </div>
                `;
                return;
            }

            // Get grouping based on view mode
            let groups, headerIcon, headerLabel, getGroupName, getGroupMeta;

            if (viewMode === 'bed' || viewMode === 'field') {
                // Show ALL beds from allBeds array, not just beds with plantings
                // Filter by field if field filter is active
                const fieldFilter = document.getElementById('fieldFilter').value;
                const bedsToShow = fieldFilter
                    ? allBeds.filter(b => b.field === fieldFilter)
                    : allBeds;

                groups = bedsToShow.map(b => b.group);
                headerIcon = viewMode === 'field' ? 'fa-map' : 'fa-th';
                headerLabel = viewMode === 'field' ? 'Fields & Beds' : 'Beds';
                getGroupName = (group) => {
                    const [field, bed] = group.split('|');
                    // Handle both "Field F3L-01" and just "01" formats
                    const bedDisplay = bed.includes('Field') ? bed.replace('Field ', '') : `${field}-${bed}`;
                    return bedDisplay;
                };
                getGroupMeta = (plantings) => plantings.length > 0 ? `${plantings.length} plantings` : 'Empty';
            } else if (viewMode === 'crop') {
                // CROP VIEW: Include ALL plantings (assigned + unassigned) to see full picture
                const allPlantingsForCropView = plantings.filter(p => {
                    const cropFilter = document.getElementById('cropFilter').value;
                    if (cropFilter && p.crop !== cropFilter) return false;
                    return true;
                });
                groups = [...new Set(allPlantingsForCropView.map(p => p.crop))].filter(c => c).sort();
                headerIcon = 'fa-seedling';
                headerLabel = 'Crops';
                getGroupName = (group) => group;
                getGroupMeta = (groupPlantings) => {
                    const unassignedCount = groupPlantings.filter(p => p.isUnassigned).length;
                    return unassignedCount > 0
                        ? `${groupPlantings.length} plantings (${unassignedCount} unassigned)`
                        : `${groupPlantings.length} plantings`;
                };
                // Override filteredPlantings for crop view
                filteredPlantings = allPlantingsForCropView;
            } else if (viewMode === 'variety') {
                // VARIETY VIEW: Include ALL plantings (assigned + unassigned) to see full picture
                const allPlantingsForVarietyView = plantings.filter(p => {
                    const cropFilter = document.getElementById('cropFilter').value;
                    if (cropFilter && p.crop !== cropFilter) return false;
                    return true;
                });
                groups = [...new Set(allPlantingsForVarietyView.map(p => `${p.crop}|${p.variety || 'Unknown'}`))].filter(v => v).sort();
                headerIcon = 'fa-leaf';
                headerLabel = 'Varieties';
                getGroupName = (group) => {
                    const [crop, variety] = group.split('|');
                    return `${crop} - ${variety}`;
                };
                getGroupMeta = (groupPlantings) => {
                    const unassignedCount = groupPlantings.filter(p => p.isUnassigned).length;
                    return unassignedCount > 0
                        ? `${groupPlantings.length} successions (${unassignedCount} unassigned)`
                        : `${groupPlantings.length} successions`;
                };
                // Override filteredPlantings for variety view
                filteredPlantings = allPlantingsForVarietyView;
            } else {
                // Default: field view
                groups = [...new Set(filteredPlantings.map(p => p.field))].sort();
                headerIcon = 'fa-map';
                headerLabel = 'Fields';
                getGroupName = (group) => `Field ${group}`;
                getGroupMeta = (plantings) => `${plantings.length} plantings`;
            }

            // Calculate timeline
            const totalDays = Math.ceil((timelineEnd - timelineStart) / (24 * 60 * 60 * 1000));
            const timelineWidth = totalDays * dayWidth;

            // Build labels HTML and rows HTML separately
            let labelsHtml = '';
            let rowsHtml = '';
            const rowHeights = [];

            // Render rows based on view mode
            groups.forEach((group, index) => {
                let groupPlantings;
                let isEmpty = false;

                if (viewMode === 'bed' || viewMode === 'field') {
                    // Both field and bed view show individual beds
                    const [field, bed] = group.split('|');
                    groupPlantings = filteredPlantings.filter(p => {
                        const pBed = p.bed || p.Bed || p.bedNumber || '1';
                        // Handle "Field F3L-01" format from allBeds
                        return p.field === field && (pBed === bed || `Field ${p.field}-${pBed.toString().padStart(2,'0')}` === bed);
                    });
                    isEmpty = groupPlantings.length === 0;
                } else if (viewMode === 'crop') {
                    groupPlantings = filteredPlantings.filter(p => p.crop === group);
                } else if (viewMode === 'variety') {
                    const [crop, variety] = group.split('|');
                    groupPlantings = filteredPlantings.filter(p => p.crop === crop && (p.variety || 'Unknown') === variety);
                } else {
                    groupPlantings = filteredPlantings.filter(p => p.field === group);
                }

                const stackedPlantings = calculateStacking(groupPlantings);
                const rowHeight = Math.max(50, (stackedPlantings.maxStack + 1) * 44);
                rowHeights.push(rowHeight);

                const emptyClass = isEmpty ? ' empty-bed' : '';

                // Label for left column
                labelsHtml += `
                    <div class="gantt-label${emptyClass}" style="height: ${rowHeight}px;">
                        <div class="field-name">${getGroupName(group)}</div>
                        <div class="field-meta">${getGroupMeta(groupPlantings)}</div>
                    </div>
                `;

                // Content row - store field and bed info for drop targeting
                const [rowField, rowBed] = group.split('|');
                rowsHtml += `
                    <div class="gantt-row${emptyClass}" data-group="${group}" data-field="${rowField}" data-bed="${rowBed}" style="height: ${rowHeight}px; width: ${timelineWidth}px;">
                        <div class="timeline-grid">
                            ${generateGridLines(totalDays)}
                        </div>
                        ${isEmpty ? '' : renderGaps(groupPlantings, getGroupName(group))}
                        ${renderTodayLine(totalDays)}
                        ${renderCropBars(stackedPlantings.plantings, group)}
                    </div>
                `;
            });

            // Build the grid structure
            container.innerHTML = `
                <!-- Corner cell -->
                <div class="gantt-corner">
                    <i class="fas ${headerIcon}"></i> ${headerLabel}
                </div>

                <!-- Header row (date headers) -->
                <div class="gantt-header-scroll" id="headerScroll">
                    <div class="gantt-header-inner" style="width: ${timelineWidth}px;">
                        <div class="gantt-months-row">
                            ${generateMonthHeaders(totalDays)}
                        </div>
                        <div class="gantt-days-row">
                            ${generateDayHeaders(totalDays)}
                        </div>
                    </div>
                </div>

                <!-- Labels column (field/bed names) -->
                <div class="gantt-labels-scroll" id="labelsScroll">
                    ${labelsHtml}
                </div>

                <!-- Main content area -->
                <div class="gantt-content-scroll" id="contentScroll">
                    <div class="gantt-content-inner" style="width: ${timelineWidth}px;">
                        ${rowsHtml}
                    </div>
                </div>
            `;

            // Set up synchronized scrolling
            setupScrollSync();

            // Initialize drag and resize
            initializeInteractions();

            // Setup drop zones for unassigned plantings (after gantt is rendered)
            setTimeout(() => setupGanttDropZones(), 100);
        }

        // Synchronized scrolling for sticky headers
        function setupScrollSync() {
            const contentScroll = document.getElementById('contentScroll');
            const headerScroll = document.getElementById('headerScroll');
            const labelsScroll = document.getElementById('labelsScroll');

            if (!contentScroll || !headerScroll || !labelsScroll) return;

            contentScroll.addEventListener('scroll', function() {
                // Sync horizontal scroll with header
                headerScroll.scrollLeft = contentScroll.scrollLeft;
                // Sync vertical scroll with labels
                labelsScroll.scrollTop = contentScroll.scrollTop;
            });
        }

        function generateMonthHeaders(totalDays) {
            let html = '';
            let currentDate = new Date(timelineStart);

            while (currentDate <= timelineEnd) {
                const monthStart = new Date(currentDate);
                const monthEnd = new Date(currentDate.getFullYear(), currentDate.getMonth() + 1, 0);
                const daysInView = Math.min(
                    Math.ceil((monthEnd - monthStart) / (24 * 60 * 60 * 1000)) + 1,
                    Math.ceil((timelineEnd - monthStart) / (24 * 60 * 60 * 1000)) + 1
                );

                const width = daysInView * dayWidth;
                const label = currentDate.toLocaleDateString('en-US', { month: 'short', year: '2-digit' });

                html += `<div class="gantt-month" style="width: ${width}px;">${label}</div>`;

                currentDate.setMonth(currentDate.getMonth() + 1);
                currentDate.setDate(1);
            }

            return html;
        }

        function generateDayHeaders(totalDays) {
            let html = '';
            const today = new Date();
            today.setHours(0, 0, 0, 0);

            for (let i = 0; i < totalDays; i++) {
                const date = new Date(timelineStart);
                date.setDate(date.getDate() + i);

                const isToday = date.getTime() === today.getTime();
                const isWeekend = date.getDay() === 0 || date.getDay() === 6;

                let label = '';
                if (zoomLevel === 'day') {
                    label = date.getDate();
                } else if (zoomLevel === 'week') {
                    if (date.getDay() === 1 || i === 0) {
                        label = date.getDate();
                    }
                } else {
                    if (date.getDate() === 1 || date.getDate() === 15) {
                        label = date.getDate();
                    }
                }

                const classes = ['gantt-day'];
                if (isToday) classes.push('today');
                if (isWeekend) classes.push('weekend');

                html += `<div class="${classes.join(' ')}" style="width: ${dayWidth}px;">${label}</div>`;
            }

            return html;
        }

        function generateGridLines(totalDays) {
            let html = '';
            for (let i = 0; i < totalDays; i++) {
                const date = new Date(timelineStart);
                date.setDate(date.getDate() + i);
                const isWeekStart = date.getDay() === 1;
                html += `<div class="grid-line ${isWeekStart ? 'week-start' : ''}" style="width: ${dayWidth}px;"></div>`;
            }
            return html;
        }

        function renderTodayLine(totalDays) {
            const today = new Date();
            if (today < timelineStart || today > timelineEnd) return '';

            const dayOffset = Math.ceil((today - timelineStart) / (24 * 60 * 60 * 1000));
            const left = dayOffset * dayWidth;

            return `
                <div class="today-line" style="left: ${left}px;">
                    <div class="today-marker">TODAY</div>
                </div>
            `;
        }

        function calculateStacking(fieldPlantings) {
            // Sort by start date
            const sorted = [...fieldPlantings].sort((a, b) => new Date(a.seedDate) - new Date(b.seedDate));

            const stacks = [];
            let maxStack = 0;

            sorted.forEach(planting => {
                const start = new Date(planting.seedDate);
                const end = new Date(planting.harvestDate);

                // Find the lowest stack level that doesn't overlap
                let stackLevel = 0;
                for (let i = 0; i < stacks.length; i++) {
                    const lastEnd = stacks[i];
                    if (start >= lastEnd) {
                        stackLevel = i;
                        break;
                    }
                    stackLevel = i + 1;
                }

                // Update the stack end date
                stacks[stackLevel] = end;
                planting.stackLevel = stackLevel;
                maxStack = Math.max(maxStack, stackLevel);
            });

            return { plantings: sorted, maxStack };
        }

        function renderCropBars(fieldPlantings, field) {
            let html = '';

            fieldPlantings.forEach(planting => {
                const startDate = new Date(planting.fieldStartDate || planting.seedDate);
                const endDate = new Date(planting.harvestDate);

                const startOffset = Math.max(0, (startDate - timelineStart) / (24 * 60 * 60 * 1000));
                const duration = Math.ceil((endDate - startDate) / (24 * 60 * 60 * 1000));

                const left = startOffset * dayWidth;
                const width = Math.max(duration * dayWidth, 60);
                const top = 8 + (planting.stackLevel * 44);

                const icon = cropIcons[planting.crop] || 'üå±';

                // Build display text - show variety if bar is wide enough
                const displayText = width > 120
                    ? `${planting.crop} - ${planting.variety}`
                    : planting.crop;

                // Add locked class if already sown
                const lockedClass = planting.isLocked ? 'locked' : '';
                const lockIcon = planting.isLocked ? 'üîí ' : '';

                // Add unassigned class for visual differentiation
                const unassignedClass = planting.isUnassigned ? 'unassigned' : '';
                const unassignedIcon = planting.isUnassigned ? '‚ö†Ô∏è ' : '';

                // Get crop color - from API profiles, fallback to default colors
                const cropColor = getCropColor(planting.crop);
                const barStyle = cropColor
                    ? `background: linear-gradient(135deg, ${cropColor} 0%, ${lightenColor(cropColor, 20)} 100%);`
                    : '';

                // Add dashed border for unassigned plantings
                const unassignedStyle = planting.isUnassigned
                    ? 'border: 2px dashed rgba(255,255,255,0.8); box-shadow: 0 0 8px rgba(244, 162, 97, 0.5);'
                    : '';

                // Add opacity for completed status
                const completedStyle = planting.status === 'completed' ? 'opacity: 0.6;' : '';

                html += `
                    <div class="crop-bar ${lockedClass} ${unassignedClass}"
                         id="bar-${planting.id}"
                         data-id="${planting.id}"
                         data-field="${planting.field}"
                         data-crop="${planting.crop}"
                         data-locked="${planting.isLocked}"
                         data-start="${planting.fieldStartDate || planting.seedDate}"
                         data-end="${planting.harvestDate}"
                         style="left: ${left}px; width: ${width}px; top: ${top}px; ${barStyle} ${completedStyle} ${unassignedStyle} cursor: pointer;"
                         ondblclick="openEditModal('${planting.id}')"
                         onmouseenter="showTooltip(event, '${planting.id}')"
                         onmouseleave="hideTooltip()">
                        <div class="resize-handle resize-handle-left" data-edge="left"></div>
                        <span class="crop-bar-icon">${unassignedIcon}${lockIcon}${icon}</span>
                        <div class="crop-bar-content">
                            <div class="crop-bar-name">${displayText}</div>
                            <div class="crop-bar-dates">${planting.variety ? planting.variety.substring(0, 15) : ''} ${planting.dtm}d</div>
                        </div>
                        <div class="resize-handle resize-handle-right" data-edge="right"></div>
                    </div>
                `;
            });

            return html;
        }

        // Render gaps (empty spaces) between plantings
        function renderGaps(fieldPlantings, groupName) {
            let html = '';

            // Escape group name for use in HTML/JS
            const safeGroupName = (groupName || '').replace(/'/g, "\\'").replace(/"/g, '&quot;');

            // Sort plantings by field start date
            const sorted = [...fieldPlantings].sort((a, b) => {
                const aStart = new Date(a.fieldStartDate || a.seedDate);
                const bStart = new Date(b.fieldStartDate || b.seedDate);
                return aStart - bStart;
            });

            // Find gaps
            const gaps = [];
            const seasonStart = new Date(timelineStart);
            const seasonEnd = new Date(timelineEnd);

            // Check for gap at the beginning of timeline
            if (sorted.length > 0) {
                const firstPlanting = sorted[0];
                const firstStart = new Date(firstPlanting.fieldStartDate || firstPlanting.seedDate);
                if (firstStart > seasonStart) {
                    const gapDays = Math.floor((firstStart - seasonStart) / (24 * 60 * 60 * 1000));
                    if (gapDays >= 7) {
                        gaps.push({
                            start: new Date(seasonStart),
                            end: new Date(firstStart),
                            type: 'before'
                        });
                    }
                }
            } else {
                // No plantings - entire timeline is a gap
                gaps.push({
                    start: new Date(seasonStart),
                    end: new Date(seasonEnd),
                    type: 'empty'
                });
            }

            // Check for gaps between plantings (non-overlapping)
            for (let i = 0; i < sorted.length - 1; i++) {
                const current = sorted[i];
                const next = sorted[i + 1];
                const currentEnd = new Date(current.harvestDate || current.lastHarvest || current.fieldStartDate);
                const nextStart = new Date(next.fieldStartDate || next.seedDate);

                // If there's a gap of at least 7 days
                if (!isNaN(currentEnd.getTime()) && !isNaN(nextStart.getTime())) {
                    const gapDays = Math.floor((nextStart - currentEnd) / (24 * 60 * 60 * 1000));
                    if (gapDays >= 7) {
                        gaps.push({
                            start: new Date(currentEnd),
                            end: new Date(nextStart),
                            type: 'between'
                        });
                    }
                }
            }

            // Check for gap at the end of timeline
            if (sorted.length > 0) {
                const lastPlanting = sorted[sorted.length - 1];
                const lastEnd = new Date(lastPlanting.harvestDate || lastPlanting.lastHarvest || lastPlanting.fieldStartDate);
                if (!isNaN(lastEnd.getTime()) && lastEnd < seasonEnd) {
                    const gapDays = Math.floor((seasonEnd - lastEnd) / (24 * 60 * 60 * 1000));
                    if (gapDays >= 7) {
                        gaps.push({
                            start: new Date(lastEnd),
                            end: new Date(seasonEnd),
                            type: 'after'
                        });
                    }
                }
            }

            // Render gap indicators
            gaps.forEach((gap, index) => {
                const startOffset = Math.max(0, (gap.start - timelineStart) / (24 * 60 * 60 * 1000));
                const gapDuration = Math.ceil((gap.end - gap.start) / (24 * 60 * 60 * 1000));

                // Only show gaps that are visible in the timeline and have width
                if (startOffset >= 0 && gapDuration > 0) {
                    const left = startOffset * dayWidth;
                    const width = Math.max(gapDuration * dayWidth, 20); // Minimum 20px width for clickability

                    // Format dates for data attributes
                    const startStr = gap.start.toISOString().split('T')[0];
                    const endStr = gap.end.toISOString().split('T')[0];

                    html += `
                        <div class="field-gap"
                             data-group="${safeGroupName}"
                             data-start="${startStr}"
                             data-end="${endStr}"
                             data-days="${gapDuration}"
                             style="left: ${left}px; width: ${width}px;"
                             onmouseenter="showGapTooltip(event, '${safeGroupName}', '${startStr}', '${endStr}', ${gapDuration})"
                             onmousemove="moveGapTooltip(event)"
                             onmouseleave="hideGapTooltip()">
                        </div>
                    `;
                }
            });

            return html;
        }

        // Gap tooltip functions
        function showGapTooltip(event, groupName, startDate, endDate, days) {
            const tooltip = document.getElementById('gapTooltip');

            // Format dates nicely
            const start = new Date(startDate);
            const end = new Date(endDate);
            const startStr = start.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
            const endStr = end.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });

            document.getElementById('gapDuration').textContent = `${days} days`;
            document.getElementById('gapDateRange').textContent = `${startStr} - ${endStr}`;
            document.getElementById('gapField').textContent = groupName;

            // Position tooltip
            tooltip.style.left = (event.clientX + 15) + 'px';
            tooltip.style.top = (event.clientY + 15) + 'px';
            tooltip.classList.add('visible');
        }

        function moveGapTooltip(event) {
            const tooltip = document.getElementById('gapTooltip');
            tooltip.style.left = (event.clientX + 15) + 'px';
            tooltip.style.top = (event.clientY + 15) + 'px';
        }

        function hideGapTooltip() {
            document.getElementById('gapTooltip').classList.remove('visible');
        }

        // Get crop color from profiles or fallback
        function getCropColor(cropName) {
            // First check API-loaded colors
            if (cropProfileColors[cropName]) {
                return cropProfileColors[cropName];
            }
            // Then check default colors
            if (cropColors[cropName]) {
                return cropColors[cropName];
            }
            // Default fallback
            return '#2d5a27';
        }

        // Lighten a hex color by a percentage
        function lightenColor(hex, percent) {
            const num = parseInt(hex.replace('#', ''), 16);
            const amt = Math.round(2.55 * percent);
            const R = Math.min(255, (num >> 16) + amt);
            const G = Math.min(255, ((num >> 8) & 0x00FF) + amt);
            const B = Math.min(255, (num & 0x0000FF) + amt);
            return '#' + (0x1000000 + R * 0x10000 + G * 0x100 + B).toString(16).slice(1);
        }

        // Track current drag state for date display
        let currentDragPlanting = null;

        // Initialize Drag and Resize with interact.js
        function initializeInteractions() {
            interact('.crop-bar:not(.locked)')
                .draggable({
                    inertia: false,
                    modifiers: [
                        interact.modifiers.restrictRect({
                            restriction: '.gantt-body',
                            endOnly: true
                        })
                    ],
                    autoScroll: true,
                    listeners: {
                        start(event) {
                            // Double-check not locked
                            if (event.target.dataset.locked === 'true') {
                                showToast('This planting is locked (already sown)', 'error');
                                return false;
                            }
                            event.target.classList.add('dragging');
                            hideTooltip();

                            // Setup drag tooltip
                            const id = event.target.dataset.id;
                            currentDragPlanting = plantings.find(p => p.id === id);

                            // Create ghost at original position (only if not already moved)
                            if (!originalPositions.has(id)) {
                                createGhost(id, event.target);
                            }

                            if (currentDragPlanting) {
                                showDragTooltip(event, currentDragPlanting);
                            }
                        },
                        move(event) {
                            const target = event.target;
                            const x = (parseFloat(target.getAttribute('data-x')) || parseFloat(target.style.left)) + event.dx;
                            const y = (parseFloat(target.getAttribute('data-y')) || parseFloat(target.style.top)) + event.dy;

                            target.style.left = `${x}px`;
                            target.style.top = `${y}px`;
                            target.setAttribute('data-x', x);
                            target.setAttribute('data-y', y);

                            // Highlight drop target row
                            const dropTarget = getRowAtPosition(event.clientY);
                            document.querySelectorAll('.gantt-row').forEach(el => el.classList.remove('drop-target'));
                            if (dropTarget) dropTarget.classList.add('drop-target');

                            // Update real-time date display
                            if (currentDragPlanting) {
                                updateDragTooltip(event, x);
                            }
                        },
                        end(event) {
                            event.target.classList.remove('dragging');
                            document.querySelectorAll('.gantt-row').forEach(el => el.classList.remove('drop-target'));
                            hideDragTooltip();

                            const target = event.target;
                            const id = target.dataset.id;
                            const newLeft = parseFloat(target.style.left);

                            // Calculate new start date from position
                            const daysFromStart = Math.round(newLeft / dayWidth);
                            const newStartDate = new Date(timelineStart);
                            newStartDate.setDate(newStartDate.getDate() + daysFromStart);

                            // Check for row change (field + bed)
                            const dropTargetRow = getRowAtPosition(event.clientY);
                            let newField = target.dataset.field;
                            let newBed = null;

                            if (dropTargetRow) {
                                newField = dropTargetRow.dataset.field;
                                newBed = dropTargetRow.dataset.bed; // e.g., "Field F3L-01"

                                // If dropping to a different row, move the element to that row
                                const currentRow = target.closest('.gantt-row');
                                if (currentRow && currentRow !== dropTargetRow) {
                                    // Move the bar element to the new row
                                    dropTargetRow.appendChild(target);
                                    // Reset Y position since we moved to new row
                                    target.style.top = '4px';
                                    target.setAttribute('data-y', '4');
                                }
                            }

                            // Mark as moved
                            target.classList.add('moved');

                            // Update planting with date cascade (no re-render!)
                            updatePlantingDates(id, newStartDate, null, newField, newBed);
                            currentDragPlanting = null;
                        }
                    }
                })
                .resizable({
                    edges: { left: '.resize-handle-left', right: '.resize-handle-right' },
                    listeners: {
                        start(event) {
                            if (event.target.dataset.locked === 'true') {
                                showToast('This planting is locked (already sown)', 'error');
                                return false;
                            }
                            event.target.classList.add('resizing');
                            hideTooltip();

                            // Setup drag tooltip for resize
                            const id = event.target.dataset.id;
                            currentDragPlanting = plantings.find(p => p.id === id);
                            if (currentDragPlanting) {
                                showDragTooltip(event, currentDragPlanting);
                            }
                        },
                        move(event) {
                            const target = event.target;
                            let x = parseFloat(target.style.left) || 0;
                            let width = event.rect.width;

                            // Handle left edge resize
                            if (event.edges.left) {
                                x += event.deltaRect.left;
                            }

                            target.style.width = `${width}px`;
                            target.style.left = `${x}px`;

                            // Update real-time date display for resize
                            if (currentDragPlanting) {
                                updateResizeTooltip(event, x, width);
                            }
                        },
                        end(event) {
                            event.target.classList.remove('resizing');
                            hideDragTooltip();

                            const target = event.target;
                            const id = target.dataset.id;
                            const left = parseFloat(target.style.left);
                            const width = parseFloat(target.style.width);

                            // Calculate new dates
                            const startDays = Math.round(left / dayWidth);
                            const durationDays = Math.round(width / dayWidth);

                            const newStartDate = new Date(timelineStart);
                            newStartDate.setDate(newStartDate.getDate() + startDays);

                            const newEndDate = new Date(newStartDate);
                            newEndDate.setDate(newEndDate.getDate() + durationDays);

                            updatePlantingDates(id, newStartDate, newEndDate, null);
                            currentDragPlanting = null;
                        }
                    },
                    modifiers: [
                        interact.modifiers.restrictSize({
                            min: { width: 40 }
                        })
                    ]
                });

            // Add click handler for locked bars
            document.querySelectorAll('.crop-bar.locked').forEach(bar => {
                bar.addEventListener('click', () => {
                    showToast('Locked: Already sown. Confirm termination to unlock.', 'warning');
                });
            });
        }

        // Show drag tooltip with current planting info
        function showDragTooltip(event, planting) {
            const tooltip = document.getElementById('dragTooltip');
            document.getElementById('dragCrop').textContent = `${planting.crop} - ${planting.variety}`;

            // Show GH sow row only if applicable
            const ghRow = document.getElementById('dragGHSow').parentElement;
            if (planting.planGHSow && planting.plantingMethod !== 'Direct Seed') {
                ghRow.style.display = 'flex';
                document.getElementById('dragGHSow').textContent = formatShortDate(planting.planGHSow);
            } else {
                ghRow.style.display = 'none';
            }

            document.getElementById('dragFieldStart').textContent = formatShortDate(planting.fieldStartDate);
            document.getElementById('dragHarvest').textContent = formatShortDate(planting.harvestDate);

            tooltip.style.left = (event.clientX + 20) + 'px';
            tooltip.style.top = (event.clientY - 80) + 'px';
            tooltip.classList.add('show');
        }

        // Update drag tooltip with new calculated dates
        function updateDragTooltip(event, newLeft) {
            if (!currentDragPlanting) return;

            const tooltip = document.getElementById('dragTooltip');
            tooltip.style.left = (event.clientX + 20) + 'px';
            tooltip.style.top = (event.clientY - 80) + 'px';

            // Calculate new dates based on position
            const daysFromStart = Math.round(newLeft / dayWidth);
            const newFieldStart = new Date(timelineStart);
            newFieldStart.setDate(newFieldStart.getDate() + daysFromStart);

            // Calculate day shift
            const oldFieldStart = new Date(currentDragPlanting.fieldStartDate);
            const dayShift = Math.round((newFieldStart - oldFieldStart) / (24 * 60 * 60 * 1000));

            // Calculate cascaded dates
            let newGHSow = null;
            if (currentDragPlanting.planGHSow) {
                const oldGH = new Date(currentDragPlanting.planGHSow);
                newGHSow = new Date(oldGH);
                newGHSow.setDate(newGHSow.getDate() + dayShift);
            }

            const oldHarvest = new Date(currentDragPlanting.harvestDate);
            const newHarvest = new Date(oldHarvest);
            newHarvest.setDate(newHarvest.getDate() + dayShift);

            // Update display with highlight for changed dates
            const fieldEl = document.getElementById('dragFieldStart');
            const harvestEl = document.getElementById('dragHarvest');
            const ghEl = document.getElementById('dragGHSow');

            fieldEl.textContent = formatShortDate(newFieldStart.toISOString().split('T')[0]);
            harvestEl.textContent = formatShortDate(newHarvest.toISOString().split('T')[0]);

            if (newGHSow) {
                ghEl.textContent = formatShortDate(newGHSow.toISOString().split('T')[0]);
            }

            // Add changed class if dates are different
            if (dayShift !== 0) {
                fieldEl.classList.add('changed');
                harvestEl.classList.add('changed');
                if (newGHSow) ghEl.classList.add('changed');
            } else {
                fieldEl.classList.remove('changed');
                harvestEl.classList.remove('changed');
                ghEl.classList.remove('changed');
            }
        }

        // Update tooltip for resize operations
        function updateResizeTooltip(event, newLeft, newWidth) {
            if (!currentDragPlanting) return;

            const tooltip = document.getElementById('dragTooltip');
            tooltip.style.left = (event.clientX + 20) + 'px';
            tooltip.style.top = (event.clientY - 80) + 'px';

            // Calculate new dates
            const startDays = Math.round(newLeft / dayWidth);
            const durationDays = Math.round(newWidth / dayWidth);

            const newFieldStart = new Date(timelineStart);
            newFieldStart.setDate(newFieldStart.getDate() + startDays);

            const newHarvest = new Date(newFieldStart);
            newHarvest.setDate(newHarvest.getDate() + durationDays);

            // Calculate GH sow if start date changed
            const oldFieldStart = new Date(currentDragPlanting.fieldStartDate);
            const dayShift = Math.round((newFieldStart - oldFieldStart) / (24 * 60 * 60 * 1000));

            let newGHSow = null;
            if (currentDragPlanting.planGHSow) {
                const oldGH = new Date(currentDragPlanting.planGHSow);
                newGHSow = new Date(oldGH);
                newGHSow.setDate(newGHSow.getDate() + dayShift);
            }

            // Update display
            const fieldEl = document.getElementById('dragFieldStart');
            const harvestEl = document.getElementById('dragHarvest');
            const ghEl = document.getElementById('dragGHSow');

            fieldEl.textContent = formatShortDate(newFieldStart.toISOString().split('T')[0]);
            harvestEl.textContent = formatShortDate(newHarvest.toISOString().split('T')[0]);

            if (newGHSow) {
                ghEl.textContent = formatShortDate(newGHSow.toISOString().split('T')[0]);
            }

            // Highlight changes
            fieldEl.classList.add('changed');
            harvestEl.classList.add('changed');
            if (newGHSow) ghEl.classList.add('changed');
        }

        function hideDragTooltip() {
            document.getElementById('dragTooltip').classList.remove('show');
        }

        function formatShortDate(dateStr) {
            if (!dateStr) return '-';
            const date = new Date(dateStr);
            return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
        }

        // Format date for Google Sheets (M/D/YYYY format)
        function formatDateForSheet(dateStr) {
            if (!dateStr) return '';
            try {
                const date = new Date(dateStr);
                if (isNaN(date.getTime())) return dateStr; // Return as-is if invalid
                const month = date.getMonth() + 1;
                const day = date.getDate();
                const year = date.getFullYear();
                return `${month}/${day}/${year}`;
            } catch (e) {
                return dateStr; // Return as-is if error
            }
        }

        function getFieldAtPosition(clientY) {
            const fieldRows = document.querySelectorAll('.field-timeline');
            for (const row of fieldRows) {
                const rect = row.getBoundingClientRect();
                if (clientY >= rect.top && clientY <= rect.bottom) {
                    return row;
                }
            }
            return null;
        }

        // Get the gantt row at a Y position (for drop targeting)
        function getRowAtPosition(clientY) {
            const rows = document.querySelectorAll('.gantt-row');
            for (const row of rows) {
                const rect = row.getBoundingClientRect();
                if (clientY >= rect.top && clientY <= rect.bottom) {
                    return row;
                }
            }
            return null;
        }

        // Create a ghost element at the original position of a dragged planting
        function createGhost(plantingId, element) {
            // Don't create duplicate ghosts
            if (ghostElements.has(plantingId)) return;

            const rect = element.getBoundingClientRect();
            const parentRect = element.parentElement.getBoundingClientRect();

            // Store original position info
            const planting = plantings.find(p => p.id === plantingId);
            if (!planting) return;

            originalPositions.set(plantingId, {
                field: planting.field,
                bed: planting.bed,
                fieldStartDate: planting.fieldStartDate,
                left: parseFloat(element.style.left),
                top: parseFloat(element.style.top) || 0,
                rowGroup: element.closest('.gantt-row')?.dataset.group
            });

            // Create ghost element
            const ghost = document.createElement('div');
            ghost.className = 'crop-bar-ghost';
            ghost.style.cssText = `
                left: ${element.style.left};
                top: ${element.style.top || '0px'};
                width: ${element.style.width};
                height: ${element.offsetHeight}px;
                background-color: ${element.style.backgroundColor};
            `;
            ghost.dataset.ghostFor = plantingId;

            // Insert ghost into the same parent
            element.parentElement.appendChild(ghost);
            ghostElements.set(plantingId, ghost);
        }

        // Clear all ghost elements (called on submit or discard)
        function clearAllGhosts() {
            ghostElements.forEach((ghost, id) => {
                ghost.remove();
            });
            ghostElements.clear();
            originalPositions.clear();

            // Remove 'moved' class from all bars
            document.querySelectorAll('.crop-bar.moved').forEach(bar => {
                bar.classList.remove('moved');
            });
        }

        // Update Planting Dates
        // CASCADE ALL DATES when field start changes
        function updatePlantingDates(id, newFieldStartDate, newEndDate, newField, newBed = null) {
            const planting = plantings.find(p => p.id === id);
            if (!planting) return;

            // Check if locked
            if (planting.isLocked) {
                showToast(`Cannot move: ${planting.lockReason}`, 'error');
                // Snap back by re-rendering just this element would be complex,
                // for locked items we do need to re-render to restore position
                applyFilters();
                return;
            }

            const oldFieldStart = new Date(planting.fieldStartDate);
            const oldHarvest = new Date(planting.harvestDate);

            // Calculate shift in days
            let dayShift = 0;
            if (newFieldStartDate) {
                dayShift = Math.round((newFieldStartDate - oldFieldStart) / (24 * 60 * 60 * 1000));
            }

            // --- CASCADE ALL DATES ---

            // 1. Update GH Sow date (shift by same amount)
            if (planting.planGHSow) {
                const oldGHSow = new Date(planting.planGHSow);
                oldGHSow.setDate(oldGHSow.getDate() + dayShift);
                planting.planGHSow = oldGHSow.toISOString().split('T')[0];
            }

            // 2. Update field start date (transplant or field sow)
            if (newFieldStartDate) {
                const newStartStr = newFieldStartDate.toISOString().split('T')[0];
                planting.fieldStartDate = newStartStr;
                planting.seedDate = newStartStr; // Legacy

                if (planting.plantingMethod === 'Direct Seed') {
                    planting.planFieldSow = newStartStr;
                } else {
                    planting.planTransplant = newStartStr;
                }
            }

            // 3. Update First Harvest (shift by same amount if exists)
            if (planting.firstHarvest) {
                const oldFirst = new Date(planting.firstHarvest);
                oldFirst.setDate(oldFirst.getDate() + dayShift);
                planting.firstHarvest = oldFirst.toISOString().split('T')[0];
            }

            // 4. Update Last Harvest
            if (newEndDate) {
                // User explicitly set new end date (resized)
                planting.harvestDate = newEndDate.toISOString().split('T')[0];
                planting.lastHarvest = planting.harvestDate;
            } else {
                // Maintain original duration (dragged)
                const shiftedHarvest = new Date(oldHarvest);
                shiftedHarvest.setDate(shiftedHarvest.getDate() + dayShift);
                planting.harvestDate = shiftedHarvest.toISOString().split('T')[0];
                planting.lastHarvest = planting.harvestDate;
            }

            // Update duration
            planting.dtm = daysBetween(planting.fieldStartDate, planting.harvestDate);
            planting.daysFieldToHarvest = planting.dtm;

            // 5. Update field and bed assignment
            if (newBed) {
                // Full bed was provided (e.g., "Field F3L-01")
                planting.bed = newBed;
                planting.field = newField;
                // Extract bed number
                const bedNumMatch = newBed.match(/(\d+)$/);
                planting.bedNum = bedNumMatch ? bedNumMatch[1] : '01';
            } else if (newField && newField !== planting.field) {
                // Only field changed, preserve bed number
                planting.field = newField;
                const bedNum = planting.bedNum || planting.bed.match(/\d+$/)?.[0] || '01';
                planting.bed = `Field ${newField}-${bedNum}`;
            }

            // Update status
            planting.status = computeStatus(planting.fieldStartDate, planting.harvestDate);

            // Queue for sync to Google Sheets
            queueUpdate(planting);

            // NO re-render - bar is already visually positioned correctly!
            // applyFilters(); // REMOVED - prevents scroll reset

            // Show confirmation with all dates
            const ghSowInfo = planting.planGHSow ? `GH: ${formatDisplayDate(planting.planGHSow)} ‚Üí ` : '';
            const bedInfo = planting.bed ? ` | ${planting.bed}` : '';
            showToast(`${planting.crop}: ${ghSowInfo}Field: ${formatDisplayDate(planting.fieldStartDate)} ‚Üí Harvest: ${formatDisplayDate(planting.harvestDate)}${bedInfo}`, 'success');
        }

        // Queue updates for batch saving
        function queueUpdate(planting) {
            pendingUpdates.set(planting.id, planting);

            // Update pending count display and show submit button
            updatePendingDisplay();
        }

        // Update the pending changes display
        function updatePendingDisplay() {
            const count = pendingUpdates.size;
            const submitBtn = document.getElementById('submitChangesBtn');
            const discardBtn = document.getElementById('discardBtn');
            const pendingCountEl = document.getElementById('pendingCount');

            if (count > 0) {
                submitBtn.classList.add('visible');
                discardBtn.classList.add('visible');
                pendingCountEl.textContent = count;
                setSyncStatus('pending', `${count} pending`);
            } else {
                submitBtn.classList.remove('visible');
                discardBtn.classList.remove('visible');
                setSyncStatus('synced', 'Synced');
            }
        }

        // Discard all pending changes and reload
        function discardChanges() {
            if (pendingUpdates.size === 0 && ghostElements.size === 0) return;

            if (confirm(`Discard ${pendingUpdates.size} pending change(s)? This will reload the calendar.`)) {
                pendingUpdates.clear();
                clearAllGhosts(); // Clear ghost elements
                updatePendingDisplay();
                loadPlantings(); // Reload from server to restore original positions
                showToast('Changes discarded', 'info');
            }
        }

        // Save to Google Sheets - CASCADE ALL DATES
        async function saveToGoogleSheets() {
            if (pendingUpdates.size === 0) return;

            const updates = Array.from(pendingUpdates.values());
            const saveCount = updates.length;
            pendingUpdates.clear();

            // Show saving status
            setSyncStatus('syncing', `Saving ${saveCount}...`);
            document.getElementById('submitChangesBtn').classList.remove('visible');
            document.getElementById('discardBtn').classList.remove('visible');

            try {
                for (const planting of updates) {
                    // Construct proper Target_Bed_ID format
                    const bedNum = planting.bedNum || (planting.bed ? planting.bed.match(/\d+$/)?.[0] : null) || '01';
                    const properBedId = planting.field ? `Field ${planting.field}-${bedNum}` : planting.bed;

                    // Use correct column names from actual sheet structure
                    // CASCADE: Update ALL related dates - auto-format to M/D/YYYY for Google Sheets
                    const updateData = {
                        action: 'updatePlanting',
                        id: planting.id,
                        Batch_ID: planting.id,
                        Target_Bed_ID: properBedId,
                        First_Harvest: formatDateForSheet(planting.firstHarvest),
                        Last_Harvest: formatDateForSheet(planting.harvestDate || planting.lastHarvest)
                    };

                    // Update GH Sow date if it exists
                    if (planting.planGHSow) {
                        updateData.Plan_GH_Sow = formatDateForSheet(planting.planGHSow);
                    }

                    // Update correct field start date based on planting method
                    if (planting.plantingMethod === 'Direct Seed') {
                        updateData.Plan_Field_Sow = formatDateForSheet(planting.planFieldSow || planting.fieldStartDate);
                    } else {
                        updateData.Plan_Transplant = formatDateForSheet(planting.planTransplant || planting.fieldStartDate);
                    }


                    // Use GET with URL parameters to avoid CORS preflight issues
                    const params = new URLSearchParams(updateData);
                    const response = await fetch(`${API_URL}?${params.toString()}`, {
                        method: 'GET',
                        redirect: 'follow'
                    });
                    const result = await response.json();

                    if (!result.success) {
                        console.error('Update failed:', result.error);
                        showToast(`Update failed: ${result.error}`, 'error');
                    } else {
                    }
                }

                setSyncStatus('synced', 'Saved');
                showToast(`Saved ${saveCount} change(s) to Google Sheets`, 'success');
                updatePendingDisplay();

                // Clear all ghosts - changes are now committed
                clearAllGhosts();
            } catch (error) {
                console.error('Error saving to Google Sheets:', error);
                setSyncStatus('error', 'Save Failed');
                showToast('Failed to save changes', 'error');
                updatePendingDisplay();
            }
        }

        // Sync Status Indicator
        function setSyncStatus(status, text) {
            const indicator = document.getElementById('syncIndicator');
            const textEl = document.getElementById('syncText');

            indicator.className = `sync-indicator ${status}`;
            textEl.textContent = text;
        }

        // Edit Modal Functions
        let currentEditingPlanting = null;

        function openEditModal(id) {
            const planting = plantings.find(p => p.id === id);
            if (!planting) return;

            currentEditingPlanting = planting;

            // Populate form fields
            document.getElementById('editBatchId').value = planting.id;
            document.getElementById('editCrop').value = planting.crop || '';
            document.getElementById('editVariety').value = planting.variety || '';
            document.getElementById('editField').value = planting.field || '';
            document.getElementById('editBed').value = planting.bedNum || '';
            document.getElementById('editBedFeet').value = planting.bedFeet || '';
            document.getElementById('editDTM').value = planting.dtm || planting.DTM || planting.daysToMaturity || '';
            document.getElementById('editHarvestWindow').value = planting.harvestWindow || '';
            document.getElementById('editNotes').value = planting.notes || '';

            // Format dates for date inputs (YYYY-MM-DD)
            const formatForInput = (dateStr) => {
                if (!dateStr) return '';
                try {
                    const date = new Date(dateStr);
                    if (isNaN(date.getTime())) return '';
                    return date.toISOString().split('T')[0];
                } catch (e) {
                    return '';
                }
            };

            const formatDisplay = (dateStr) => {
                if (!dateStr) return '--';
                try {
                    const date = new Date(dateStr);
                    if (isNaN(date.getTime())) return '--';
                    return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                } catch (e) {
                    return '--';
                }
            };

            // Determine planting method
            const method = planting.method || planting.plantingMethod ||
                          (planting.planGHSow || planting.seedDate ? 'Transplant' : 'Direct Seed');

            if (method === 'Direct Seed') {
                document.getElementById('methodDirect').checked = true;
            } else {
                document.getElementById('methodTransplant').checked = true;
            }
            updateMethodFields();

            // Populate dates
            document.getElementById('editGHSow').value = formatForInput(planting.planGHSow || planting.seedDate);
            document.getElementById('editTransplant').value = formatForInput(planting.planTransplant || planting.fieldStartDate);
            document.getElementById('editFieldSow').value = formatForInput(planting.fieldSow || planting.planTransplant || planting.fieldStartDate);
            document.getElementById('editFirstHarvest').value = formatForInput(planting.firstHarvest);
            document.getElementById('editLastHarvest').value = formatForInput(planting.harvestDate || planting.lastHarvest);

            // Update modal header info
            const icon = cropIcons[planting.crop] || 'üå±';
            document.getElementById('editModalIcon').textContent = icon;
            document.getElementById('editModalCropName').textContent = `${planting.crop || 'Unknown Crop'} - ${planting.variety || 'Unknown Variety'}`;
            document.getElementById('editModalBatchId').textContent = `Batch ID: ${planting.id}`;

            // Build current schedule display
            let scheduleHTML = '';
            const ghSow = planting.planGHSow || planting.seedDate;
            const transplant = planting.planTransplant || planting.fieldStartDate;
            const firstHarvest = planting.firstHarvest;
            const lastHarvest = planting.harvestDate || planting.lastHarvest;

            if (method === 'Transplant' || ghSow) {
                scheduleHTML += `<div style="display: flex; gap: 2rem; flex-wrap: wrap;">`;
                scheduleHTML += `<span><strong>GH Sow:</strong> ${formatDisplay(ghSow)}</span>`;
                scheduleHTML += `<span><strong>Transplant:</strong> ${formatDisplay(transplant)}</span>`;
                scheduleHTML += `<span><strong>First Harvest:</strong> ${formatDisplay(firstHarvest)}</span>`;
                scheduleHTML += `<span><strong>Last Harvest:</strong> ${formatDisplay(lastHarvest)}</span>`;
                scheduleHTML += `</div>`;
            } else {
                scheduleHTML += `<div style="display: flex; gap: 2rem; flex-wrap: wrap;">`;
                scheduleHTML += `<span><strong>Field Sow:</strong> ${formatDisplay(transplant)}</span>`;
                scheduleHTML += `<span><strong>First Harvest:</strong> ${formatDisplay(firstHarvest)}</span>`;
                scheduleHTML += `<span><strong>Last Harvest:</strong> ${formatDisplay(lastHarvest)}</span>`;
                scheduleHTML += `</div>`;
            }
            scheduleHTML += `<div style="margin-top: 0.5rem; color: var(--text-secondary);"><strong>Location:</strong> Field ${planting.field || '--'}${planting.bed ? ` / Bed ${planting.bed}` : ''} | <strong>Bed Feet:</strong> ${planting.bedFeet || '--'}</div>`;

            document.getElementById('editCurrentSchedule').innerHTML = scheduleHTML;

            // Show modal
            document.getElementById('editModal').classList.add('active');
        }

        function updateMethodFields() {
            const isTransplant = document.getElementById('methodTransplant').checked;
            const transplantDates = document.getElementById('transplantDates');
            const directSeedDates = document.getElementById('directSeedDates');

            if (isTransplant) {
                transplantDates.style.display = 'block';
                directSeedDates.style.display = 'none';
                document.getElementById('methodTransplantLabel').style.border = '2px solid var(--primary)';
                document.getElementById('methodDirectLabel').style.border = '2px solid transparent';
            } else {
                transplantDates.style.display = 'none';
                directSeedDates.style.display = 'block';
                document.getElementById('methodDirectLabel').style.border = '2px solid var(--primary)';
                document.getElementById('methodTransplantLabel').style.border = '2px solid transparent';
            }
        }

        function closeEditModal() {
            document.getElementById('editModal').classList.remove('active');
            currentEditingPlanting = null;
        }

        async function saveEditModal() {
            if (!currentEditingPlanting) return;

            const saveBtn = document.getElementById('editSaveBtn');
            saveBtn.disabled = true;
            saveBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Saving...';

            try {
                const isTransplant = document.getElementById('methodTransplant').checked;
                const plantingMethod = isTransplant ? 'Transplant' : 'Direct Seed';

                // Construct Target_Bed_ID from field and bed number
                const fieldVal = document.getElementById('editField').value;
                const bedNum = document.getElementById('editBed').value;
                const targetBedId = fieldVal ? `Field ${fieldVal}-${bedNum || '01'}` : '';

                const updateData = {
                    action: 'updatePlanting',
                    id: document.getElementById('editBatchId').value,
                    Crop: document.getElementById('editCrop').value,
                    Variety: document.getElementById('editVariety').value,
                    Target_Bed_ID: targetBedId,
                    Feet_Used: document.getElementById('editBedFeet').value,
                    Planting_Method: plantingMethod,
                    Notes: document.getElementById('editNotes').value
                };

                // Add dates with proper formatting based on planting method
                const firstHarvest = document.getElementById('editFirstHarvest').value;
                const lastHarvest = document.getElementById('editLastHarvest').value;

                if (isTransplant) {
                    const ghSow = document.getElementById('editGHSow').value;
                    const transplant = document.getElementById('editTransplant').value;
                    if (ghSow) updateData.Plan_GH_Sow = formatDateForSheet(ghSow);
                    if (transplant) updateData.Plan_Transplant = formatDateForSheet(transplant);
                } else {
                    const fieldSow = document.getElementById('editFieldSow').value;
                    if (fieldSow) updateData.Plan_Transplant = formatDateForSheet(fieldSow);
                    // Clear GH Sow for direct seed
                    updateData.Plan_GH_Sow = '';
                }

                if (firstHarvest) updateData.First_Harvest = formatDateForSheet(firstHarvest);
                if (lastHarvest) updateData.Last_Harvest = formatDateForSheet(lastHarvest);

                // Use GET with URL parameters to avoid CORS preflight issues
                const params = new URLSearchParams(updateData);
                const response = await fetch(`${API_URL}?${params.toString()}`, {
                    method: 'GET',
                    redirect: 'follow'
                });

                const result = await response.json();

                if (result.success) {
                    // Update local data
                    currentEditingPlanting.crop = updateData.Crop;
                    currentEditingPlanting.variety = updateData.Variety;
                    currentEditingPlanting.field = fieldVal;
                    currentEditingPlanting.bedNum = bedNum;
                    currentEditingPlanting.bed = targetBedId;
                    currentEditingPlanting.bedFeet = parseInt(updateData.Feet_Used) || 0;
                    currentEditingPlanting.plantingMethod = plantingMethod;
                    currentEditingPlanting.notes = updateData.Notes;

                    if (isTransplant) {
                        const ghSow = document.getElementById('editGHSow').value;
                        const transplant = document.getElementById('editTransplant').value;
                        if (ghSow) currentEditingPlanting.planGHSow = ghSow;
                        if (transplant) {
                            currentEditingPlanting.planTransplant = transplant;
                            currentEditingPlanting.fieldStartDate = transplant;
                        }
                    } else {
                        const fieldSow = document.getElementById('editFieldSow').value;
                        if (fieldSow) {
                            currentEditingPlanting.planTransplant = fieldSow;
                            currentEditingPlanting.fieldStartDate = fieldSow;
                        }
                        currentEditingPlanting.planGHSow = null;
                    }

                    if (firstHarvest) currentEditingPlanting.firstHarvest = firstHarvest;
                    if (lastHarvest) currentEditingPlanting.harvestDate = lastHarvest;

                    closeEditModal();
                    applyFilters();
                    showToast('Planting updated successfully!', 'success');
                } else {
                    showToast('Failed to update: ' + (result.error || 'Unknown error'), 'error');
                }
            } catch (error) {
                console.error('Error saving planting:', error);
                showToast('Error saving planting: ' + error.message, 'error');
            } finally {
                saveBtn.disabled = false;
                saveBtn.innerHTML = '<i class="fas fa-save"></i> Save Changes';
            }
        }

        // Close modal on overlay click
        document.getElementById('editModal').addEventListener('click', function(e) {
            if (e.target === this) closeEditModal();
        });

        // Close modal on Escape key
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') closeEditModal();
        });

        // Tooltip
        function showTooltip(event, id) {
            const planting = plantings.find(p => p.id === id);
            if (!planting) return;

            const tooltip = document.getElementById('tooltip');
            const icon = cropIcons[planting.crop] || 'üå±';

            document.getElementById('tooltipIcon').textContent = icon;
            document.getElementById('tooltipTitle').textContent = planting.crop;
            document.getElementById('tooltipVariety').textContent = planting.variety;
            document.getElementById('tooltipBatchId').textContent = planting.id;
            document.getElementById('tooltipBed').textContent = planting.bed;
            document.getElementById('tooltipMethod').textContent = planting.plantingMethod || 'Transplant';

            // GH Sow date (hide row if not applicable)
            const ghRow = document.getElementById('tooltipGHRow');
            if (planting.planGHSow && planting.plantingMethod !== 'Direct Seed') {
                ghRow.style.display = 'flex';
                document.getElementById('tooltipGHSow').textContent = formatDisplayDate(planting.planGHSow);
            } else {
                ghRow.style.display = 'none';
            }

            document.getElementById('tooltipStart').textContent = formatDisplayDate(planting.fieldStartDate || planting.seedDate);
            document.getElementById('tooltipEnd').textContent = formatDisplayDate(planting.harvestDate);
            document.getElementById('tooltipDuration').textContent = `${planting.dtm} days`;
            document.getElementById('tooltipBedFeet').textContent = `${planting.bedFeet} ft`;
            document.getElementById('tooltipStatus').textContent = planting.status.charAt(0).toUpperCase() + planting.status.slice(1);

            // Lock status
            const lockRow = document.getElementById('tooltipLockRow');
            const actions = document.getElementById('tooltipActions');
            if (planting.isLocked) {
                lockRow.style.display = 'flex';
                document.getElementById('tooltipLockReason').textContent = planting.lockReason;
                actions.textContent = 'Locked - Confirm termination to edit';
                actions.style.color = '#e63946';
            } else {
                lockRow.style.display = 'none';
                actions.textContent = 'Drag to move | Resize edges to adjust dates';
                actions.style.color = 'var(--text-secondary)';
            }

            tooltip.style.left = (event.pageX + 15) + 'px';
            tooltip.style.top = (event.pageY + 15) + 'px';
            tooltip.classList.add('show');
        }

        function hideTooltip() {
            document.getElementById('tooltip').classList.remove('show');
        }

        function formatDisplayDate(dateStr) {
            const date = new Date(dateStr);
            return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
        }

        // Refresh Data
        async function refreshData() {
            showToast('Refreshing data...', 'warning');
            await loadPlantings();
            showToast('Data refreshed', 'success');
        }

        // ========================================
        // UNASSIGNED PLANTINGS PANEL
        // ========================================
        let unassignedPlantings = [];
        let unassignedFilterText = '';

        function toggleUnassignedPanel() {
            const panel = document.getElementById('unassignedPanel');
            const toggle = document.getElementById('unassignedToggle');
            panel.classList.toggle('open');
            toggle.classList.toggle('open');
        }

        // Year timeline constants for sidebar
        const SIDEBAR_YEAR_START = new Date('2026-01-01');
        const SIDEBAR_YEAR_END = new Date('2026-12-31');
        const SIDEBAR_TIMELINE_WIDTH = 380; // Width in pixels for timeline portion

        function populateUnassignedPanel() {
            // Filter plantings that are unassigned
            unassignedPlantings = plantings.filter(p =>
                p.isUnassigned || p.field === 'Unassigned' || p.field === 'Unknown' || !p.field
            );

            // Update badge and count
            const count = unassignedPlantings.length;
            document.getElementById('unassignedBadge').textContent = count;
            document.getElementById('unassignedPanelCount').textContent =
                `${count} planting${count !== 1 ? 's' : ''} need bed assignment`;

            // Group by crop
            const byCrop = {};
            unassignedPlantings.forEach(p => {
                const crop = p.crop || 'Unknown';
                if (!byCrop[crop]) byCrop[crop] = [];
                byCrop[crop].push(p);
            });

            // Build HTML - organized by crop with mini timeline
            const content = document.getElementById('unassignedContent');
            if (count === 0) {
                content.innerHTML = `
                    <div style="padding: 2rem; text-align: center; color: var(--text-secondary);">
                        <i class="fas fa-check-circle" style="font-size: 2rem; color: var(--success); margin-bottom: 1rem;"></i>
                        <p>All plantings are assigned!</p>
                    </div>
                `;
                return;
            }

            // Build month header for timeline
            const months = ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'];
            const monthHeader = `
                <div class="unassigned-timeline-header">
                    ${months.map(m => `<span>${m}</span>`).join('')}
                </div>
            `;

            let html = '';
            Object.keys(byCrop).sort().forEach(crop => {
                const items = byCrop[crop];
                const cropColor = getCropColor(crop);

                // Check if any items should be filtered
                const filteredItems = items.filter(p =>
                    !unassignedFilterText ||
                    p.crop?.toLowerCase().includes(unassignedFilterText) ||
                    p.variety?.toLowerCase().includes(unassignedFilterText) ||
                    p.id?.toLowerCase().includes(unassignedFilterText)
                );

                if (filteredItems.length === 0) return;

                // Sort items by fieldStartDate
                filteredItems.sort((a, b) => {
                    const dateA = a.fieldStartDate ? new Date(a.fieldStartDate) : new Date('2026-12-31');
                    const dateB = b.fieldStartDate ? new Date(b.fieldStartDate) : new Date('2026-12-31');
                    return dateA - dateB;
                });

                html += `
                    <div class="crop-group" data-crop="${crop}">
                        <div class="crop-group-header" onclick="toggleCropGroup(this.parentElement)">
                            <div class="crop-group-title">
                                <div class="crop-color" style="background: ${cropColor};"></div>
                                ${crop}
                            </div>
                            <span class="crop-group-count">${filteredItems.length}</span>
                        </div>
                        <div class="crop-group-items">
                            ${monthHeader}
                            ${filteredItems.map(p => buildUnassignedItem(p, cropColor)).join('')}
                        </div>
                    </div>
                `;
            });

            content.innerHTML = html || '<div style="padding: 1rem; text-align: center; color: var(--text-secondary);">No matches</div>';

            // Setup drag events for unassigned items
            setupUnassignedDrag();
        }

        function buildUnassignedItem(p, cropColor) {
            // Check for missing critical info
            const warnings = [];
            if (!p.bedFeet && p.bedFeet !== 0) warnings.push('No feet');
            if (!p.fieldStartDate) warnings.push('No dates');

            // Calculate days until action needed
            let daysUntil = null;
            let isUrgent = false;
            if (p.fieldStartDate) {
                const startDate = new Date(p.fieldStartDate);
                const today = new Date();
                today.setHours(0,0,0,0);
                daysUntil = Math.ceil((startDate - today) / (1000 * 60 * 60 * 24));
                isUrgent = daysUntil !== null && daysUntil <= 10 && daysUntil >= 0;
            }

            // Calculate bar position on timeline (0-100% of year)
            let barLeft = 0;
            let barWidth = 10; // Default width
            if (p.fieldStartDate) {
                const startDate = new Date(p.fieldStartDate);
                const yearStart = SIDEBAR_YEAR_START;
                const yearEnd = SIDEBAR_YEAR_END;
                const totalDays = (yearEnd - yearStart) / (1000 * 60 * 60 * 24);
                const daysFromStart = (startDate - yearStart) / (1000 * 60 * 60 * 24);
                barLeft = Math.max(0, Math.min(100, (daysFromStart / totalDays) * 100));

                // Calculate duration (field to harvest)
                if (p.harvestDate) {
                    const endDate = new Date(p.harvestDate);
                    const durationDays = (endDate - startDate) / (1000 * 60 * 60 * 24);
                    barWidth = Math.max(2, (durationDays / totalDays) * 100);
                } else {
                    // Default to DTM days
                    barWidth = Math.max(2, ((p.dtm || 60) / totalDays) * 100);
                }
            }

            // Format date for display
            const dateLabel = p.fieldStartDate ?
                new Date(p.fieldStartDate).toLocaleDateString('en-US', { month: 'short', day: 'numeric' }) : '';

            const urgentClass = isUrgent ? 'urgent' : '';
            const warningIcon = warnings.length > 0 ? `<i class="fas fa-exclamation-triangle" style="color: var(--warning); margin-left: 4px;" title="${warnings.join(', ')}"></i>` : '';

            return `
                <div class="unassigned-item" draggable="true"
                     data-planting-id="${p.id}"
                     data-field-start="${p.fieldStartDate || ''}"
                     data-harvest-date="${p.harvestDate || ''}">
                    <div class="unassigned-item-label">
                        <div class="variety-name">${p.variety || 'No variety'}${warningIcon}</div>
                        <div class="item-meta">${p.bedFeet ? p.bedFeet + ' ft' : ''} ${daysUntil !== null ? (daysUntil <= 0 ? '‚ö†Ô∏è NOW' : daysUntil + 'd') : ''}</div>
                    </div>
                    <div class="unassigned-item-timeline">
                        <div class="unassigned-item-bar ${urgentClass}"
                             style="left: ${barLeft}%; width: ${barWidth}%; background: ${cropColor || '#2d5a27'};"
                             title="${p.variety} - ${dateLabel}${p.bedFeet ? ' | ' + p.bedFeet + ' ft' : ''}">
                            <span class="bar-label">${dateLabel}</span>
                        </div>
                    </div>
                </div>
            `;
        }

        function toggleCropGroup(element) {
            element.classList.toggle('expanded');
        }

        function filterUnassigned(text) {
            unassignedFilterText = text.toLowerCase();
            populateUnassignedPanel();
        }

        function setupUnassignedDrag() {
            const items = document.querySelectorAll('.unassigned-item');
            items.forEach(item => {
                item.addEventListener('dragstart', (e) => {
                    // Store planting ID and planned dates for drop handler
                    const plantingData = JSON.stringify({
                        id: item.dataset.plantingId,
                        fieldStart: item.dataset.fieldStart,
                        harvestDate: item.dataset.harvestDate
                    });
                    e.dataTransfer.setData('application/json', plantingData);
                    e.dataTransfer.setData('text/plain', item.dataset.plantingId);
                    item.classList.add('dragging');

                    // Highlight potential drop zones (all gantt rows)
                    document.querySelectorAll('.gantt-row').forEach(row => {
                        row.classList.add('drop-zone-highlight');
                    });
                });

                item.addEventListener('dragend', () => {
                    item.classList.remove('dragging');
                    document.querySelectorAll('.drop-zone-highlight').forEach(el => {
                        el.classList.remove('drop-zone-highlight');
                    });
                });
            });

            // Setup drop zones on gantt rows
            setupGanttDropZones();
        }

        function setupGanttDropZones() {
            document.querySelectorAll('.gantt-row').forEach(row => {
                row.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    row.classList.add('drop-target');
                });

                row.addEventListener('dragleave', () => {
                    row.classList.remove('drop-target');
                });

                row.addEventListener('drop', (e) => {
                    e.preventDefault();
                    row.classList.remove('drop-target');

                    // Get planting data from drag
                    let plantingId, fieldStart, harvestDate;
                    try {
                        const data = JSON.parse(e.dataTransfer.getData('application/json'));
                        plantingId = data.id;
                        fieldStart = data.fieldStart;
                        harvestDate = data.harvestDate;
                    } catch {
                        plantingId = e.dataTransfer.getData('text/plain');
                    }

                    if (!plantingId) return;

                    // Get target bed info
                    const targetField = row.dataset.field;
                    const targetBed = row.dataset.bed;

                    if (!targetField || !targetBed) {
                        showToast('Cannot assign to this row', 'error');
                        return;
                    }

                    // Find the planting
                    const planting = plantings.find(p => p.id === plantingId);
                    if (!planting) {
                        showToast('Planting not found', 'error');
                        return;
                    }

                    // Use the PLANNED start date (not drop position)
                    const plannedStart = fieldStart || planting.fieldStartDate;

                    if (!plannedStart) {
                        showToast('No planned date - set dates first', 'warning');
                        return;
                    }

                    // Update planting with new bed assignment (keeping planned date)
                    updatePlantingDates(plantingId, new Date(plannedStart), null, targetField, targetBed);

                    // Update local planting data
                    planting.field = targetField;
                    planting.bed = targetBed;
                    planting.isUnassigned = false;

                    showToast(`Assigned to ${targetBed} at planned date`, 'success');

                    // Refresh displays
                    populateUnassignedPanel();
                    renderGantt();
                });
            });
        }

        // Toast
        function showToast(message, type = 'success') {
            const toast = document.getElementById('toast');
            const icon = toast.querySelector('i');

            toast.className = `toast ${type}`;
            icon.className = type === 'success' ? 'fas fa-check-circle' :
                            type === 'error' ? 'fas fa-exclamation-circle' :
                            'fas fa-sync-alt';

            document.getElementById('toastMessage').textContent = message;
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), 3000);
        }

        // ========================================
        // ADD PLANTING MODAL
        // ========================================
        let addNurseryDays = 21;
        let addDTM = 60;
        let addRows = 3;
        let addSpacing = 6;

        function openAddPlantingModal(presetDate = null) {
            // Populate crop dropdown
            const cropSelect = document.getElementById('addCrop');
            const uniqueCrops = [...new Set(cropProfiles.map(p => p.Crop))].sort();
            cropSelect.innerHTML = '<option value="">Select crop...</option>' +
                uniqueCrops.map(c => `<option value="${c}">${c}</option>`).join('') +
                '<option value="__add_new__">+ Add New Crop...</option>';

            // Reset form
            document.getElementById('addVariety').innerHTML = '<option value="">Select variety...</option>';
            document.getElementById('addNewCrop').style.display = 'none';
            document.getElementById('addNewVariety').style.display = 'none';
            document.getElementById('addMethod').value = 'Transplant';
            document.getElementById('addTraySize').value = '128';
            document.getElementById('addFeet').value = '100';
            document.getElementById('addBed').value = '';
            document.getElementById('addDateType').value = 'transplant';
            document.getElementById('addDate').value = presetDate || new Date().toISOString().split('T')[0];
            document.getElementById('addSuccessionCheck').checked = false;
            document.getElementById('addSuccessionOptions').style.display = 'none';

            updateAddPlantingSummary();

            // Show modal
            document.getElementById('addPlantingModal').classList.add('active');
        }

        function closeAddPlantingModal() {
            document.getElementById('addPlantingModal').classList.remove('active');
        }

        function onAddCropChange() {
            const crop = document.getElementById('addCrop').value;
            const varietySelect = document.getElementById('addVariety');
            const newCropInput = document.getElementById('addNewCrop');
            const newVarietyInput = document.getElementById('addNewVariety');

            if (crop === '__add_new__') {
                newCropInput.style.display = 'block';
                newCropInput.focus();
                varietySelect.innerHTML = '<option value="">Select variety...</option>' +
                    '<option value="__add_new__">+ Add New Variety...</option>';
                newVarietyInput.style.display = 'none';
                return;
            } else {
                newCropInput.style.display = 'none';
                newCropInput.value = '';
            }

            const varieties = cropProfiles
                .filter(p => p.Crop === crop)
                .map(p => p.Variety)
                .filter(v => v);
            const uniqueVarieties = [...new Set(varieties)];

            varietySelect.innerHTML = '<option value="">Select variety...</option>' +
                uniqueVarieties.map(v => `<option value="${v}">${v}</option>`).join('') +
                '<option value="__add_new__">+ Add New Variety...</option>';

            if (uniqueVarieties.length > 0) {
                varietySelect.value = uniqueVarieties[0];
                onAddVarietyChange();
            }
        }

        function onAddVarietyChange() {
            const crop = document.getElementById('addCrop').value;
            const variety = document.getElementById('addVariety').value;
            const newVarietyInput = document.getElementById('addNewVariety');

            if (variety === '__add_new__') {
                newVarietyInput.style.display = 'block';
                newVarietyInput.focus();
                // Set defaults for new variety
                document.getElementById('addMethod').value = 'Transplant';
                document.getElementById('addTraySize').value = '128';
                addNurseryDays = 21;
                addDTM = 60;
                addRows = 3;
                addSpacing = 6;
                return;
            } else {
                newVarietyInput.style.display = 'none';
                newVarietyInput.value = '';
            }

            const profile = cropProfiles.find(p => p.Crop === crop && p.Variety === variety) ||
                           cropProfiles.find(p => p.Crop === crop);

            if (profile) {
                document.getElementById('addMethod').value = profile.Planting_Method || 'Transplant';
                document.getElementById('addTraySize').value = profile.Tray_Cell_Count || '128';
                addNurseryDays = profile.Nursery_Days || 21;
                addDTM = profile.DTM || 60;
                addRows = profile.Rows_Per_Bed || 3;
                addSpacing = profile.Spacing || 6;
            }

            updateAddPlantingSummary();
        }

        function toggleAddSuccession() {
            const checked = document.getElementById('addSuccessionCheck').checked;
            document.getElementById('addSuccessionOptions').style.display = checked ? 'block' : 'none';
            updateAddPlantingSummary();
        }

        function updateAddPlantingSummary() {
            const crop = document.getElementById('addCrop').value;
            const variety = document.getElementById('addVariety').value;
            const feet = parseInt(document.getElementById('addFeet').value) || 100;
            const succession = document.getElementById('addSuccessionCheck').checked;
            const count = succession ? parseInt(document.getElementById('addSuccessionCount').value) || 1 : 1;

            if (!crop || crop === '__add_new__') {
                document.getElementById('addPlantingSummary').innerHTML =
                    '<strong>Summary:</strong> Select a crop to see planting summary';
                return;
            }

            const totalFeet = feet * count;
            const plantsPerFoot = addRows * (12 / addSpacing);
            const totalPlants = Math.ceil(totalFeet * plantsPerFoot);
            const traySize = parseInt(document.getElementById('addTraySize').value) || 128;
            const traysNeeded = Math.ceil(totalPlants / traySize);

            document.getElementById('addPlantingSummary').innerHTML = `
                <strong>Summary:</strong> ${count} planting${count > 1 ? 's' : ''} √ó ${feet} ft = ${totalFeet} total ft<br>
                <span style="color: var(--text-secondary);">
                    Plants: ~${totalPlants.toLocaleString()} | Trays: ${traysNeeded} |
                    Nursery: ${addNurseryDays} days | DTM: ${addDTM} days
                </span>
            `;
        }

        async function saveAddPlanting() {
            let crop = document.getElementById('addCrop').value;
            let variety = document.getElementById('addVariety').value;
            const method = document.getElementById('addMethod').value;
            const traySize = document.getElementById('addTraySize').value;
            const feet = document.getElementById('addFeet').value;
            const bed = document.getElementById('addBed').value;
            const dateType = document.getElementById('addDateType').value;
            const targetDate = document.getElementById('addDate').value;

            // Handle new crop/variety
            const isNewCrop = crop === '__add_new__';
            const isNewVariety = variety === '__add_new__';

            if (isNewCrop) {
                crop = document.getElementById('addNewCrop').value.trim();
                if (!crop) {
                    showToast('Please enter a crop name', 'error');
                    return;
                }
            }

            if (isNewVariety) {
                variety = document.getElementById('addNewVariety').value.trim();
                if (!variety) {
                    showToast('Please enter a variety name', 'error');
                    return;
                }
            }

            if (!crop || !targetDate) {
                showToast('Please select crop and date', 'error');
                return;
            }

            const successionEnabled = document.getElementById('addSuccessionCheck').checked;
            const successionCount = successionEnabled ? parseInt(document.getElementById('addSuccessionCount').value) : 1;
            const interval = parseInt(document.getElementById('addInterval').value) || 7;
            const intervalUnit = document.getElementById('addIntervalUnit').value;
            const intervalDays = intervalUnit === 'weeks' ? interval * 7 : interval;

            try {
                // Create new crop profile if adding new crop or variety
                if (isNewCrop || isNewVariety) {
                    const profileParams = new URLSearchParams({
                        action: 'createCropProfile',
                        crop: crop,
                        variety: variety || 'Standard',
                        plantingMethod: method,
                        trayCellCount: traySize,
                        nurseryDays: addNurseryDays,
                        dtm: addDTM,
                        rowsPerBed: addRows,
                        spacing: addSpacing
                    });

                    const profileResponse = await fetch(`${API_URL}?${profileParams}`);
                    const profileResult = await profileResponse.json();

                    if (profileResult.success) {
                        showToast(`New ${isNewCrop ? 'crop' : 'variety'} added!`, 'success');
                    }
                }

                // Save plantings
                for (let i = 0; i < successionCount; i++) {
                    const offsetDays = i * intervalDays;
                    const plantingDate = new Date(targetDate);
                    plantingDate.setDate(plantingDate.getDate() + offsetDays);

                    const params = new URLSearchParams({
                        action: 'savePlanting',
                        crop: crop,
                        variety: variety || 'Standard',
                        method: method,
                        traySize: traySize,
                        feet: feet,
                        Target_Bed_ID: bed,
                        dateType: dateType,
                        targetDate: plantingDate.toISOString().split('T')[0],
                        nurseryDays: addNurseryDays,
                        dtm: addDTM,
                        rows: addRows,
                        spacing: addSpacing
                    });

                    await fetch(`${API_URL}?${params}`);
                }

                showToast(`${successionCount} planting(s) added!`, 'success');
                closeAddPlantingModal();

                // Refresh calendar
                await loadPlantings();

            } catch (error) {
                console.error('Error saving planting:', error);
                showToast('Error saving planting', 'error');
            }
        }

        // Close add modal on overlay click
        document.getElementById('addPlantingModal').addEventListener('click', function(e) {
            if (e.target === this) closeAddPlantingModal();
        });

        // Close add modal on Escape key
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                closeAddPlantingModal();
                closeEditModal();
                closePlanningAssistant();
            }
        });

        // ========================================
        // PLANNING ASSISTANT - AI CHAT INTERFACE
        // ========================================
        let assistantOpen = false;
        let assistantMessages = [];
        let assistantSuggestions = [];
        let isAssistantProcessing = false;

        // Toggle the planning assistant panel
        function togglePlanningAssistant() {
            assistantOpen = !assistantOpen;
            const panel = document.getElementById('assistantPanel');
            const toggle = document.getElementById('assistantToggle');

            if (assistantOpen) {
                panel.classList.add('open');
                toggle.style.display = 'none';
                document.getElementById('assistantInput').focus();
                // Load suggestions when opened
                loadAssistantSuggestions();
            } else {
                panel.classList.remove('open');
                toggle.style.display = 'flex';
            }
        }

        function closePlanningAssistant() {
            if (assistantOpen) {
                assistantOpen = false;
                document.getElementById('assistantPanel').classList.remove('open');
                document.getElementById('assistantToggle').style.display = 'flex';
            }
        }

        // Load proactive suggestions based on current data
        async function loadAssistantSuggestions() {
            const suggestionsContainer = document.getElementById('assistantSuggestions');

            // Generate suggestions from current planning data
            const suggestions = [];

            // Check for unassigned plantings
            const unassignedCount = unassignedPlantings.length;
            if (unassignedCount > 0) {
                suggestions.push({
                    icon: '‚ö†Ô∏è',
                    text: `${unassignedCount} plantings need bed assignment`,
                    action: `Assign ${unassignedCount} unassigned plantings`,
                    type: 'warning'
                });
            }

            // Check for urgent plantings (within 10 days)
            const urgentPlantings = unassignedPlantings.filter(p => {
                if (!p.fieldStartDate) return false;
                const startDate = new Date(p.fieldStartDate);
                const today = new Date();
                const daysUntil = Math.ceil((startDate - today) / (1000 * 60 * 60 * 24));
                return daysUntil <= 10 && daysUntil >= 0;
            });

            if (urgentPlantings.length > 0) {
                suggestions.push({
                    icon: 'üö®',
                    text: `${urgentPlantings.length} plantings urgent - transplant within 10 days`,
                    action: `Show urgent plantings`,
                    type: 'critical'
                });
            }

            // Check for available beds this month
            const availableBeds = getAvailableBedsThisMonth();
            if (availableBeds.length > 0) {
                suggestions.push({
                    icon: 'üå±',
                    text: `${availableBeds.length} beds available this month`,
                    action: `Show available beds`,
                    type: 'info'
                });
            }

            assistantSuggestions = suggestions;
            renderSuggestions();
        }

        function getAvailableBedsThisMonth() {
            // Get beds that are free this month based on current plantings
            const now = new Date();
            const monthStart = new Date(now.getFullYear(), now.getMonth(), 1);
            const monthEnd = new Date(now.getFullYear(), now.getMonth() + 1, 0);

            // Get occupied beds for this month
            const occupiedBeds = new Set();
            plantings.forEach(p => {
                if (p.isUnassigned) return;
                const start = new Date(p.fieldStartDate);
                const end = new Date(p.harvestDate);
                if (start <= monthEnd && end >= monthStart) {
                    occupiedBeds.add(p.bed);
                }
            });

            // Return beds not occupied (simplified - would need full bed list)
            return [...allBeds].filter(bed => !occupiedBeds.has(bed)).slice(0, 10);
        }

        function renderSuggestions() {
            const container = document.getElementById('assistantSuggestions');
            if (assistantSuggestions.length === 0) {
                container.innerHTML = '';
                return;
            }

            container.innerHTML = assistantSuggestions.map((s, i) => `
                <div class="suggestion-card" onclick="handleSuggestion(${i})">
                    <span class="suggestion-icon">${s.icon}</span>
                    <span class="suggestion-text">${s.text}</span>
                    <div class="suggestion-meta">Click to: ${s.action}</div>
                </div>
            `).join('');

            // Update badge count
            updateAssistantBadge(assistantSuggestions.length);
        }

        function updateAssistantBadge(count) {
            const badge = document.getElementById('assistantBadge');
            const toggle = document.getElementById('assistantToggle');

            badge.textContent = count;
            badge.setAttribute('data-count', count);

            if (count > 0) {
                toggle.classList.add('has-suggestions');
            } else {
                toggle.classList.remove('has-suggestions');
            }
        }

        function handleSuggestion(index) {
            const suggestion = assistantSuggestions[index];
            // Add as user message and process
            addAssistantMessage('user', suggestion.action);
            processAssistantMessage(suggestion.action);
        }

        // Send a message to the assistant
        function sendAssistantMessage() {
            const input = document.getElementById('assistantInput');
            const message = input.value.trim();

            if (!message || isAssistantProcessing) return;

            // Add user message
            addAssistantMessage('user', message);
            input.value = '';

            // Process the message
            processAssistantMessage(message);
        }

        function addAssistantMessage(role, content, actions = null) {
            const messagesContainer = document.getElementById('assistantMessages');

            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${role}`;

            let html = content;

            if (actions && actions.length > 0) {
                html += '<div class="message-actions">';
                actions.forEach(action => {
                    const btnClass = action.primary ? 'primary' : action.danger ? 'danger' : '';
                    html += `<button class="message-action-btn ${btnClass}" onclick="${action.onclick}">${action.label}</button>`;
                });
                html += '</div>';
            }

            messageDiv.innerHTML = html;
            messagesContainer.appendChild(messageDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;

            assistantMessages.push({ role, content, actions });
        }

        function showTypingIndicator() {
            const messagesContainer = document.getElementById('assistantMessages');
            const typing = document.createElement('div');
            typing.className = 'message assistant typing';
            typing.id = 'typingIndicator';
            typing.innerHTML = '<div class="dots"><span class="dot"></span><span class="dot"></span><span class="dot"></span></div>';
            messagesContainer.appendChild(typing);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        function hideTypingIndicator() {
            const typing = document.getElementById('typingIndicator');
            if (typing) typing.remove();
        }

        // Conversation history for AI context
        let conversationHistory = [];

        // Process user message and generate response
        async function processAssistantMessage(message) {
            isAssistantProcessing = true;
            showTypingIndicator();

            // Add user message to history
            conversationHistory.push({ role: 'user', content: message });

            try {
                // Parse intent from message
                const intent = parseAssistantIntent(message);

                // Handle locally for known planning-specific intents (faster)
                let response;
                let useLocalHandler = true;

                switch (intent.type) {
                    case 'query_unassigned':
                        response = handleQueryUnassigned();
                        break;
                    case 'query_available_beds':
                        response = handleQueryAvailableBeds(intent);
                        break;
                    case 'query_urgent':
                        response = handleQueryUrgent();
                        break;
                    case 'move_planting':
                        response = handleMovePlanting(intent);
                        break;
                    case 'when_to_plant':
                        response = handleWhenToPlant(intent);
                        break;
                    case 'check_conflicts':
                        response = handleCheckConflicts();
                        break;
                    case 'check_gaps':
                        response = handleCheckGaps();
                        break;
                    case 'summary':
                        response = handleSummary();
                        break;
                    case 'help':
                        response = handleHelp();
                        break;
                    default:
                        // For unknown intents, call the Claude AI backend
                        useLocalHandler = false;
                        response = await callChiefOfStaffAPI(message);
                }

                hideTypingIndicator();

                if (useLocalHandler) {
                    addAssistantMessage('assistant', response.message, response.actions);
                    conversationHistory.push({ role: 'assistant', content: response.message });
                } else {
                    // AI response - format it nicely
                    const aiMessage = response.success ? response.message : 'I had trouble processing that. Try asking about unassigned plantings, bed availability, or planting dates.';
                    addAssistantMessage('assistant', aiMessage, response.actions || []);
                    conversationHistory.push({ role: 'assistant', content: aiMessage });
                }

            } catch (error) {
                hideTypingIndicator();
                const errorMsg = `Sorry, I encountered an error: ${error.message}. Please try again.`;
                addAssistantMessage('assistant', errorMsg);
                conversationHistory.push({ role: 'assistant', content: errorMsg });
            }

            // Keep conversation history manageable (last 20 messages)
            if (conversationHistory.length > 20) {
                conversationHistory = conversationHistory.slice(-20);
            }

            isAssistantProcessing = false;
        }

        // Call the Chief of Staff AI backend
        async function callChiefOfStaffAPI(message) {
            try {
                const params = new URLSearchParams({
                    action: 'chatWithChiefOfStaff',
                    message: message,
                    history: JSON.stringify(conversationHistory.slice(-10))
                });

                const response = await fetch(`${API_URL}?${params}`);
                const data = await response.json();

                if (data.success) {
                    return {
                        success: true,
                        message: formatAIResponse(data.message),
                        actions: extractActionsFromResponse(data.message)
                    };
                } else {
                    console.warn('AI API error:', data.error);
                    return {
                        success: false,
                        message: data.message || 'I had trouble understanding that. Try being more specific.',
                        actions: []
                    };
                }
            } catch (error) {
                console.error('Chief of Staff API error:', error);
                return {
                    success: false,
                    message: 'I\'m having trouble connecting to the AI. Let me help you with what I know locally.',
                    actions: [
                        { label: 'Show summary', onclick: "processAssistantMessage('summary')" },
                        { label: 'Help', onclick: "processAssistantMessage('help')" }
                    ]
                };
            }
        }

        // Format AI response for display (handle markdown-like formatting)
        function formatAIResponse(text) {
            if (!text) return '';
            return text
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')  // Bold
                .replace(/\*(.*?)\*/g, '<em>$1</em>')              // Italic
                .replace(/\n/g, '<br>')                             // Line breaks
                .replace(/‚Ä¢ /g, '&bull; ');                         // Bullets
        }

        // Extract actionable buttons from AI response
        function extractActionsFromResponse(text) {
            const actions = [];
            const lowerText = (text || '').toLowerCase();

            // Detect if AI mentioned unassigned plantings
            if (lowerText.includes('unassigned') || lowerText.includes('need bed')) {
                actions.push({ label: 'View unassigned', onclick: "processAssistantMessage('show unassigned')" });
            }

            // Detect if AI mentioned conflicts
            if (lowerText.includes('conflict') || lowerText.includes('overlap')) {
                actions.push({ label: 'Check conflicts', onclick: "processAssistantMessage('check conflicts')" });
            }

            // Detect if AI mentioned available beds
            if (lowerText.includes('available bed') || lowerText.includes('open bed')) {
                actions.push({ label: 'Available beds', onclick: "processAssistantMessage('available beds')" });
            }

            return actions.slice(0, 3); // Max 3 actions
        }

        // Enhanced intent parsing with more query types
        function parseAssistantIntent(message) {
            const lowerMsg = message.toLowerCase();
            const months = ['january', 'february', 'march', 'april', 'may', 'june',
                           'july', 'august', 'september', 'october', 'november', 'december'];

            // Extract common entities
            function extractCrop() {
                // Check plantings for crop names
                const cropNames = [...new Set(plantings.map(p => p.crop).filter(Boolean))];
                return cropNames.find(c => lowerMsg.includes(c.toLowerCase()));
            }

            function extractMonth() {
                let month = null;
                months.forEach((m, i) => {
                    if (lowerMsg.includes(m)) month = i;
                });
                return month;
            }

            // "When should I plant X for Y harvest?"
            if (lowerMsg.includes('when') && (lowerMsg.includes('plant') || lowerMsg.includes('sow'))) {
                return {
                    type: 'when_to_plant',
                    crop: extractCrop(),
                    harvestMonth: extractMonth()
                };
            }

            // "Check for conflicts" / "Any conflicts?"
            if (lowerMsg.includes('conflict') || (lowerMsg.includes('double') && lowerMsg.includes('book'))) {
                return { type: 'check_conflicts' };
            }

            // "Check for gaps" / "Harvest gaps?"
            if (lowerMsg.includes('gap') || (lowerMsg.includes('missing') && lowerMsg.includes('harvest'))) {
                return { type: 'check_gaps' };
            }

            // Query unassigned
            if (lowerMsg.includes('unassigned') || lowerMsg.includes('need bed') || lowerMsg.includes('not assigned')) {
                return { type: 'query_unassigned' };
            }

            // Query available beds
            if (lowerMsg.includes('available') && (lowerMsg.includes('bed') || lowerMsg.includes('field'))) {
                return { type: 'query_available_beds', month: extractMonth() };
            }

            // Query urgent
            if (lowerMsg.includes('urgent') || lowerMsg.includes('overdue') || lowerMsg.includes('soon')) {
                return { type: 'query_urgent' };
            }

            // Move planting
            if (lowerMsg.includes('move') || lowerMsg.includes('assign') || lowerMsg.includes('put')) {
                const cropMatch = extractCrop();
                const fieldMatch = DEFAULT_FIELDS.find(f => lowerMsg.includes(f.toLowerCase()));
                return { type: 'move_planting', crop: cropMatch, field: fieldMatch };
            }

            // Summary / Overview
            if (lowerMsg.includes('summary') || lowerMsg.includes('overview') || lowerMsg.includes('status')) {
                return { type: 'summary' };
            }

            // Help
            if (lowerMsg.includes('help') || lowerMsg === '?') {
                return { type: 'help' };
            }

            return { type: 'unknown' };
        }

        // Intent handlers
        function handleQueryUnassigned() {
            const count = unassignedPlantings.length;
            if (count === 0) {
                return {
                    message: '‚úÖ All plantings are assigned to beds! Great work.',
                    actions: []
                };
            }

            // Group by crop
            const byCrop = {};
            unassignedPlantings.forEach(p => {
                const crop = p.crop || 'Unknown';
                if (!byCrop[crop]) byCrop[crop] = [];
                byCrop[crop].push(p);
            });

            const cropSummary = Object.entries(byCrop)
                .map(([crop, items]) => `‚Ä¢ ${crop}: ${items.length}`)
                .join('<br>');

            return {
                message: `üìã **${count} unassigned plantings:**<br><br>${cropSummary}<br><br>Would you like me to suggest beds for these?`,
                actions: [
                    { label: 'üéØ Auto-assign all', onclick: 'autoAssignPlantings()', primary: true },
                    { label: 'Show sidebar', onclick: 'toggleUnassignedPanel()' }
                ]
            };
        }

        function handleQueryAvailableBeds(intent) {
            const month = intent.month !== null ? intent.month : new Date().getMonth();
            const monthNames = ['January', 'February', 'March', 'April', 'May', 'June',
                               'July', 'August', 'September', 'October', 'November', 'December'];

            // Calculate available beds for the month
            const availableByField = {};
            DEFAULT_FIELDS.forEach(field => {
                const bedCount = FIELD_CONFIG[field] || 10;
                // Count how many are occupied
                let occupiedCount = 0;
                plantings.forEach(p => {
                    if (p.field === field && !p.isUnassigned) {
                        const start = new Date(p.fieldStartDate);
                        const end = new Date(p.harvestDate);
                        const monthStart = new Date(2026, month, 1);
                        const monthEnd = new Date(2026, month + 1, 0);
                        if (start <= monthEnd && end >= monthStart) {
                            occupiedCount++;
                        }
                    }
                });
                const available = Math.max(0, bedCount - occupiedCount);
                if (available > 0) {
                    availableByField[field] = available;
                }
            });

            const fieldSummary = Object.entries(availableByField)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 8)
                .map(([field, count]) => `‚Ä¢ ${field}: ${count} beds`)
                .join('<br>');

            const totalAvailable = Object.values(availableByField).reduce((a, b) => a + b, 0);

            return {
                message: `üå± **Available beds in ${monthNames[month]}:** ${totalAvailable} total<br><br>${fieldSummary || 'All beds occupied'}`,
                actions: [
                    { label: 'View calendar', onclick: 'setZoom("month")' }
                ]
            };
        }

        function handleQueryUrgent() {
            const urgent = unassignedPlantings.filter(p => {
                if (!p.fieldStartDate) return false;
                const startDate = new Date(p.fieldStartDate);
                const today = new Date();
                const daysUntil = Math.ceil((startDate - today) / (1000 * 60 * 60 * 24));
                return daysUntil <= 10 && daysUntil >= 0;
            });

            if (urgent.length === 0) {
                return {
                    message: '‚úÖ No urgent unassigned plantings! Everything due within 10 days has a bed.',
                    actions: []
                };
            }

            const urgentList = urgent.slice(0, 5).map(p => {
                const daysUntil = Math.ceil((new Date(p.fieldStartDate) - new Date()) / (1000 * 60 * 60 * 24));
                return `‚Ä¢ ${p.crop} ${p.variety || ''}: ${daysUntil} days`;
            }).join('<br>');

            return {
                message: `üö® **${urgent.length} urgent plantings** (need assignment within 10 days):<br><br>${urgentList}${urgent.length > 5 ? '<br>...' : ''}<br><br>These need beds ASAP!`,
                actions: [
                    { label: 'üéØ Auto-assign urgent', onclick: 'autoAssignUrgent()', primary: true },
                    { label: 'Show in sidebar', onclick: 'toggleUnassignedPanel()' }
                ]
            };
        }

        function handleMovePlanting(intent) {
            if (!intent.crop && !intent.field) {
                return {
                    message: `I can help you move plantings! Please specify:<br><br>‚Ä¢ **Crop:** Which crop to move (e.g., Tomato, Lettuce)<br>‚Ä¢ **Field:** Where to move it (e.g., JS6, F3L)<br><br>Example: "Move Tomato plantings to JS6"`,
                    actions: []
                };
            }

            if (intent.crop && !intent.field) {
                // Find where this crop could go
                const cropPlantings = unassignedPlantings.filter(p =>
                    p.crop?.toLowerCase() === intent.crop.toLowerCase()
                );

                if (cropPlantings.length === 0) {
                    return {
                        message: `No unassigned ${intent.crop} plantings found. All ${intent.crop} plantings are already assigned.`,
                        actions: []
                    };
                }

                return {
                    message: `Found **${cropPlantings.length} unassigned ${intent.crop}** plantings. Which field would you like to move them to?<br><br>Available fields: ${DEFAULT_FIELDS.slice(0, 8).join(', ')}...`,
                    actions: DEFAULT_FIELDS.slice(0, 4).map(f => ({
                        label: f,
                        onclick: `executeMoveCommand('${intent.crop}', '${f}')`
                    }))
                };
            }

            if (intent.crop && intent.field) {
                // Preview the move
                const cropPlantings = unassignedPlantings.filter(p =>
                    p.crop?.toLowerCase() === intent.crop.toLowerCase()
                );

                if (cropPlantings.length === 0) {
                    return {
                        message: `No unassigned ${intent.crop} plantings to move.`,
                        actions: []
                    };
                }

                return {
                    message: `üìã **Preview: Move ${cropPlantings.length} ${intent.crop} to ${intent.field}**<br><br>` +
                        `<div class="preview-box">` +
                        cropPlantings.slice(0, 3).map(p => `<div class="preview-row"><span>${p.variety || 'Standard'}</span><span class="changed">‚Üí ${intent.field}</span></div>`).join('') +
                        (cropPlantings.length > 3 ? `<div class="preview-row"><span>...and ${cropPlantings.length - 3} more</span></div>` : '') +
                        `</div>`,
                    actions: [
                        { label: '‚úÖ Confirm Move', onclick: `executeMoveCommand('${intent.crop}', '${intent.field}')`, primary: true },
                        { label: 'Cancel', onclick: 'addAssistantMessage("assistant", "Move cancelled.")', danger: true }
                    ]
                };
            }

            return {
                message: `Please specify which crop to move to ${intent.field}.`,
                actions: []
            };
        }

        function handleHelp() {
            return {
                message: `üå± **Planning Assistant Help**<br><br>` +
                    `**Queries:**<br>` +
                    `‚Ä¢ "Show unassigned plantings"<br>` +
                    `‚Ä¢ "What beds are available in May?"<br>` +
                    `‚Ä¢ "Show urgent plantings"<br>` +
                    `‚Ä¢ "Give me a summary"<br><br>` +
                    `**Smart Planning:**<br>` +
                    `‚Ä¢ "When should I plant Lettuce for June harvest?"<br>` +
                    `‚Ä¢ "Check for bed conflicts"<br>` +
                    `‚Ä¢ "Check for harvest gaps"<br><br>` +
                    `**Actions:**<br>` +
                    `‚Ä¢ "Move Tomato to JS6"<br>` +
                    `‚Ä¢ "Assign Lettuce to F3L"<br><br>` +
                    `**Tips:**<br>` +
                    `‚Ä¢ Click suggestions at the top for proactive alerts<br>` +
                    `‚Ä¢ Use the sidebar to drag plantings to beds`,
                actions: [
                    { label: 'Summary', onclick: "processAssistantMessage('summary')" },
                    { label: 'Check conflicts', onclick: "processAssistantMessage('check conflicts')" }
                ]
            };
        }

        // Summary of current planning state
        function handleSummary() {
            const totalPlantings = plantings.length;
            const assigned = plantings.filter(p => !p.isUnassigned).length;
            const unassigned = unassignedPlantings.length;

            // Get stats
            const conflicts = detectBedConflicts();
            const gaps = detectHarvestGaps();
            const urgentCount = unassignedPlantings.filter(p => {
                if (!p.fieldStartDate) return false;
                const daysUntil = Math.ceil((new Date(p.fieldStartDate) - new Date()) / (1000*60*60*24));
                return daysUntil <= 10 && daysUntil >= 0;
            }).length;

            // Get unique crops
            const cropCount = new Set(plantings.map(p => p.crop)).size;

            // Get unique fields
            const fieldCount = new Set(plantings.filter(p => p.field && p.field !== 'Unassigned').map(p => p.field)).size;

            return {
                message: `üìä **Planning Summary**<br><br>` +
                    `<div class="preview-box">` +
                    `<div class="preview-row"><span>Total Plantings</span><span>${totalPlantings}</span></div>` +
                    `<div class="preview-row"><span>Assigned</span><span style="color: #22c55e">${assigned}</span></div>` +
                    `<div class="preview-row"><span>Unassigned</span><span style="color: ${unassigned > 0 ? '#f59e0b' : '#22c55e'}">${unassigned}</span></div>` +
                    `<div class="preview-row"><span>Urgent (‚â§10 days)</span><span style="color: ${urgentCount > 0 ? '#ef4444' : '#22c55e'}">${urgentCount}</span></div>` +
                    `<div class="preview-row"><span>Bed Conflicts</span><span style="color: ${conflicts.length > 0 ? '#ef4444' : '#22c55e'}">${conflicts.length}</span></div>` +
                    `<div class="preview-row"><span>Harvest Gaps</span><span style="color: ${gaps.length > 3 ? '#f59e0b' : '#22c55e'}">${gaps.length} weeks</span></div>` +
                    `<div class="preview-row"><span>Crops</span><span>${cropCount}</span></div>` +
                    `<div class="preview-row"><span>Fields in Use</span><span>${fieldCount}</span></div>` +
                    `</div>`,
                actions: unassigned > 0 || conflicts.length > 0 ? [
                    unassigned > 0 ? { label: 'üéØ Auto-assign', onclick: 'autoAssignPlantings()', primary: true } : null,
                    conflicts.length > 0 ? { label: '‚ö†Ô∏è View conflicts', onclick: "processAssistantMessage('check conflicts')" } : null
                ].filter(Boolean) : []
            };
        }

        function handleGenericQuery(message) {
            return {
                message: `I'm not sure how to help with that yet. Try asking about:<br><br>` +
                    `‚Ä¢ Unassigned plantings<br>` +
                    `‚Ä¢ Available beds<br>` +
                    `‚Ä¢ Moving crops to fields<br><br>` +
                    `Or type **help** for more options.`,
                actions: [
                    { label: 'Help', onclick: "processAssistantMessage('help')" }
                ]
            };
        }

        // Execute move command
        async function executeMoveCommand(crop, field) {
            const toMove = unassignedPlantings.filter(p =>
                p.crop?.toLowerCase() === crop.toLowerCase()
            );

            if (toMove.length === 0) {
                addAssistantMessage('assistant', `No ${crop} plantings to move.`);
                return;
            }

            showTypingIndicator();

            // Assign to available beds in the field
            let assignedCount = 0;
            const availableBedNumbers = Array.from({length: FIELD_CONFIG[field] || 10}, (_, i) => i + 1);

            for (const planting of toMove) {
                if (availableBedNumbers.length === 0) break;

                const bedNum = availableBedNumbers.shift();
                const bedId = `Field ${field}-${String(bedNum).padStart(2, '0')}`;

                // Update local data
                planting.field = field;
                planting.bed = bedId;
                planting.isUnassigned = false;

                // Queue update for backend
                pendingUpdates.set(planting.id, {
                    Target_Bed_ID: bedId
                });

                assignedCount++;
            }

            hideTypingIndicator();

            // Refresh displays
            populateUnassignedPanel();
            renderGantt();

            addAssistantMessage('assistant',
                `‚úÖ **Moved ${assignedCount} ${crop} plantings to ${field}!**<br><br>` +
                `Changes are pending. Click "Submit Changes" to save to Google Sheets.`,
                [{ label: 'Submit Changes', onclick: 'saveToGoogleSheets()', primary: true }]
            );
        }

        // Auto-assign all unassigned plantings
        async function autoAssignPlantings() {
            addAssistantMessage('assistant', 'üîÑ Auto-assigning plantings to available beds...');
            showTypingIndicator();

            // Group by crop and assign to fields
            let assignedCount = 0;
            const byCrop = {};
            unassignedPlantings.forEach(p => {
                const crop = p.crop || 'Unknown';
                if (!byCrop[crop]) byCrop[crop] = [];
                byCrop[crop].push(p);
            });

            // Simple assignment: spread across fields
            const fieldIndex = {};
            DEFAULT_FIELDS.forEach(f => fieldIndex[f] = 1);

            Object.entries(byCrop).forEach(([crop, items]) => {
                // Pick a field for this crop (round-robin)
                const fieldKeys = Object.keys(fieldIndex);
                const fieldForCrop = fieldKeys[assignedCount % fieldKeys.length];

                items.forEach(p => {
                    const bedNum = fieldIndex[fieldForCrop]++;
                    if (bedNum <= (FIELD_CONFIG[fieldForCrop] || 10)) {
                        const bedId = `Field ${fieldForCrop}-${String(bedNum).padStart(2, '0')}`;
                        p.field = fieldForCrop;
                        p.bed = bedId;
                        p.isUnassigned = false;
                        pendingUpdates.set(p.id, { Target_Bed_ID: bedId });
                        assignedCount++;
                    }
                });
            });

            hideTypingIndicator();
            populateUnassignedPanel();
            renderGantt();

            addAssistantMessage('assistant',
                `‚úÖ **Auto-assigned ${assignedCount} plantings!**<br><br>` +
                `Click "Submit Changes" to save to Google Sheets.`,
                [{ label: 'Submit Changes', onclick: 'saveToGoogleSheets()', primary: true }]
            );
        }

        // Auto-assign only urgent plantings
        async function autoAssignUrgent() {
            const urgent = unassignedPlantings.filter(p => {
                if (!p.fieldStartDate) return false;
                const daysUntil = Math.ceil((new Date(p.fieldStartDate) - new Date()) / (1000 * 60 * 60 * 24));
                return daysUntil <= 10 && daysUntil >= 0;
            });

            if (urgent.length === 0) {
                addAssistantMessage('assistant', 'No urgent plantings to assign!');
                return;
            }

            showTypingIndicator();

            let assignedCount = 0;
            const fieldIndex = {};
            DEFAULT_FIELDS.forEach(f => fieldIndex[f] = 1);

            urgent.forEach((p, i) => {
                const field = DEFAULT_FIELDS[i % DEFAULT_FIELDS.length];
                const bedNum = fieldIndex[field]++;
                const bedId = `Field ${field}-${String(bedNum).padStart(2, '0')}`;

                p.field = field;
                p.bed = bedId;
                p.isUnassigned = false;
                pendingUpdates.set(p.id, { Target_Bed_ID: bedId });
                assignedCount++;
            });

            hideTypingIndicator();
            populateUnassignedPanel();
            renderGantt();

            addAssistantMessage('assistant',
                `‚úÖ **Assigned ${assignedCount} urgent plantings!**<br><br>` +
                `These are the plantings that need to go in the ground within 10 days.`,
                [{ label: 'Submit Changes', onclick: 'saveToGoogleSheets()', primary: true }]
            );
        }

        // ========================================
        // SPRINT 2: PROACTIVE INTELLIGENCE
        // ========================================

        // Detect bed conflicts (double-booked beds)
        function detectBedConflicts() {
            const conflicts = [];
            const bedTimelines = {};

            plantings.forEach(p => {
                if (p.isUnassigned || !p.bed) return;
                const key = p.bed;
                if (!bedTimelines[key]) bedTimelines[key] = [];
                bedTimelines[key].push({
                    start: new Date(p.fieldStartDate || p.seedDate),
                    end: new Date(p.harvestDate),
                    planting: p
                });
            });

            // Check overlaps
            Object.entries(bedTimelines).forEach(([bed, intervals]) => {
                intervals.sort((a, b) => a.start - b.start);
                for (let i = 0; i < intervals.length - 1; i++) {
                    if (intervals[i].end > intervals[i+1].start) {
                        conflicts.push({
                            type: 'bed_conflict',
                            priority: 1,
                            bed: bed,
                            planting1: intervals[i].planting,
                            planting2: intervals[i+1].planting,
                            overlapDays: Math.ceil((intervals[i].end - intervals[i+1].start) / (1000*60*60*24))
                        });
                    }
                }
            });

            return conflicts;
        }

        // Detect harvest gaps (weeks with no harvests)
        function detectHarvestGaps() {
            const gaps = [];
            const harvestByWeek = {};

            // Build harvest timeline
            plantings.forEach(p => {
                if (!p.harvestDate) return;
                const harvestStart = new Date(p.harvestDate);
                const weekNum = getWeekOfYear(harvestStart);
                if (!harvestByWeek[weekNum]) harvestByWeek[weekNum] = [];
                harvestByWeek[weekNum].push(p);
            });

            // Check for gaps in growing season (weeks 15-45 roughly April-November)
            for (let week = 15; week <= 42; week++) {
                if (!harvestByWeek[week] || harvestByWeek[week].length === 0) {
                    gaps.push({
                        type: 'harvest_gap',
                        priority: 2,
                        week: week,
                        date: weekToDate(week)
                    });
                }
            }

            return gaps;
        }

        function getWeekOfYear(date) {
            const d = new Date(date);
            d.setHours(0, 0, 0, 0);
            d.setDate(d.getDate() + 4 - (d.getDay() || 7));
            const yearStart = new Date(d.getFullYear(), 0, 1);
            return Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
        }

        function weekToDate(weekNum) {
            const d = new Date(2026, 0, 1);
            d.setDate(d.getDate() + (weekNum - 1) * 7);
            return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
        }

        // Check planting windows (plantings approaching deadline)
        function checkPlantingWindows() {
            const alerts = [];
            const today = new Date();

            plantings.forEach(p => {
                if (!p.fieldStartDate || !p.isUnassigned) return;

                const startDate = new Date(p.fieldStartDate);
                const daysUntil = Math.ceil((startDate - today) / (1000*60*60*24));

                if (daysUntil <= 5 && daysUntil >= 0) {
                    alerts.push({
                        type: 'window_closing',
                        priority: 1,
                        planting: p,
                        daysUntil: daysUntil
                    });
                } else if (daysUntil < 0 && daysUntil >= -7) {
                    alerts.push({
                        type: 'window_missed',
                        priority: 0,
                        planting: p,
                        daysPast: Math.abs(daysUntil)
                    });
                }
            });

            return alerts;
        }

        // Calculate when to plant for target harvest
        function calculatePlantingDate(crop, targetHarvestDate) {
            // Find crop profile for DTM
            const profile = cropProfiles.find(p => p.Crop?.toLowerCase() === crop.toLowerCase());
            const dtm = profile?.DTM || 60;
            const nurseryDays = profile?.Nursery_Days || 21;
            const isTransplant = profile?.Method === 'Transplant';

            const harvestDate = new Date(targetHarvestDate);
            const fieldDate = new Date(harvestDate);
            fieldDate.setDate(fieldDate.getDate() - dtm);

            let sowDate = fieldDate;
            if (isTransplant) {
                sowDate = new Date(fieldDate);
                sowDate.setDate(sowDate.getDate() - nurseryDays);
            }

            return {
                crop: crop,
                harvestDate: harvestDate,
                fieldDate: fieldDate,
                sowDate: sowDate,
                dtm: dtm,
                nurseryDays: isTransplant ? nurseryDays : 0,
                method: isTransplant ? 'Transplant' : 'Direct Seed'
            };
        }

        // Handle "when to plant" queries
        function handleWhenToPlant(intent) {
            const crop = intent.crop || 'Lettuce';
            const harvestMonth = intent.harvestMonth;

            // Default to 3 months from now if not specified
            let targetDate = new Date();
            if (harvestMonth !== null && harvestMonth !== undefined) {
                targetDate = new Date(2026, harvestMonth, 15);
            } else {
                targetDate.setMonth(targetDate.getMonth() + 3);
            }

            const result = calculatePlantingDate(crop, targetDate);

            const formatDate = d => d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });

            return {
                message: `üå± **${crop} for ${formatDate(result.harvestDate)} harvest:**<br><br>` +
                    `<div class="preview-box">` +
                    `<div class="preview-row"><span>Method</span><span>${result.method}</span></div>` +
                    (result.nurseryDays > 0 ? `<div class="preview-row"><span>GH Sow Date</span><span class="changed">${formatDate(result.sowDate)}</span></div>` : '') +
                    `<div class="preview-row"><span>Field Date</span><span class="changed">${formatDate(result.fieldDate)}</span></div>` +
                    `<div class="preview-row"><span>Days to Maturity</span><span>${result.dtm} days</span></div>` +
                    `</div>`,
                actions: [
                    { label: 'üìù Add this planting', onclick: `openAddPlantingWithData('${crop}', '${result.fieldDate.toISOString().split('T')[0]}')`, primary: true }
                ]
            };
        }

        // Handle conflict check query
        function handleCheckConflicts() {
            const conflicts = detectBedConflicts();

            if (conflicts.length === 0) {
                return {
                    message: '‚úÖ **No bed conflicts detected!**<br><br>All plantings have non-overlapping schedules.',
                    actions: []
                };
            }

            const conflictList = conflicts.slice(0, 5).map(c =>
                `‚Ä¢ **${c.bed}**: ${c.planting1.crop} overlaps ${c.planting2.crop} by ${c.overlapDays} days`
            ).join('<br>');

            return {
                message: `‚ö†Ô∏è **${conflicts.length} bed conflict${conflicts.length > 1 ? 's' : ''} found:**<br><br>${conflictList}`,
                actions: [
                    { label: 'Show first conflict', onclick: `highlightConflict('${conflicts[0].bed}')` }
                ]
            };
        }

        // Handle gap check query
        function handleCheckGaps() {
            const gaps = detectHarvestGaps();

            if (gaps.length === 0) {
                return {
                    message: '‚úÖ **No harvest gaps detected!**<br><br>You have harvests planned throughout the season.',
                    actions: []
                };
            }

            // Group consecutive gaps
            const gapRanges = [];
            let currentRange = null;

            gaps.forEach(g => {
                if (!currentRange || g.week !== currentRange.endWeek + 1) {
                    if (currentRange) gapRanges.push(currentRange);
                    currentRange = { startWeek: g.week, endWeek: g.week, startDate: g.date };
                } else {
                    currentRange.endWeek = g.week;
                }
            });
            if (currentRange) gapRanges.push(currentRange);

            const gapList = gapRanges.slice(0, 4).map(r =>
                r.startWeek === r.endWeek ?
                    `‚Ä¢ Week ${r.startWeek} (${r.startDate})` :
                    `‚Ä¢ Weeks ${r.startWeek}-${r.endWeek} (${r.startDate})`
            ).join('<br>');

            return {
                message: `üìä **${gaps.length} weeks with no planned harvests:**<br><br>${gapList}<br><br>Consider adding crops to fill these gaps.`,
                actions: [
                    { label: 'Suggest crops for gaps', onclick: "processAssistantMessage('suggest crops for gaps')" }
                ]
            };
        }

        // Highlight a bed on the calendar
        function highlightConflict(bedId) {
            const bedRow = document.querySelector(`[data-bed="${bedId}"]`);
            if (bedRow) {
                bedRow.style.background = 'rgba(230, 57, 70, 0.3)';
                bedRow.scrollIntoView({ behavior: 'smooth', block: 'center' });
                setTimeout(() => {
                    bedRow.style.background = '';
                }, 3000);
            }
            addAssistantMessage('assistant', `Highlighted bed ${bedId} on the calendar.`);
        }

        // Open add planting with prefilled data
        function openAddPlantingWithData(crop, fieldDate) {
            openAddPlantingModal(fieldDate);
            setTimeout(() => {
                const cropSelect = document.getElementById('addCrop');
                if (cropSelect) {
                    cropSelect.value = crop;
                    onAddCropChange();
                }
            }, 100);
        }

        // Enhanced proactive suggestions
        async function loadAssistantSuggestionsEnhanced() {
            const suggestions = [];

            // Check for unassigned plantings
            const unassignedCount = unassignedPlantings.length;
            if (unassignedCount > 0) {
                suggestions.push({
                    icon: '‚ö†Ô∏è',
                    text: `${unassignedCount} plantings need bed assignment`,
                    action: `Assign ${unassignedCount} unassigned plantings`,
                    type: 'warning',
                    priority: 2
                });
            }

            // Check for planting window alerts
            const windowAlerts = checkPlantingWindows();
            const closingWindows = windowAlerts.filter(a => a.type === 'window_closing');
            if (closingWindows.length > 0) {
                suggestions.push({
                    icon: 'üö®',
                    text: `${closingWindows.length} planting window${closingWindows.length > 1 ? 's' : ''} closing soon!`,
                    action: 'Show urgent plantings',
                    type: 'critical',
                    priority: 1
                });
            }

            // Check for bed conflicts
            const conflicts = detectBedConflicts();
            if (conflicts.length > 0) {
                suggestions.push({
                    icon: 'üí•',
                    text: `${conflicts.length} bed conflict${conflicts.length > 1 ? 's' : ''} detected`,
                    action: 'Check for conflicts',
                    type: 'critical',
                    priority: 1
                });
            }

            // Check for harvest gaps
            const gaps = detectHarvestGaps();
            if (gaps.length >= 3) {
                suggestions.push({
                    icon: 'üìä',
                    text: `${gaps.length} weeks with no planned harvests`,
                    action: 'Check for harvest gaps',
                    type: 'warning',
                    priority: 3
                });
            }

            // Sort by priority
            suggestions.sort((a, b) => a.priority - b.priority);

            assistantSuggestions = suggestions.slice(0, 5);
            renderSuggestions();

            // Also fetch AI-powered suggestions from backend (async enhancement)
            try {
                const params = new URLSearchParams({ action: 'getProactiveSuggestions' });
                const response = await fetch(`${API_URL}?${params}`);
                const data = await response.json();

                if (data && data.suggestions && Array.isArray(data.suggestions)) {
                    // Merge AI suggestions with local ones
                    const aiSuggestions = data.suggestions.map(s => ({
                        icon: s.icon || 'ü§ñ',
                        text: s.text || s.message,
                        action: s.action || s.text,
                        type: s.type || 'info',
                        priority: s.priority || 5,
                        fromAI: true
                    }));

                    // Combine and re-sort (local suggestions take priority)
                    const combined = [...assistantSuggestions, ...aiSuggestions];
                    combined.sort((a, b) => a.priority - b.priority);
                    assistantSuggestions = combined.slice(0, 5);
                    renderSuggestions();
                }
            } catch (err) {
                // Silently fail - local suggestions are already displayed
                console.log('AI suggestions not available, using local intelligence');
            }
        }

        // Initialize assistant on load
        function initPlanningAssistant() {
            // Add welcome message
            setTimeout(() => {
                addAssistantMessage('assistant',
                    `üëã Hi! I'm your Planning Assistant. I can help you:<br><br>` +
                    `‚Ä¢ Find and assign unassigned plantings<br>` +
                    `‚Ä¢ Check bed availability and conflicts<br>` +
                    `‚Ä¢ Calculate planting dates for harvests<br>` +
                    `‚Ä¢ Move crops between fields<br><br>` +
                    `Try: "When should I plant Lettuce for June harvest?"<br>` +
                    `Or: "Check for bed conflicts"`
                );

                // Load enhanced suggestions
                loadAssistantSuggestionsEnhanced();
            }, 500);
        }

        // Add to initialization
        document.addEventListener('DOMContentLoaded', function() {
            // Existing init code runs via loadPlantings...
            // Initialize assistant after a delay
            setTimeout(initPlanningAssistant, 2000);
        });
    </script>

    <!-- Planning Assistant Chat Widget -->
    <div class="planning-assistant">
        <button class="assistant-toggle" id="assistantToggle" onclick="togglePlanningAssistant()">
            <i class="fas fa-robot"></i>
            <span class="notification-badge" id="assistantBadge" data-count="0">0</span>
        </button>

        <div class="assistant-panel" id="assistantPanel">
            <div class="assistant-header">
                <div class="assistant-title">
                    <i class="fas fa-seedling"></i>
                    Planning Assistant
                </div>
                <button class="assistant-close" onclick="togglePlanningAssistant()">√ó</button>
            </div>

            <div class="assistant-suggestions" id="assistantSuggestions">
                <!-- Proactive suggestions appear here -->
            </div>

            <div class="assistant-messages" id="assistantMessages">
                <!-- Conversation history -->
            </div>

            <div class="quick-actions">
                <span class="quick-action-chip" onclick="processAssistantMessage('show unassigned')">Unassigned</span>
                <span class="quick-action-chip" onclick="processAssistantMessage('available beds')">Available beds</span>
                <span class="quick-action-chip" onclick="processAssistantMessage('urgent')">Urgent</span>
                <span class="quick-action-chip" onclick="processAssistantMessage('help')">Help</span>
            </div>

            <div class="assistant-input-area">
                <input type="text" id="assistantInput"
                       placeholder="Try: 'Move Tomato plantings to JS6'"
                       onkeypress="if(event.key==='Enter') sendAssistantMessage()">
                <button onclick="sendAssistantMessage()">
                    <i class="fas fa-paper-plane"></i>
                </button>
            </div>
        </div>
    </div>
</body>
</html>
